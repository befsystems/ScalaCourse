# Материал (Шаг 5)

## Информация о шаге

- **ID шага**: 7808144
- **Позиция**: 5
- **Тип**: text
- **Курс**: Функциональная Scala 3 для начинающих
- **Экспортирован**: 2025-12-20T22:21:38.9539237

## Содержание

# Подмена внедряемого контейнера при агрегации

Внедряемые контейнеры могут создаваться с различными состояниями, что уже позволяет видоизменять поведение основного контейнера. Однако, когда требуется более радикальное изменение логики его работы, возникает необходимость в подмене типа внедряемого контейнера.

**Подмена типа внедряемого контейнера** — это возможность использовать разные, но **совместимые **типы контейнеров, через единообразный способ обращения к ним внутри основного контейнера. Такой механизм возможен благодаря **полиморфизму**.

**Полиморфизм **— это способность программы работать с сущностями разных типов одинаковым образом. Он позволяет обрабатывать значения различных типов через общий интерфейс, то есть через один и тот же набор доступных операций.

Благодаря этому, можно использовать одни и те же приёмы работы с различными реализациями, не зная их внутреннего устройства. Это особенно удобно при создании альтернативных версий компонентов — например, для модульного тестирования, настройки разных конфигураций системы или поддержки нескольких режимов работы.

Существует несколько способов организовать подмену типа внедряемого контейнера: с использованием **трейтов (traits)**, **абстрактных классов**, **прямое наследование от реализованного класса**, **параметрического полиморфизма (generics)**, **структурных типов (structural types)** или **классовых типов** (**type class)**. Среди них самым простым является **прямое наследование от реализованного класса**.

## Подмена контейнера через прямое наследование

Для реализации подмены типа через **прямое наследование** сначала определяется тип **базового **внедряемого контейнера с **полной основной функциональностью**. Этот тип внедряемого контейнера используется внутри основного контейнера. При необходимости подмены создаётся **специализированная версия** **типа** внедряемого контейнера с помощью **наследования **(`extends`), в котором **переопределяются **или дополняются нужные части.

Основной контейнер использует внедренный контейнер **любой версии**, как будто он является **базовым**.

Такой подход проще остальных, поскольку не требует введения дополнительных **абстракций **(обобщенных конструкций) для достижения полиморфного поведения. Он очень компактен и легко реализуем, но при этом уступает альтернативным способам в гибкости и масштабировании.

**Наследование контейнера** — это способ определения **нового типа контейнера на основе существующего**. Наследующий (потомок) контейнер получает **все функции и значения** родительского контейнера, и может при необходимости их **переопределить **или дополнить.

**Синтаксис определения контейнера - наследника:**

class ChildContainerTypeName(params) extends ParentContainerTypeName(parentParams):
// дополнительные определения
override // переопределения родительских функций
super.func() // по необходимости вызов родительской версии функции

где:

- **class** — ключевое слово для определения типа динамического контейнера;

- **ChildContainerTypeName **— имя типа контейнера потомка

- **params **— параметры для конструктора контейнера потомка

- **extends** — ключевое слово для указания наследования

- **ParentContainerTypeName** — имя типа контейнера предка

- **parentParams** ** **— параметры для конструктора контейнера предка

- **override **— ключевое слово для указания на переопределение родительской функции

- **super **- доступ к родительской версии контейнера

Список параметров конструктора потомка должен **расширять **список параметров родителя.

Родительские функции, которые **не были указаны и переопределены** в потомке, появляются в потомке **неизменными**. Таким образом, необязательно указывать все родительские функции в потомке, а только те функции которые необходимо **изменить**.

В потомке можно указать **дополнительные новые функции** при необходимости, однако основной контейнер их не увидит, так как он работает как бы с **базовым типом** внедренного контейнера, в определении которого этих функций нет.

Потомок может быть **родителем для другого потомка** в другом определении. Таким образом можно определить длинную цепочку наследников. Все наследники будут **совместимы **с базовым (родительским) типом, и могут быть приняты им.



**Пример определения базового внедряемого контейнера:**

class Logger(val prefix: String):
def log(message: String): Unit =
println(s"[$prefix] $message")

def logError(message: String): Unit =
println(s"[$prefix] ERROR: $message")

**Пример определения нескольких новых версий внедряемого контейнера:**

class FileLogger(prefix: String, val filename: String) extends Logger(prefix):
// override — ключевое слово для переопределения родительской функции
override def log(message: String): Unit =
// В реальности здесь была бы запись в файл
println(s"[FILE:$filename] [$prefix] $message")

override def logError(message: String): Unit =
println(s"[FILE:$filename] [$prefix] ERROR: $message")

class VerboseLogger(prefix: String) extends Logger(prefix):
override def log(message: String): Unit =
val timestamp = java.time.LocalDateTime.now()
println(s"[$timestamp] [$prefix] $message")

override def logError(message: String): Unit =
val timestamp = java.time.LocalDateTime.now()
// Можно комбинировать свою логику с вызовом родительской функции
println(s"[$timestamp] VERBOSE ERROR DETECTED:")
super.logError(message)

class DatabaseLogger(prefix: String, val connectionString: String) extends Logger(prefix):
override def log(message: String): Unit =
// Сначала логируем как обычно
super.log(message)
// Затем сохраняем в базу данных
saveToDatabase(message)

// Добавляем новый метод, которого нет в родительском классе
def saveToDatabase(message: String): Unit =
println(s"Saving to DB [$connectionString]: $message")

// Добавляем новое значение
val maxRetries: Int = 3



**Пример определения основного контейнера:**



class DataProcessor(val logger: Logger, val dataSource: String):
def processData(): String =
logger.log("Starting data processing")
logger.log(s"Reading from: $dataSource")

// Имитация обработки данных
val result = s"Processed data from $dataSource"

logger.log("Data processing completed")
result

def handleError(error: String): Unit =
logger.logError(s"Processing failed: $error")


**Пример создания контейнеров с подменой типа:**

// Обычный консольный логгер
val processor1 = new DataProcessor(
new Logger("MAIN"),
"database.db"
)

// Файловый логгер
val processor2 = new DataProcessor(
new FileLogger("MAIN", "app.log"),
"database.db"
)

// Подробный логгер с временными метками
val processor4 = new DataProcessor(
new VerboseLogger("MAIN"),
"database.db"
)

// Логгер с сохранением в базу данных
val processor5 = new DataProcessor(
new DatabaseLogger("MAIN", "localhost:5432"),
"database.db"
)

Созданные контейнеры имеют различный процесс логирования, за счет подмены внедряемый контейнеров при создании.

---

### Полные данные JSON

<details>
<summary>Показать JSON данные</summary>

```json
{
  "name" : "text",
  "text" : "<h1 style=\"text-align:center;\">Подмена внедряемого контейнера при агрегации</h1>\n\n<p>Внедряемые контейнеры могут создаваться с различными состояниями, что уже позволяет видоизменять поведение основного контейнера. Однако, когда требуется более радикальное изменение логики его работы, возникает необходимость в подмене типа внедряемого контейнера.</p>\n\n<p><strong>Подмена типа внедряемого контейнера</strong> — это возможность использовать разные, но <strong>совместимые </strong>типы контейнеров, через единообразный способ обращения к ним внутри основного контейнера. Такой механизм возможен благодаря <strong>полиморфизму</strong>.</p>\n\n<p><strong>Полиморфизм </strong>— это способность программы работать с сущностями разных типов одинаковым образом. Он позволяет обрабатывать значения различных типов через общий интерфейс, то есть через один и тот же набор доступных операций.</p>\n\n<p>Благодаря этому, можно использовать одни и те же приёмы работы с различными реализациями, не зная их внутреннего устройства. Это особенно удобно при создании альтернативных версий компонентов — например, для модульного тестирования, настройки разных конфигураций системы или поддержки нескольких режимов работы.</p>\n\n<p>Существует несколько способов организовать подмену типа внедряемого контейнера: с использованием <strong>трейтов (traits)</strong>, <strong>абстрактных классов</strong>, <strong>прямое наследование от реализованного класса</strong>, <strong>параметрического полиморфизма (generics)</strong>, <strong>структурных типов (structural types)</strong> или <strong>классовых типов</strong>&nbsp;(<strong>type class)</strong>. Среди них самым простым является <strong>прямое наследование от реализованного класса</strong>.</p>\n\n<h2 style=\"text-align:center;\">Подмена контейнера через прямое наследование</h2>\n\n<p>Для реализации подмены типа через <strong>прямое наследование</strong> сначала определяется тип&nbsp;<strong>базового </strong>внедряемого контейнера&nbsp;с <strong>полной основной функциональностью</strong>. Этот тип внедряемого контейнера используется внутри основного контейнера. При необходимости подмены создаётся <strong>специализированная версия</strong>&nbsp;<strong>типа</strong> внедряемого контейнера с помощью <strong>наследования </strong>(<code>extends</code>), в котором&nbsp;<strong>переопределяются </strong>или дополняются нужные части.</p>\n\n<p>Основной контейнер использует внедренный контейнер <strong>любой версии</strong>, как будто он является <strong>базовым</strong>.</p>\n\n<p>Такой подход проще остальных, поскольку не требует введения дополнительных <strong>абстракций </strong>(обобщенных конструкций)&nbsp;для достижения полиморфного поведения. Он очень компактен и легко реализуем, но при этом уступает альтернативным способам в гибкости и масштабировании.</p>\n\n<p><strong>Наследование контейнера</strong> — это способ определения&nbsp;<strong>нового типа контейнера на основе существующего</strong>. Наследующий (потомок) контейнер получает <strong>все функции и значения</strong> родительского контейнера, и может при необходимости их <strong>переопределить </strong>или дополнить.&nbsp;</p>\n\n<p><strong>Синтаксис определения контейнера - наследника:</strong></p>\n\n<pre><code class=\"language-scala\">class ChildContainerTypeName(params) extends ParentContainerTypeName(parentParams):\n  // дополнительные определения\n  override // переопределения родительских функций\n  super.func() // по необходимости вызов родительской версии функции</code></pre>\n\n<p>где:</p>\n\n<ul>\n\t<li><strong>class</strong> — ключевое слово для определения типа динамического контейнера;</li>\n\t<li><strong>ChildContainerTypeName </strong>— имя типа контейнера потомка</li>\n\t<li><strong>params&nbsp;</strong>— параметры для конструктора контейнера потомка</li>\n\t<li><strong>extends</strong> — ключевое слово для указания наследования</li>\n\t<li><strong>ParentContainerTypeName</strong>&nbsp;— имя типа контейнера предка</li>\n\t<li><strong>parentParams</strong> <strong>&nbsp;</strong>— параметры для конструктора контейнера предка</li>\n\t<li><strong>override&nbsp;</strong>— ключевое слово для указания на переопределение родительской функции</li>\n\t<li><strong>super </strong>- доступ к родительской версии контейнера</li>\n</ul>\n\n<p>Список параметров конструктора потомка должен <strong>расширять </strong>список параметров родителя.</p>\n\n<p>Родительские функции, которые <strong>не были указаны и переопределены</strong> в потомке, появляются в потомке <strong>неизменными</strong>. Таким образом, необязательно указывать все родительские функции в потомке, а только те функции которые необходимо <strong>изменить</strong>.</p>\n\n<p>В потомке можно указать <strong>дополнительные новые функции</strong> при необходимости, однако основной контейнер их не увидит, так как он работает как бы с <strong>базовым типом</strong> внедренного контейнера, в определении которого этих функций нет.</p>\n\n<p>Потомок может быть <strong>родителем для другого потомка</strong> в другом определении. Таким образом можно определить длинную цепочку наследников. Все наследники будут <strong>совместимы </strong>с базовым (родительским) типом, и могут быть приняты им.</p>\n\n<p>&nbsp;</p>\n\n<p><strong>Пример определения базового внедряемого контейнера:</strong></p>\n\n<pre><code class=\"language-scala\">class Logger(val prefix: String):\n  def log(message: String): Unit = \n    println(s\"[$prefix] $message\")\n  \n  def logError(message: String): Unit =\n    println(s\"[$prefix] ERROR: $message\")</code></pre>\n\n<p><strong>Пример определения нескольких новых версий внедряемого контейнера:</strong></p>\n\n<pre><code class=\"language-scala\">class FileLogger(prefix: String, val filename: String) extends Logger(prefix):\n  // override — ключевое слово для переопределения родительской функции\n  override def log(message: String): Unit = \n    // В реальности здесь была бы запись в файл\n    println(s\"[FILE:$filename] [$prefix] $message\")\n  \n  override def logError(message: String): Unit =\n    println(s\"[FILE:$filename] [$prefix] ERROR: $message\")\n\nclass VerboseLogger(prefix: String) extends Logger(prefix):\n  override def log(message: String): Unit = \n    val timestamp = java.time.LocalDateTime.now()\n    println(s\"[$timestamp] [$prefix] $message\")\n  \n  override def logError(message: String): Unit =\n    val timestamp = java.time.LocalDateTime.now()\n    // Можно комбинировать свою логику с вызовом родительской функции\n    println(s\"[$timestamp] VERBOSE ERROR DETECTED:\")\n    super.logError(message)\n\nclass DatabaseLogger(prefix: String, val connectionString: String) extends Logger(prefix):\n  override def log(message: String): Unit = \n    // Сначала логируем как обычно\n    super.log(message)\n    // Затем сохраняем в базу данных\n    saveToDatabase(message)\n  \n  // Добавляем новый метод, которого нет в родительском классе\n  def saveToDatabase(message: String): Unit =\n    println(s\"Saving to DB [$connectionString]: $message\")\n  \n  // Добавляем новое значение\n  val maxRetries: Int = 3</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>Пример определения основного контейнера:</strong></p>\n\n<p>&nbsp;</p>\n\n<pre><code class=\"language-scala\">class DataProcessor(val logger: Logger, val dataSource: String):\n  def processData(): String =\n    logger.log(\"Starting data processing\")\n    logger.log(s\"Reading from: $dataSource\")\n    \n    // Имитация обработки данных\n    val result = s\"Processed data from $dataSource\"\n    \n    logger.log(\"Data processing completed\")\n    result\n  \n  def handleError(error: String): Unit =\n    logger.logError(s\"Processing failed: $error\")\n  </code></pre>\n\n<p><br>\n<strong>Пример создания контейнеров с подменой типа:</strong></p>\n\n<pre><code class=\"language-scala\">// Обычный консольный логгер\nval processor1 = new DataProcessor(\n  new Logger(\"MAIN\"), \n  \"database.db\"\n)\n\n// Файловый логгер\nval processor2 = new DataProcessor(\n  new FileLogger(\"MAIN\", \"app.log\"), \n  \"database.db\"\n)\n\n// Подробный логгер с временными метками\nval processor4 = new DataProcessor(\n  new VerboseLogger(\"MAIN\"), \n  \"database.db\"\n)\n\n// Логгер с сохранением в базу данных\nval processor5 = new DataProcessor(\n  new DatabaseLogger(\"MAIN\", \"localhost:5432\"),\n  \"database.db\"\n)</code></pre>\n\n<p>Созданные контейнеры имеют различный процесс логирования, за счет подмены внедряемый контейнеров при создании.<br>\n<br>\n<br>\n&nbsp;</p>",
  "video" : null,
  "options" : {
    
  },
  "subtitle_files" : [
  ],
  "is_deprecated" : false
}
```

</details>
