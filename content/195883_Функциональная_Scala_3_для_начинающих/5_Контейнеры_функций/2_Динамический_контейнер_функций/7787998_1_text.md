# Материал (Шаг 1)

## Информация о шаге

- **ID шага**: 7787998
- **Позиция**: 1
- **Тип**: text
- **Курс**: Функциональная Scala 3 для начинающих
- **Экспортирован**: 2025-12-20T22:21:38.938075

## Содержание

# Динамический контейнер функций

**Динамический контейнер функций** — это контейнер, способный **изменять свое поведение**, заранее не определенное при его описании. Это обеспечивается наличием **внутреннего состояния**, задаваемого при создании контейнера или изменяемого в процессе работы программы.

**Состояние** контейнера — это **набор значений, хранящихся внутри контейнера в данный момент времени**.

Можно создать **множество **независимых контейнеров, каждый с **собственным состоянием**.

Динамический контейнер необходимо создавать **явно**, чтобы задать ему нужное состояние.

**Как функции используют состояние контейнера?** Функции внутри контейнера могут обращаться к **состоянию** как к общим данным, доступным всему контейнеру. Это удобно, поскольку сокращает количество требуемых явных параметров функций, делая код более читаемым. Однако это нарушает принцип чистоты функций *(pure functions)*, так как результат работы функции зависит не только от её аргументов, но и от состояния контейнера.

Тем не менее:

- Если **состояние контейнера** **остается неизменным** **после создания**, то нарушение чистоты можно считать минимальным и им можно пренебречь ради удобства вызова функций. Это частый приём в стандартной библиотеке Scala.

- Использование динамического контейнера оправдано, если функции в контейнере изначально предполагают **нечистоту** или работу с **побочными эффектами** (например, ввод-вывод, доступ к внешним ресурсам).

Для создания динамического контейнера, сначала требуется определить (описать) его тип. Динамический контейнер определяется с помощью конструкции `class. `Конструкция `class `в Scala обладает широкими возможностями применения. В данном контексте мы рассматриваем её исключительно как контейнер функций, без углубления в другие варианты использования.

**Синтаксис определения типа динамического контейнера:**

class ContainerTypeName(paramName: ParamType, ...):
// определения функций и значений

где:

- **class** — ключевое слово для определения типа динамического контейнера;

- **ContainerTypeName** — придуманное имя типа контейнера (по соглашению пишется с большой буквы);

- **paramName** — придуманное имя параметра, для формирования состояния;

- **ParamType** — тип параметра.

Параметры, указываемые при определении контейнера, формируют **состояние контейнера**.

В такой форме определения состояние **недоступно извне**, а используются только функциями контейнера. Чтобы состояние было видно из контейнера, нужно добавить модификатор **`val `**перед именем параметра.

class ContainerTypeName(val paramName: ParamType, ...):
// определения функций и значений

**Пример определения типа динамического контейнера MathOperations:**

class MathOperations(val multiplier: Int, val offset: Int):
val add: (Int, Int) => Int = _ + _
def multiply(a: Int, b: Int): Int = a * b
def calculate(x: Int): Int = x * multiplier + offset

Состояние контейнера, образуемое из параметров `multiplier` и `offset `используется в теле функции `calculate .`

Все эти формы определений типа контейнера обеспечивают **неизменяемость состояния контейнера после его создания**. Другие формы определений контейнера, позволяющие менять состояние контейнера "на лету", использовать в функциональном стиле не рекомендуется, и мы их рассматривать не будем.

Для создания контейнера определенного типа, нужно указать ключевое слово **`new`** перед именем типа и указать необходимые аргументы для создания состояния:

val math2 = new MathOperations(2, 10)
val math3 = new MathOperations(3, 10)

В данном примере созданы (определены) два контейнера math2 и math3 .

**Доступ **к элементам контейнера осуществляется по имени созданного контейнера и имени элемента с помощью **точечной нотации**.

Пример доступа к элементам контейнера:

val sum = math2.add(2, 2)
val prod = math2.multiply(2, 2)
val res = math2.calculate(2)
val multiplier = math2.multiplier
val offset = math2.offset

---

### Полные данные JSON

<details>
<summary>Показать JSON данные</summary>

```json
{
  "name" : "text",
  "text" : "<h1 style=\"text-align:center;\">Динамический контейнер функций</h1>\n\n<p><strong>Динамический контейнер функций</strong> — это контейнер, способный <strong>изменять свое поведение</strong>, заранее не определенное при его описании. Это обеспечивается наличием <strong>внутреннего состояния</strong>, задаваемого при создании контейнера или изменяемого в процессе работы программы.</p>\n\n<p><strong>Состояние</strong> контейнера — это <strong>набор значений, хранящихся внутри контейнера в данный момент времени</strong>.</p>\n\n<p>Можно создать <strong>множество </strong>независимых контейнеров, каждый с <strong>собственным состоянием</strong>.</p>\n\n<p>Динамический контейнер необходимо создавать <strong>явно</strong>, чтобы задать ему нужное состояние.</p>\n\n<p><strong>Как функции используют состояние контейнера?</strong> Функции внутри контейнера могут обращаться к <strong>состоянию</strong> как к общим данным, доступным всему контейнеру. Это удобно, поскольку сокращает количество требуемых явных параметров функций, делая код более читаемым. Однако это нарушает принцип чистоты функций <em>(pure functions)</em>, так как результат работы функции зависит не только от её аргументов, но и от состояния контейнера.</p>\n\n<p>Тем не менее:</p>\n\n<ul>\n\t<li>Если <strong>состояние контейнера</strong> <strong>остается неизменным</strong> <strong>после создания</strong>, то нарушение чистоты можно считать минимальным и им можно пренебречь ради удобства вызова функций. Это частый приём в стандартной библиотеке Scala.</li>\n\t<li>Использование динамического контейнера оправдано, если функции в контейнере изначально предполагают <strong>нечистоту</strong> или работу с <strong>побочными эффектами</strong> (например, ввод-вывод, доступ к внешним ресурсам).</li>\n</ul>\n\n<p>Для создания динамического контейнера, сначала требуется определить (описать) его тип.&nbsp;Динамический контейнер определяется с помощью конструкции <code>class.&nbsp;</code>Конструкция <code>class&nbsp;</code>в Scala обладает широкими возможностями применения. В данном контексте мы рассматриваем её исключительно как контейнер функций, без углубления в другие варианты использования.</p>\n\n<p><strong>Синтаксис определения типа динамического контейнера:</strong></p>\n\n<pre><code class=\"language-scala\">class ContainerTypeName(paramName: ParamType, ...):\n  // определения функций и значений</code></pre>\n\n<p>где:</p>\n\n<ul>\n\t<li><strong>class</strong> — ключевое слово для определения типа динамического контейнера;</li>\n\t<li><strong>ContainerTypeName</strong> — придуманное имя типа контейнера (по соглашению пишется с большой буквы);</li>\n\t<li><strong>paramName</strong> — придуманное имя параметра,&nbsp;для формирования состояния;</li>\n\t<li><strong>ParamType</strong> — тип параметра.</li>\n</ul>\n\n<p>Параметры, указываемые при определении контейнера, формируют <strong>состояние контейнера</strong>.</p>\n\n<p>В такой форме определения состояние&nbsp;<strong>недоступно извне</strong>, а используются только функциями контейнера. Чтобы состояние было видно из контейнера, нужно добавить модификатор <strong><code>val </code></strong>перед именем параметра.</p>\n\n<pre><code class=\"language-scala\">class ContainerTypeName(val paramName: ParamType, ...):\n  // определения функций и значений</code></pre>\n\n<p><strong>Пример определения типа динамического контейнера MathOperations:</strong></p>\n\n<pre><code class=\"language-scala\">class MathOperations(val multiplier: Int, val offset: Int):\n  val add: (Int, Int) =&gt; Int = _ + _\n  def multiply(a: Int, b: Int): Int = a * b\n  def calculate(x: Int): Int = x * multiplier + offset</code></pre>\n\n<p>Состояние контейнера, образуемое из параметров&nbsp;<code>multiplier</code> и&nbsp;<code>offset&nbsp;</code>используется в теле функции&nbsp;<code>calculate .</code></p>\n\n<p>Все эти формы определений типа контейнера обеспечивают <strong>неизменяемость состояния контейнера после его создания</strong>. Другие формы определений контейнера, позволяющие менять состояние контейнера \"на лету\", использовать в функциональном стиле не рекомендуется, и мы их рассматривать не будем.</p>\n\n<p>Для создания контейнера определенного типа, нужно указать ключевое слово <strong><code>new</code></strong> перед именем типа и указать необходимые аргументы для создания состояния:</p>\n\n<pre><code class=\"language-scala\">val math2 = new MathOperations(2, 10)\nval math3 = new MathOperations(3, 10)</code></pre>\n\n<p>В данном примере созданы (определены) два контейнера&nbsp;&nbsp;math2 и&nbsp;math3 .</p>\n\n<p><strong>Доступ </strong>к элементам контейнера осуществляется по имени созданного контейнера и имени элемента с помощью <strong>точечной нотации</strong>.</p>\n\n<p>Пример доступа к элементам контейнера:</p>\n\n<pre><code class=\"language-scala\">val sum = math2.add(2, 2)\nval prod = math2.multiply(2, 2)\nval res = math2.calculate(2)\nval multiplier = math2.multiplier\nval offset = math2.offset </code></pre>",
  "video" : null,
  "options" : {
    
  },
  "subtitle_files" : [
  ],
  "is_deprecated" : false
}
```

</details>
