{
  "step_id" : 7808144,
  "lesson_id" : 1880282,
  "position" : 5,
  "type" : "unknown",
  "block" : {
    "name" : "text",
    "text" : "<h1 style=\"text-align:center;\">Подмена внедряемого контейнера при агрегации</h1>\n\n<p>Внедряемые контейнеры могут создаваться с различными состояниями, что уже позволяет видоизменять поведение основного контейнера. Однако, когда требуется более радикальное изменение логики его работы, возникает необходимость в подмене типа внедряемого контейнера.</p>\n\n<p><strong>Подмена типа внедряемого контейнера</strong> — это возможность использовать разные, но <strong>совместимые </strong>типы контейнеров, через единообразный способ обращения к ним внутри основного контейнера. Такой механизм возможен благодаря <strong>полиморфизму</strong>.</p>\n\n<p><strong>Полиморфизм </strong>— это способность программы работать с сущностями разных типов одинаковым образом. Он позволяет обрабатывать значения различных типов через общий интерфейс, то есть через один и тот же набор доступных операций.</p>\n\n<p>Благодаря этому, можно использовать одни и те же приёмы работы с различными реализациями, не зная их внутреннего устройства. Это особенно удобно при создании альтернативных версий компонентов — например, для модульного тестирования, настройки разных конфигураций системы или поддержки нескольких режимов работы.</p>\n\n<p>Существует несколько способов организовать подмену типа внедряемого контейнера: с использованием <strong>трейтов (traits)</strong>, <strong>абстрактных классов</strong>, <strong>прямое наследование от реализованного класса</strong>, <strong>параметрического полиморфизма (generics)</strong>, <strong>структурных типов (structural types)</strong> или <strong>классовых типов</strong>&nbsp;(<strong>type class)</strong>. Среди них самым простым является <strong>прямое наследование от реализованного класса</strong>.</p>\n\n<h2 style=\"text-align:center;\">Подмена контейнера через прямое наследование</h2>\n\n<p>Для реализации подмены типа через <strong>прямое наследование</strong> сначала определяется тип&nbsp;<strong>базового </strong>внедряемого контейнера&nbsp;с <strong>полной основной функциональностью</strong>. Этот тип внедряемого контейнера используется внутри основного контейнера. При необходимости подмены создаётся <strong>специализированная версия</strong>&nbsp;<strong>типа</strong> внедряемого контейнера с помощью <strong>наследования </strong>(<code>extends</code>), в котором&nbsp;<strong>переопределяются </strong>или дополняются нужные части.</p>\n\n<p>Основной контейнер использует внедренный контейнер <strong>любой версии</strong>, как будто он является <strong>базовым</strong>.</p>\n\n<p>Такой подход проще остальных, поскольку не требует введения дополнительных <strong>абстракций </strong>(обобщенных конструкций)&nbsp;для достижения полиморфного поведения. Он очень компактен и легко реализуем, но при этом уступает альтернативным способам в гибкости и масштабировании.</p>\n\n<p><strong>Наследование контейнера</strong> — это способ определения&nbsp;<strong>нового типа контейнера на основе существующего</strong>. Наследующий (потомок) контейнер получает <strong>все функции и значения</strong> родительского контейнера, и может при необходимости их <strong>переопределить </strong>или дополнить.&nbsp;</p>\n\n<p><strong>Синтаксис определения контейнера - наследника:</strong></p>\n\n<pre><code class=\"language-scala\">class ChildContainerTypeName(params) extends ParentContainerTypeName(parentParams):\n  // дополнительные определения\n  override // переопределения родительских функций\n  super.func() // по необходимости вызов родительской версии функции</code></pre>\n\n<p>где:</p>\n\n<ul>\n\t<li><strong>class</strong> — ключевое слово для определения типа динамического контейнера;</li>\n\t<li><strong>ChildContainerTypeName </strong>— имя типа контейнера потомка</li>\n\t<li><strong>params&nbsp;</strong>— параметры для конструктора контейнера потомка</li>\n\t<li><strong>extends</strong> — ключевое слово для указания наследования</li>\n\t<li><strong>ParentContainerTypeName</strong>&nbsp;— имя типа контейнера предка</li>\n\t<li><strong>parentParams</strong> <strong>&nbsp;</strong>— параметры для конструктора контейнера предка</li>\n\t<li><strong>override&nbsp;</strong>— ключевое слово для указания на переопределение родительской функции</li>\n\t<li><strong>super </strong>- доступ к родительской версии контейнера</li>\n</ul>\n\n<p>Список параметров конструктора потомка должен <strong>расширять </strong>список параметров родителя.</p>\n\n<p>Родительские функции, которые <strong>не были указаны и переопределены</strong> в потомке, появляются в потомке <strong>неизменными</strong>. Таким образом, необязательно указывать все родительские функции в потомке, а только те функции которые необходимо <strong>изменить</strong>.</p>\n\n<p>В потомке можно указать <strong>дополнительные новые функции</strong> при необходимости, однако основной контейнер их не увидит, так как он работает как бы с <strong>базовым типом</strong> внедренного контейнера, в определении которого этих функций нет.</p>\n\n<p>Потомок может быть <strong>родителем для другого потомка</strong> в другом определении. Таким образом можно определить длинную цепочку наследников. Все наследники будут <strong>совместимы </strong>с базовым (родительским) типом, и могут быть приняты им.</p>\n\n<p>&nbsp;</p>\n\n<p><strong>Пример определения базового внедряемого контейнера:</strong></p>\n\n<pre><code class=\"language-scala\">class Logger(val prefix: String):\n  def log(message: String): Unit = \n    println(s\"[$prefix] $message\")\n  \n  def logError(message: String): Unit =\n    println(s\"[$prefix] ERROR: $message\")</code></pre>\n\n<p><strong>Пример определения нескольких новых версий внедряемого контейнера:</strong></p>\n\n<pre><code class=\"language-scala\">class FileLogger(prefix: String, val filename: String) extends Logger(prefix):\n  // override — ключевое слово для переопределения родительской функции\n  override def log(message: String): Unit = \n    // В реальности здесь была бы запись в файл\n    println(s\"[FILE:$filename] [$prefix] $message\")\n  \n  override def logError(message: String): Unit =\n    println(s\"[FILE:$filename] [$prefix] ERROR: $message\")\n\nclass VerboseLogger(prefix: String) extends Logger(prefix):\n  override def log(message: String): Unit = \n    val timestamp = java.time.LocalDateTime.now()\n    println(s\"[$timestamp] [$prefix] $message\")\n  \n  override def logError(message: String): Unit =\n    val timestamp = java.time.LocalDateTime.now()\n    // Можно комбинировать свою логику с вызовом родительской функции\n    println(s\"[$timestamp] VERBOSE ERROR DETECTED:\")\n    super.logError(message)\n\nclass DatabaseLogger(prefix: String, val connectionString: String) extends Logger(prefix):\n  override def log(message: String): Unit = \n    // Сначала логируем как обычно\n    super.log(message)\n    // Затем сохраняем в базу данных\n    saveToDatabase(message)\n  \n  // Добавляем новый метод, которого нет в родительском классе\n  def saveToDatabase(message: String): Unit =\n    println(s\"Saving to DB [$connectionString]: $message\")\n  \n  // Добавляем новое значение\n  val maxRetries: Int = 3</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>Пример определения основного контейнера:</strong></p>\n\n<p>&nbsp;</p>\n\n<pre><code class=\"language-scala\">class DataProcessor(val logger: Logger, val dataSource: String):\n  def processData(): String =\n    logger.log(\"Starting data processing\")\n    logger.log(s\"Reading from: $dataSource\")\n    \n    // Имитация обработки данных\n    val result = s\"Processed data from $dataSource\"\n    \n    logger.log(\"Data processing completed\")\n    result\n  \n  def handleError(error: String): Unit =\n    logger.logError(s\"Processing failed: $error\")\n  </code></pre>\n\n<p><br>\n<strong>Пример создания контейнеров с подменой типа:</strong></p>\n\n<pre><code class=\"language-scala\">// Обычный консольный логгер\nval processor1 = new DataProcessor(\n  new Logger(\"MAIN\"), \n  \"database.db\"\n)\n\n// Файловый логгер\nval processor2 = new DataProcessor(\n  new FileLogger(\"MAIN\", \"app.log\"), \n  \"database.db\"\n)\n\n// Подробный логгер с временными метками\nval processor4 = new DataProcessor(\n  new VerboseLogger(\"MAIN\"), \n  \"database.db\"\n)\n\n// Логгер с сохранением в базу данных\nval processor5 = new DataProcessor(\n  new DatabaseLogger(\"MAIN\", \"localhost:5432\"),\n  \"database.db\"\n)</code></pre>\n\n<p>Созданные контейнеры имеют различный процесс логирования, за счет подмены внедряемый контейнеров при создании.<br>\n<br>\n<br>\n&nbsp;</p>",
    "video" : null,
    "options" : {
      
    },
    "subtitle_files" : [
    ],
    "is_deprecated" : false
  },
  "name" : "text",
  "course_id" : 195883,
  "course_name" : "Функциональная Scala 3 для начинающих",
  "exported_at" : "2026-01-10T10:17:34.0100506"
}