{
  "step_id" : 7787998,
  "lesson_id" : 1880282,
  "position" : 1,
  "type" : "unknown",
  "block" : {
    "name" : "text",
    "text" : "<h1 style=\"text-align:center;\">Динамический контейнер функций</h1>\n\n<p><strong>Динамический контейнер функций</strong> — это контейнер, способный <strong>изменять свое поведение</strong>, заранее не определенное при его описании. Это обеспечивается наличием <strong>внутреннего состояния</strong>, задаваемого при создании контейнера или изменяемого в процессе работы программы.</p>\n\n<p><strong>Состояние</strong> контейнера — это <strong>набор значений, хранящихся внутри контейнера в данный момент времени</strong>.</p>\n\n<p>Можно создать <strong>множество </strong>независимых контейнеров, каждый с <strong>собственным состоянием</strong>.</p>\n\n<p>Динамический контейнер необходимо создавать <strong>явно</strong>, чтобы задать ему нужное состояние.</p>\n\n<p><strong>Как функции используют состояние контейнера?</strong> Функции внутри контейнера могут обращаться к <strong>состоянию</strong> как к общим данным, доступным всему контейнеру. Это удобно, поскольку сокращает количество требуемых явных параметров функций, делая код более читаемым. Однако это нарушает принцип чистоты функций <em>(pure functions)</em>, так как результат работы функции зависит не только от её аргументов, но и от состояния контейнера.</p>\n\n<p>Тем не менее:</p>\n\n<ul>\n\t<li>Если <strong>состояние контейнера</strong> <strong>остается неизменным</strong> <strong>после создания</strong>, то нарушение чистоты можно считать минимальным и им можно пренебречь ради удобства вызова функций. Это частый приём в стандартной библиотеке Scala.</li>\n\t<li>Использование динамического контейнера оправдано, если функции в контейнере изначально предполагают <strong>нечистоту</strong> или работу с <strong>побочными эффектами</strong> (например, ввод-вывод, доступ к внешним ресурсам).</li>\n</ul>\n\n<p>Для создания динамического контейнера, сначала требуется определить (описать) его тип.&nbsp;Динамический контейнер определяется с помощью конструкции <code>class.&nbsp;</code>Конструкция <code>class&nbsp;</code>в Scala обладает широкими возможностями применения. В данном контексте мы рассматриваем её исключительно как контейнер функций, без углубления в другие варианты использования.</p>\n\n<p><strong>Синтаксис определения типа динамического контейнера:</strong></p>\n\n<pre><code class=\"language-scala\">class ContainerTypeName(paramName: ParamType, ...):\n  // определения функций и значений</code></pre>\n\n<p>где:</p>\n\n<ul>\n\t<li><strong>class</strong> — ключевое слово для определения типа динамического контейнера;</li>\n\t<li><strong>ContainerTypeName</strong> — придуманное имя типа контейнера (по соглашению пишется с большой буквы);</li>\n\t<li><strong>paramName</strong> — придуманное имя параметра,&nbsp;для формирования состояния;</li>\n\t<li><strong>ParamType</strong> — тип параметра.</li>\n</ul>\n\n<p>Параметры, указываемые при определении контейнера, формируют <strong>состояние контейнера</strong>.</p>\n\n<p>В такой форме определения состояние&nbsp;<strong>недоступно извне</strong>, а используются только функциями контейнера. Чтобы состояние было видно из контейнера, нужно добавить модификатор <strong><code>val </code></strong>перед именем параметра.</p>\n\n<pre><code class=\"language-scala\">class ContainerTypeName(val paramName: ParamType, ...):\n  // определения функций и значений</code></pre>\n\n<p><strong>Пример определения типа динамического контейнера MathOperations:</strong></p>\n\n<pre><code class=\"language-scala\">class MathOperations(val multiplier: Int, val offset: Int):\n  val add: (Int, Int) =&gt; Int = _ + _\n  def multiply(a: Int, b: Int): Int = a * b\n  def calculate(x: Int): Int = x * multiplier + offset</code></pre>\n\n<p>Состояние контейнера, образуемое из параметров&nbsp;<code>multiplier</code> и&nbsp;<code>offset&nbsp;</code>используется в теле функции&nbsp;<code>calculate .</code></p>\n\n<p>Все эти формы определений типа контейнера обеспечивают <strong>неизменяемость состояния контейнера после его создания</strong>. Другие формы определений контейнера, позволяющие менять состояние контейнера \"на лету\", использовать в функциональном стиле не рекомендуется, и мы их рассматривать не будем.</p>\n\n<p>Для создания контейнера определенного типа, нужно указать ключевое слово <strong><code>new</code></strong> перед именем типа и указать необходимые аргументы для создания состояния:</p>\n\n<pre><code class=\"language-scala\">val math2 = new MathOperations(2, 10)\nval math3 = new MathOperations(3, 10)</code></pre>\n\n<p>В данном примере созданы (определены) два контейнера&nbsp;&nbsp;math2 и&nbsp;math3 .</p>\n\n<p><strong>Доступ </strong>к элементам контейнера осуществляется по имени созданного контейнера и имени элемента с помощью <strong>точечной нотации</strong>.</p>\n\n<p>Пример доступа к элементам контейнера:</p>\n\n<pre><code class=\"language-scala\">val sum = math2.add(2, 2)\nval prod = math2.multiply(2, 2)\nval res = math2.calculate(2)\nval multiplier = math2.multiplier\nval offset = math2.offset </code></pre>",
    "video" : null,
    "options" : {
      
    },
    "subtitle_files" : [
    ],
    "is_deprecated" : false
  },
  "name" : "text",
  "course_id" : 195883,
  "course_name" : "Функциональная Scala 3 для начинающих",
  "exported_at" : "2026-01-10T10:17:33.9917014"
}