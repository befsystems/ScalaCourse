# Материал (Шаг 4)

## Информация о шаге

- **ID шага**: 7805775
- **Позиция**: 4
- **Тип**: text
- **Курс**: Функциональная Scala 3 для начинающих
- **Экспортирован**: 2026-01-10T10:17:34.0060849

## Содержание

# Агрегация контейнеров

**Агрегация контейнеров** — это включение контейнеров функций в качестве **составных частей** другого контейнера. Вложенные контейнеры становятся **частью состояния** основного контейнера и **доступны всем** его функциям.

Этот прием позволяет строить сложные системы из простых, независимых компонентов, каждый из которых отвечает за свою область ответственности.

Агрегацию можно реализовать разными способами, которые различаются по степени зависимости между контейнерами и влияют на гибкость всей системы.

## Агрегация в динамических контейнерах

Динамические контейнеры могут включать в себя другие контейнеры, принимая их как аргументы в конструкторе основного контейнера, при его создании. Вложенные контейнеры становятся составными частями основного контейнера.

Пример определения контейнеров для агрегации:

class Logger(val prefix: String):
def log(message: String): Unit = println(s"[$prefix] $message")

class DatabaseConfig(val host: String, val port: Int):
def connectionString: String = s"jdbc://localhost:$port/$host"

class FileProcessor(val logger: Logger, val config: DatabaseConfig):
// logger и config — вложенные контейнеры, доступные всем функциям
def processFile(filename: String): String =
logger.log(s"Processing file: $filename")
logger.log(s"Will save to: ${config.connectionString}")
s"Processed: $filename"

def getStatus: String =
s"FileProcessor with ${logger.prefix} logger and ${config.host} database"

class ReportGenerator(val processor: FileProcessor, val outputPath: String):
// processor — вложенный контейнер, который сам содержит другие контейнеры
def generateReport(filename: String): String =
processor.logger.log("Starting report generation")
val result = processor.processFile(filename)
processor.logger.log(s"Report will be saved to: $outputPath")
s"Report: $result"

def getConfiguration: String =
s"Report output: $outputPath, ${processor.getStatus}"

Пример создания основного контейнера и его компонент:

// Создаем базовые контейнеры
val logger = new Logger("REPORT")
val config = new DatabaseConfig("reports_db", 3306)

// Включаем их в FileProcessor как зависимости
val processor = new FileProcessor(logger, config)

// Включаем FileProcessor в ReportGenerator как зависимость
val generator = new ReportGenerator(processor, "/tmp/reports")

val report = generator.generateReport("data.csv")
println(generator.getConfiguration)

## Применение агрегации

Агрегация полезна, потому что позволяет создавать составные контейнеры из более простых компонентов, каждый из которых решает свою конкретную задачу. Это упрощает разработку сложных систем - вместо создания одного монолитного контейнера со всей логикой, можно собирать функциональность из готовых, проверенных блоков. Вложенные контейнеры можно переиспользовать в разных комбинациях, что сокращает дублирование кода и упрощает сопровождение системы.

## Сильная и слабая связанность при агрегации

### Слабая связанность (рекомендуемый подход)

Приведенный выше пример демонстрирует слабую связанность. Это означает, что:

- Вложенные контейнеры передаются как аргументы при создании основного контейнера

- Основной контейнер зависит только от перечня сигнатур функций вложенных контейнеров

- Можно подменить вложенный контейнер на другой, совместимый контейнер, при создании основного контейнера

- Высокая тестируемость и переиспользуемость

### Сильная связанность (не рекомендуется)

Сильная связанность возникает, когда основной контейнер сам создает вложенные контейнеры внутри себя:

class FileProcessorTightlyCoupled(logPrefix: String, dbHost: String, dbPort: Int):
// Создаем зависимости внутри - сильная связанность!
val logger = new Logger(logPrefix)
val config = new DatabaseConfig(dbHost, dbPort)

def processFile(filename: String): String =
logger.log(s"Processing file: $filename")
logger.log(s"Will save to: ${config.connectionString}")
s"Processed: $filename"

Основная проблема сильной связанности в том, что вложенные контейнеры, хотя и представляют собой самостоятельные сущности, не могут быть заменены на другие совместимые контейнеры с иной реализацией функций. Это значительно усложняет тестирование, так как невозможно изолировать зависимости для создания тестовых сценариев. Кроме того, повышается специализация основного контейнера: он лишается гибкости при выборе конкретных реализаций функций на этапе создания. Например, нельзя заменить `Logger`, чтобы он писал в файл вместо вывода в консоль.

---

### Полные данные JSON

<details>
<summary>Показать JSON данные</summary>

```json
{
  "name" : "text",
  "text" : "<h1 style=\"text-align:center;\">Агрегация контейнеров</h1>\n\n<p><strong>Агрегация контейнеров</strong> — это включение контейнеров функций в качестве <strong>составных частей</strong> другого контейнера. Вложенные контейнеры становятся <strong>частью состояния</strong> основного контейнера и <strong>доступны всем</strong> его функциям.</p>\n\n<p>Этот прием позволяет строить сложные системы из простых, независимых компонентов, каждый из которых отвечает за свою область ответственности.</p>\n\n<p>Агрегацию можно реализовать разными способами, которые различаются по степени зависимости между контейнерами и влияют на гибкость всей системы.</p>\n\n<h2 style=\"text-align:center;\">Агрегация в динамических контейнерах</h2>\n\n<p>Динамические контейнеры могут включать в себя другие контейнеры, принимая их как аргументы в конструкторе основного контейнера, при его создании. Вложенные контейнеры становятся составными частями основного контейнера.</p>\n\n<p>Пример определения контейнеров для агрегации:</p>\n\n<pre><code class=\"language-scala\">class Logger(val prefix: String):\n  def log(message: String): Unit = println(s\"[$prefix] $message\")\n\nclass DatabaseConfig(val host: String, val port: Int):\n  def connectionString: String = s\"jdbc://localhost:$port/$host\"\n\nclass FileProcessor(val logger: Logger, val config: DatabaseConfig):\n  // logger и config — вложенные контейнеры, доступные всем функциям\n  def processFile(filename: String): String =\n    logger.log(s\"Processing file: $filename\")\n    logger.log(s\"Will save to: ${config.connectionString}\")\n    s\"Processed: $filename\"\n  \n  def getStatus: String =\n    s\"FileProcessor with ${logger.prefix} logger and ${config.host} database\"\n\nclass ReportGenerator(val processor: FileProcessor, val outputPath: String):\n  // processor — вложенный контейнер, который сам содержит другие контейнеры\n  def generateReport(filename: String): String =\n    processor.logger.log(\"Starting report generation\")\n    val result = processor.processFile(filename)\n    processor.logger.log(s\"Report will be saved to: $outputPath\")\n    s\"Report: $result\"\n  \n  def getConfiguration: String =\n    s\"Report output: $outputPath, ${processor.getStatus}\"\n</code></pre>\n\n<p>Пример создания основного контейнера и его компонент:</p>\n\n<pre><code class=\"language-scala\">// Создаем базовые контейнеры\nval logger = new Logger(\"REPORT\")\nval config = new DatabaseConfig(\"reports_db\", 3306)\n\n// Включаем их в FileProcessor как зависимости\nval processor = new FileProcessor(logger, config)\n\n// Включаем FileProcessor в ReportGenerator как зависимость\nval generator = new ReportGenerator(processor, \"/tmp/reports\")\n\nval report = generator.generateReport(\"data.csv\")\nprintln(generator.getConfiguration)\n</code></pre>\n\n<h2 style=\"text-align:center;\">Применение агрегации</h2>\n\n<p>Агрегация полезна, потому что позволяет создавать составные контейнеры из более простых компонентов, каждый из которых решает свою конкретную задачу. Это упрощает разработку сложных систем - вместо создания одного монолитного контейнера со всей логикой, можно собирать функциональность из готовых, проверенных блоков. Вложенные контейнеры можно переиспользовать в разных комбинациях, что сокращает дублирование кода и упрощает сопровождение системы.</p>\n\n<h2 style=\"text-align:center;\">Сильная и слабая связанность при агрегации</h2>\n\n<h3 style=\"text-align:center;\">Слабая связанность (рекомендуемый подход)</h3>\n\n<p>Приведенный выше пример демонстрирует слабую связанность. Это означает, что:</p>\n\n<ul>\n\t<li>Вложенные контейнеры передаются как аргументы при создании&nbsp;основного контейнера</li>\n\t<li>Основной контейнер зависит только от перечня сигнатур функций вложенных контейнеров</li>\n\t<li>Можно подменить вложенный контейнер на другой, совместимый контейнер, при создании основного контейнера</li>\n\t<li>Высокая тестируемость и переиспользуемость</li>\n</ul>\n\n<h3 style=\"text-align:center;\">Сильная связанность (не рекомендуется)</h3>\n\n<p>Сильная связанность возникает, когда основной контейнер сам создает вложенные контейнеры внутри себя:</p>\n\n<pre><code class=\"language-scala\">class FileProcessorTightlyCoupled(logPrefix: String, dbHost: String, dbPort: Int):\n  // Создаем зависимости внутри - сильная связанность!\n  val logger = new Logger(logPrefix)\n  val config = new DatabaseConfig(dbHost, dbPort)\n  \n  def processFile(filename: String): String =\n    logger.log(s\"Processing file: $filename\")\n    logger.log(s\"Will save to: ${config.connectionString}\")\n    s\"Processed: $filename\"\n</code></pre>\n\n<p>Основная проблема сильной связанности в том, что вложенные контейнеры, хотя и представляют собой самостоятельные сущности, не могут быть заменены на другие совместимые контейнеры с иной реализацией функций. Это значительно усложняет тестирование, так как невозможно изолировать зависимости для создания тестовых сценариев. Кроме того, повышается специализация основного контейнера: он лишается гибкости при выборе конкретных реализаций функций на этапе создания. Например, нельзя заменить <code>Logger</code>, чтобы он писал в файл вместо вывода в консоль.</p>",
  "video" : null,
  "options" : {
    
  },
  "subtitle_files" : [
  ],
  "is_deprecated" : false
}
```

</details>
