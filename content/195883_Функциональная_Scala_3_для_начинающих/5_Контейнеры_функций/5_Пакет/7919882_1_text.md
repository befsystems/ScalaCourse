# Материал (Шаг 1)

## Информация о шаге

- **ID шага**: 7919882
- **Позиция**: 1
- **Тип**: text
- **Курс**: Функциональная Scala 3 для начинающих
- **Экспортирован**: 2026-01-10T10:17:38.0427827

## Содержание

# Основы организации пакетов

Пакеты в Scala 3 являются основным механизмом организации кода в больших приложениях. Они служат контейнерами для классов, объектов, traits, функций и других определений, обеспечивая логическую структуру проекта и управление пространством имен.

Пакет (package) — это именованное пространство, которое группирует логически связанные между собой элементы кода. Представьте пакеты как каталоги файловой системы: они помогают организовать файлы по смыслу и назначению.

**Основные функции пакетов:**

- **Организация кода** — группировка связанной функциональности

- **Избежание конфликтов имен** — разные пакеты могут содержать классы с одинаковыми именами

- **Контроль доступа** — управление видимостью элементов кода

- **Модульность** — создание независимых компонентов приложения

**Синтаксис определения пакета:**

package qualified.package.name
// далее список определений в пакете

Пример определения пакета:

package com.example.myapp

def generateId(): Long = System.currentTimeMillis()

class UserService {
def createUser(name: String, email: String): User = {
User(System.currentTimeMillis(), name, email)
}
}

trait Validator {
def validate(input: String): Boolean
}

object DatabaseConfig {
val host = "localhost"
val port = 5432
}

val MAX_USERS = 1000
val DEFAULT_TIMEOUT = 30

## Структура пакетов и каталоги файловой системы

Scala не требует строгого соответствия между структурой пакетов и каталогами файловой системы, но следование этому правилу считается хорошей практикой.

Пакет: com.example.myapp.models
Каталог: src/main/scala/com/example/myapp/models/

Содержимое каталога:
├── User.scala // package com.example.myapp.models
├── Product.scala // package com.example.myapp.models
└── Order.scala // package com.example.myapp.models

В одном пакете может находиться несколько файлов, каждый из которых может содержать множественные определения (классы, объекты, функции, константы и т.д.). Все файлы в каталоге должны объявлять один и тот же пакет.

**Пример рекомендуемой структуры проекта:**

src/main/scala/
├── com/
│ └── example/
│ └── myapp/ // пакет: com.example.myapp
│ ├── Application.scala // package com.example.myapp
│ ├── models/ // пакет: com.example.myapp.models
│ │ ├── User.scala // package com.example.myapp.models
│ │ └── Product.scala // package com.example.myapp.models
│ ├── services/ // пакет: com.example.myapp.services
│ │ ├── UserService.scala // package com.example.myapp.services
│ │ └── ProductService.scala // package com.example.myapp.services
│ └── utils/ // пакет: com.example.myapp.utils
│ └── Helpers.scala // package com.example.myapp.utils

## Зачем нужны пакеты помимо каталогов

**Каталоги** - это физическая организация проекта на конкретной файловой системе. **Пакеты** - это логическая организация кода в программе.

При распространении и использовании проекта его структура не должна зависеть от особенностей файловой системы, которые могут отличаться между платформами (Windows, Linux, macOS) и создавать проблемы при работе с кодом.

**Пакеты обеспечивают:**

- **Независимость от платформы** - код работает одинаково везде

- **Логическое пространство имен** - `com.example.auth.User` и `com.example.billing.User` это разные типы

- **Контроль доступа** - можно ограничить видимость на уровне логических модулей

- **Стандартизацию** - единый способ организации кода в экосистеме JVM

## Безымянный пакет

Если не указать `package`, все определения попадают в **безымянный пакет** (anonymous package):

// Файл без объявления пакета
class User(name: String)
object UserService

Такое решение пригодно для маленьких и короткоживущих проектов.

**Проблемы безымянного пакета:**

- **Нельзя импортировать** классы из безымянного пакета в другие пакеты

- **Конфликты имен** с другими классами в безымянном пакете

- **Плохая организация** - весь код в одном глобальном пространстве

- **Ограничения доступа** - нет возможности использовать package-private модификаторы

// Файл 1: без пакета
class User(name: String)

// Файл 2: с пакетом
package com.example.services

import User // Ошибка! Нельзя импортировать из безымянного пакета

class UserService {
// def process(user: User): Unit = ??? // Не работает
}

## Корневой пакет (*root*)

**Корневой пакет** - это самый верхний уровень в иерархии пакетов Scala, который содержит:

- Безымянный пакет (anonymous package)

- Все пакеты верхнего уровня (scala, java, com, org и т.д.)

### Структура пакетов

_root_
├── (безымянный пакет)
│ ├── MyClass (без package)
│ └── MyObject (без package)
├── scala.*
│ ├── scala.collection.*
│ └── scala.util.*
├── java.*
│ ├── java.util.*
│ └── java.lang.*
├── com.*
│ └── com.example.myapp.*
└── org.*
└── org.somelib.*

Можно явно обратиться к корневому пакету с помощью ключевого слова` _root_`

---

### Полные данные JSON

<details>
<summary>Показать JSON данные</summary>

```json
{
  "name" : "text",
  "text" : "<h1 style=\"text-align:center;\">Основы организации пакетов</h1>\n\n<p>Пакеты в Scala 3 являются основным механизмом организации кода в больших приложениях. Они служат контейнерами для классов, объектов, traits, функций и других определений, обеспечивая логическую структуру проекта и управление пространством имен.</p>\n\n<p>Пакет (package) — это именованное пространство, которое группирует логически связанные между собой элементы кода. Представьте пакеты как каталоги файловой системы: они помогают организовать файлы по смыслу и назначению.</p>\n\n<p><strong>Основные функции пакетов:</strong></p>\n\n<ul>\n\t<li><strong>Организация кода</strong> — группировка связанной функциональности</li>\n\t<li><strong>Избежание конфликтов имен</strong> — разные пакеты могут содержать классы с одинаковыми именами</li>\n\t<li><strong>Контроль доступа</strong> — управление видимостью элементов кода</li>\n\t<li><strong>Модульность</strong> — создание независимых компонентов приложения</li>\n</ul>\n\n<p><strong>Синтаксис определения пакета:</strong></p>\n\n<pre><code class=\"language-scala\">package qualified.package.name\n// далее список определений в пакете</code></pre>\n\n<p>Пример определения пакета:</p>\n\n<pre><code class=\"language-scala\">package com.example.myapp\n \ndef generateId(): Long = System.currentTimeMillis()\n\nclass UserService {\n  def createUser(name: String, email: String): User = {\n    User(System.currentTimeMillis(), name, email)\n  }\n}\n\ntrait Validator {\n  def validate(input: String): Boolean\n}\n\nobject DatabaseConfig {\n  val host = \"localhost\"\n  val port = 5432\n}\n\nval MAX_USERS = 1000\nval DEFAULT_TIMEOUT = 30\n</code></pre>\n\n<h2 style=\"text-align:center;\">Структура пакетов и каталоги файловой системы</h2>\n\n<p>Scala не требует строгого соответствия между структурой пакетов и каталогами файловой системы, но следование этому правилу считается хорошей практикой.</p>\n\n<pre><code>Пакет:    com.example.myapp.models\nКаталог:  src/main/scala/com/example/myapp/models/\n\nСодержимое каталога:\n├── User.scala      // package com.example.myapp.models\n├── Product.scala   // package com.example.myapp.models  \n└── Order.scala     // package com.example.myapp.models</code></pre>\n\n<p>В одном пакете может находиться несколько файлов, каждый из которых может содержать множественные определения (классы, объекты, функции, константы и т.д.). Все файлы в каталоге должны объявлять один и тот же пакет.</p>\n\n<p><strong>Пример рекомендуемой структуры проекта:</strong></p>\n\n<pre><code>src/main/scala/\n├── com/\n│   └── example/\n│       └── myapp/                     // пакет: com.example.myapp\n│           ├── Application.scala      // package com.example.myapp\n│           ├── models/                // пакет: com.example.myapp.models\n│           │   ├── User.scala         // package com.example.myapp.models\n│           │   └── Product.scala      // package com.example.myapp.models\n│           ├── services/              // пакет: com.example.myapp.services\n│           │   ├── UserService.scala  // package com.example.myapp.services\n│           │   └── ProductService.scala // package com.example.myapp.services\n│           └── utils/                 // пакет: com.example.myapp.utils\n│               └── Helpers.scala      // package com.example.myapp.utils</code></pre>\n\n<h2 style=\"text-align:center;\">Зачем нужны пакеты помимо каталогов</h2>\n\n<p><strong>Каталоги</strong> - это физическая организация проекта на конкретной файловой системе. <strong>Пакеты</strong> - это логическая организация кода в программе.</p>\n\n<p>При распространении и использовании проекта его структура не должна зависеть от особенностей файловой системы, которые могут отличаться между платформами (Windows, Linux, macOS) и создавать проблемы при работе с кодом.</p>\n\n<p><strong>Пакеты обеспечивают:</strong></p>\n\n<ul>\n\t<li><strong>Независимость от платформы</strong> - код работает одинаково везде</li>\n\t<li><strong>Логическое пространство имен</strong> - <code>com.example.auth.User</code> и <code>com.example.billing.User</code> это разные типы</li>\n\t<li><strong>Контроль доступа</strong> - можно ограничить видимость на уровне логических модулей</li>\n\t<li><strong>Стандартизацию</strong> - единый способ организации кода в экосистеме JVM</li>\n</ul>\n\n<h2 style=\"text-align:center;\">Безымянный пакет</h2>\n\n<p>Если не указать <code>package</code>, все определения попадают в <strong>безымянный пакет</strong> (anonymous package):</p>\n\n<pre><code class=\"language-scala\">// Файл без объявления пакета\nclass User(name: String)\nobject UserService</code></pre>\n\n<p>Такое решение пригодно для маленьких и короткоживущих проектов.</p>\n\n<p><strong>Проблемы безымянного пакета:</strong></p>\n\n<ul>\n\t<li><strong>Нельзя импортировать</strong> классы из безымянного пакета в другие пакеты</li>\n\t<li><strong>Конфликты имен</strong> с другими классами в безымянном пакете</li>\n\t<li><strong>Плохая организация</strong> - весь код в одном глобальном пространстве</li>\n\t<li><strong>Ограничения доступа</strong> - нет возможности использовать package-private модификаторы</li>\n</ul>\n\n<pre><code class=\"language-scala\">// Файл 1: без пакета\nclass User(name: String)\n\n// Файл 2: с пакетом\npackage com.example.services\n\nimport User  // Ошибка! Нельзя импортировать из безымянного пакета\n\nclass UserService {\n  // def process(user: User): Unit = ???  // Не работает\n}</code></pre>\n\n<h2 style=\"text-align:center;\">Корневой пакет (<em>root</em>)</h2>\n\n<p><strong>Корневой пакет</strong> - это самый верхний уровень в иерархии пакетов Scala, который содержит:</p>\n\n<ul>\n\t<li>Безымянный пакет (anonymous package)</li>\n\t<li>Все пакеты верхнего уровня (scala, java, com, org и т.д.)</li>\n</ul>\n\n<h3>Структура пакетов</h3>\n\n<pre style=\"background:transparent; color:#383a42; text-align:left;\"><code style=\"background:transparent; color:#383a42; text-align:left;\">_root_\n├── (безымянный пакет)\n│   ├── MyClass (без package)\n│   └── MyObject (без package)\n├── scala.* \n│   ├── scala.collection.*\n│   └── scala.util.*\n├── java.*\n│   ├── java.util.*\n│   └── java.lang.*\n├── com.*\n│   └── com.example.myapp.*\n└── org.*\n    └── org.somelib.*</code></pre>\n\n<p>Можно явно обратиться к корневому пакету с помощью ключевого слова<code> _root_</code></p>",
  "video" : null,
  "options" : {
    
  },
  "subtitle_files" : [
  ],
  "is_deprecated" : false
}
```

</details>
