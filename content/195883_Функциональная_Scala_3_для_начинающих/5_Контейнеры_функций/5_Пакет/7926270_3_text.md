# Материал (Шаг 3)

## Информация о шаге

- **ID шага**: 7926270
- **Позиция**: 3
- **Тип**: text
- **Курс**: Функциональная Scala 3 для начинающих
- **Экспортирован**: 2026-01-10T10:17:38.0705554

## Содержание

# Импорт

**Импорт** позволяет использовать элементы из других пакетов без указания полного квалифицированного имени. **Импорт не является обязательным** - вы всегда можете использовать полный путь к классу.

**Синтаксис импорта:**

import package.name.Element
import package.name.{Element1, Element2}
import package.name.{Element as Alias}
import package.name.*
import package.name.given

**Что такое импорт:**

- **Не определение** - импорт не создает новые классы или объекты

- **Декларация видимости** - делает существующие элементы доступными под короткими именами

- **Синоним имени** - создает локальный псевдоним для полного квалифицированного имени

Конструкция `import` так же является псевдо-выражением (возвращает тип Unit), и соответственно, может быть указано в любом месте программы, где допустимо выражение.

### Без импорта - полные имена

package com.example.myapp.services

class UserService {
// Использование без импорта - через полное имя
def createUser(name: String): com.example.myapp.models.User = {
com.example.myapp.models.User(name)
}

def processDate(): String = {
val now = java.time.Instant.now()
val formatter = java.time.format.DateTimeFormatter.ISO_INSTANT
formatter.format(now)
}
}

### С импортом - короткие имена

package com.example.myapp.services

// Импорт для удобства
import com.example.myapp.models.User
import java.time.{Instant, format.DateTimeFormatter}
import scala.util.Try

class UserService {
// Теперь можно использовать короткие имена
def createUser(name: String): User = {
User(name)
}

def processDate(): String = {
val now = Instant.now()
val formatter = DateTimeFormatter.ISO_INSTANT
formatter.format(now)
}
}

**Когда использовать полные имена без импорта:**

- **Редкое использование** - класс нужен только в одном месте

- **Избежание конфликтов** - когда импорт создал бы путаницу

- **Явность** - когда важно подчеркнуть происхождение класса

// Пример с конфликтом имен
class DateProcessor {
def processJavaDate(): String = {
val date = new java.util.Date() // Явно Java Date
date.toString
}

def processSqlDate(): String = {
val date = new java.sql.Date(System.currentTimeMillis()) // Явно SQL Date
date.toString
}

// Без полных имен было бы неясно, какой Date используется
}

## Конкретный импорт 

package com.example.myapp.services

// Импорт конкретного класса
import com.example.myapp.models.User

class UserService {
def createUser(name: String): User = {
User(name) // Используем без полного имени
}
}

## Импорт нескольких элементов

// Импорт нескольких элементов из одного пакета
import com.example.myapp.models.{User, Product, Order}

// Импорт всех элементов пакета
import com.example.myapp.models.*

## Импорт с переименованием

import com.example.auth.User as AuthUser
import com.example.billing.User as BillingUser

class UserService {
def authenticate(user: AuthUser): Boolean = ???
def getBilling(user: BillingUser): BigDecimal = ???
}

## Импорт содержимого контейнера

// Импорт всего содержимого контейнера
import scala.math.Ordering.Implicits.*

// Импорт функций контейнера
import scala.util.Random.{nextInt, nextDouble}

class MathProcessor {
def compare[T](a: T, b: T)(using ord: Ordering[T]): Int = ord.compare(a, b)
def randomValue(): (Int, Double) = (nextInt(100), nextDouble())
}

## Локальный импорт

package com.example.myapp

class DataProcessor {
def processXml(xml: String): String = {
// локальный импорт
import scala.xml.*

val parsed = XML.loadString(xml)
parsed.toString
}

// parse и XML здесь недоступны
}

## Импорт в блоках кода

def complexProcessing(data: String): Int = {
data.map{ item =>
// Еще более локальный импорт
import java.security.MessageDigest

val digest = MessageDigest.getInstance("SHA-256")
digest.digest(item.getByte).length
}.sum
}

## Автоматические импорты

Scala 3 автоматически импортирует несколько пакетов:

// Эти импорты добавляются автоматически в каждый файл:
// import java.lang.*
// import scala.*
// import scala.Predef.*

package com.example.myapp

class Example {
// Доступны без явного импорта:
val text: String = "Hello" // java.lang.String
val number: Int = 42 // scala.Int
val list: List[Int] = List(1, 2, 3) // scala.collection.immutable.List

def print(msg: String): Unit = {
println(msg) // scala.Predef.println
}
}

## Относительные импорты

package com.example.myapp.services

// Относительный импорт - относительно текущего пакета
import models.User // com.example.myapp.services.models.User
import utils.* // com.example.myapp.services.utils.*

// Переход на уровень выше
import ..models.Product // com.example.myapp.models.Product

## Абсолютные импорты

package com.example.myapp.services

// Абсолютный импорт - от корня
import com.example.myapp.models.User
import com.example.common.utils.StringUtils

// Явное указание корня (для избежания конфликтов)
import _root_.java.util.Date
import _root_.scala.collection.mutable.Map

## Конфликты

// Плохо - неясно, какой List используется
import java.util.*
import scala.collection.mutable.*

// Хорошо - явное указание
import java.util.{List as JavaList}
import scala.collection.mutable.{List as MutableList}
import scala.collection.immutable.List // default List

class DataProcessor {
val javaList: JavaList[String] = ???
val mutableList: MutableList[String] = ???
val immutableList: List[String] = ???
}

## Минимизация импортов

// Плохо - излишние импорты
import scala.collection.mutable.*
import scala.util.*

// Хорошо - только необходимое
import scala.collection.mutable.ListBuffer
import scala.util.{Try, Success}

class SimpleProcessor {
private val buffer = ListBuffer[String]()

def process(data: String): Try[String] = {
Success(data.toUpperCase)
}
}

---

### Полные данные JSON

<details>
<summary>Показать JSON данные</summary>

```json
{
  "name" : "text",
  "text" : "<h1 style=\"text-align:center;\">Импорт</h1>\n\n<p><strong>Импорт</strong> позволяет использовать элементы из других пакетов без указания полного квалифицированного имени. <strong>Импорт не является обязательным</strong> - вы всегда можете использовать полный путь к классу.</p>\n\n<p><br>\n<strong>Синтаксис импорта:</strong></p>\n\n<pre><code class=\"language-scala\">import package.name.Element\nimport package.name.{Element1, Element2}\nimport package.name.{Element as Alias}\nimport package.name.*\nimport package.name.given</code></pre>\n\n<p><strong>Что такое импорт:</strong></p>\n\n<ul>\n\t<li><strong>Не определение</strong> - импорт не создает новые классы или объекты</li>\n\t<li><strong>Декларация видимости</strong> - делает существующие элементы доступными под короткими именами</li>\n\t<li><strong>Синоним имени</strong> - создает локальный псевдоним для полного квалифицированного имени</li>\n</ul>\n\n<p>Конструкция <code>import</code> так же является псевдо-выражением (возвращает тип Unit), и соответственно, может быть указано в любом месте программы, где допустимо выражение.</p>\n\n<h3>Без импорта - полные имена</h3>\n\n<pre><code class=\"language-scala\">package com.example.myapp.services\n\nclass UserService {\n  // Использование без импорта - через полное имя\n  def createUser(name: String): com.example.myapp.models.User = {\n    com.example.myapp.models.User(name)\n  }\n  \n  def processDate(): String = {\n    val now = java.time.Instant.now()\n    val formatter = java.time.format.DateTimeFormatter.ISO_INSTANT\n    formatter.format(now)\n  }\n}\n</code></pre>\n\n<h3>С импортом - короткие имена</h3>\n\n<pre><code class=\"language-scala\">package com.example.myapp.services\n\n// Импорт для удобства\nimport com.example.myapp.models.User\nimport java.time.{Instant, format.DateTimeFormatter}\nimport scala.util.Try\n\nclass UserService {\n  // Теперь можно использовать короткие имена\n  def createUser(name: String): User = {\n    User(name)\n  }\n  \n  def processDate(): String = {\n    val now = Instant.now()\n    val formatter = DateTimeFormatter.ISO_INSTANT\n    formatter.format(now)\n  }\n}\n</code></pre>\n\n<p><strong>Когда использовать полные имена без импорта:</strong></p>\n\n<ul>\n\t<li><strong>Редкое использование</strong> - класс нужен только в одном месте</li>\n\t<li><strong>Избежание конфликтов</strong> - когда импорт создал бы путаницу</li>\n\t<li><strong>Явность</strong> - когда важно подчеркнуть происхождение класса</li>\n</ul>\n\n<pre><code class=\"language-scala\">// Пример с конфликтом имен\nclass DateProcessor {\n  def processJavaDate(): String = {\n    val date = new java.util.Date()  // Явно Java Date\n    date.toString\n  }\n  \n  def processSqlDate(): String = {\n    val date = new java.sql.Date(System.currentTimeMillis())  // Явно SQL Date\n    date.toString\n  }\n  \n  // Без полных имен было бы неясно, какой Date используется\n}\n</code></pre>\n\n<h2 style=\"text-align:center;\">Конкретный импорт </h2>\n\n<pre><code class=\"language-scala\">package com.example.myapp.services\n\n// Импорт конкретного класса\nimport com.example.myapp.models.User\n\nclass UserService {\n  def createUser(name: String): User = {\n    User(name) // Используем без полного имени\n  }\n}\n</code></pre>\n\n<h2 style=\"text-align:center;\">Импорт нескольких элементов</h2>\n\n<pre><code class=\"language-scala\">// Импорт нескольких элементов из одного пакета\nimport com.example.myapp.models.{User, Product, Order}\n\n// Импорт всех элементов пакета\nimport com.example.myapp.models.*\n</code></pre>\n\n<h2 style=\"text-align:center;\">Импорт с переименованием</h2>\n\n<pre><code class=\"language-scala\">import com.example.auth.User as AuthUser\nimport com.example.billing.User as BillingUser\n\nclass UserService {\n  def authenticate(user: AuthUser): Boolean = ???\n  def getBilling(user: BillingUser): BigDecimal = ???\n}\n</code></pre>\n\n<h2 style=\"text-align:center;\">Импорт содержимого контейнера</h2>\n\n<pre><code class=\"language-scala\">// Импорт всего содержимого контейнера\nimport scala.math.Ordering.Implicits.*\n\n// Импорт функций контейнера\nimport scala.util.Random.{nextInt, nextDouble}\n\nclass MathProcessor {\n  def compare[T](a: T, b: T)(using ord: Ordering[T]): Int = ord.compare(a, b)\n  def randomValue(): (Int, Double) = (nextInt(100), nextDouble())\n}</code></pre>\n\n<h2 style=\"text-align:center;\">Локальный импорт</h2>\n\n<pre><code class=\"language-scala\">package com.example.myapp\n\nclass DataProcessor {\n  def processXml(xml: String): String = {\n    // локальный импорт\n    import scala.xml.*\n    \n    val parsed = XML.loadString(xml)\n    parsed.toString\n  }\n  \n  // parse и XML здесь недоступны\n}\n</code></pre>\n\n<h2 style=\"text-align:center;\">Импорт в блоках кода</h2>\n\n<pre><code class=\"language-scala\">def complexProcessing(data: String): Int = {\n  data.map{ item =&gt;\n    // Еще более локальный импорт\n    import java.security.MessageDigest\n    \n    val digest = MessageDigest.getInstance(\"SHA-256\")\n    digest.digest(item.getByte).length\n  }.sum\n}\n</code></pre>\n\n<h2 style=\"text-align:center;\">Автоматические импорты</h2>\n\n<p>Scala 3 автоматически импортирует несколько пакетов:</p>\n\n<pre><code class=\"language-scala\">// Эти импорты добавляются автоматически в каждый файл:\n// import java.lang.*\n// import scala.*\n// import scala.Predef.*\n\npackage com.example.myapp\n\nclass Example {\n  // Доступны без явного импорта:\n  val text: String = \"Hello\"           // java.lang.String\n  val number: Int = 42                 // scala.Int\n  val list: List[Int] = List(1, 2, 3)  // scala.collection.immutable.List\n  \n  def print(msg: String): Unit = {\n    println(msg)  // scala.Predef.println\n  }\n}\n</code></pre>\n\n<h2 style=\"text-align:center;\">Относительные импорты</h2>\n\n<pre><code class=\"language-scala\">package com.example.myapp.services\n\n// Относительный импорт - относительно текущего пакета\nimport models.User        // com.example.myapp.services.models.User\nimport utils.*            // com.example.myapp.services.utils.*\n\n// Переход на уровень выше\nimport ..models.Product   // com.example.myapp.models.Product\n</code></pre>\n\n<h2 style=\"text-align:center;\">Абсолютные импорты</h2>\n\n<pre><code class=\"language-scala\">package com.example.myapp.services\n\n// Абсолютный импорт - от корня\nimport com.example.myapp.models.User\nimport com.example.common.utils.StringUtils\n\n// Явное указание корня (для избежания конфликтов)\nimport _root_.java.util.Date\nimport _root_.scala.collection.mutable.Map\n</code></pre>\n\n<h2 style=\"text-align:center;\">Конфликты</h2>\n\n<pre><code class=\"language-scala\">// Плохо - неясно, какой List используется\nimport java.util.*\nimport scala.collection.mutable.*\n\n// Хорошо - явное указание\nimport java.util.{List as JavaList}\nimport scala.collection.mutable.{List as MutableList}\nimport scala.collection.immutable.List // default List\n\nclass DataProcessor {\n  val javaList: JavaList[String] = ???\n  val mutableList: MutableList[String] = ???\n  val immutableList: List[String] = ???\n}\n</code></pre>\n\n<h2 style=\"text-align:center;\">Минимизация импортов</h2>\n\n<pre><code class=\"language-scala\">// Плохо - излишние импорты\nimport scala.collection.mutable.*\nimport scala.util.*\n\n// Хорошо - только необходимое\nimport scala.collection.mutable.ListBuffer\nimport scala.util.{Try, Success}\n\nclass SimpleProcessor {\n  private val buffer = ListBuffer[String]()\n  \n  def process(data: String): Try[String] = {\n    Success(data.toUpperCase)\n  }\n}\n</code></pre>",
  "video" : null,
  "options" : {
    
  },
  "subtitle_files" : [
  ],
  "is_deprecated" : false
}
```

</details>
