{
  "step_id" : 7924871,
  "lesson_id" : 1906022,
  "position" : 2,
  "type" : "unknown",
  "block" : {
    "name" : "text",
    "text" : "<h1 style=\"text-align:center;\">Практические рекомендации применения пакетов&nbsp;</h1>\n\n<h2 style=\"text-align:center;\">Конвенции именования пакетов</h2>\n\n<p><strong>Стандартные правила именования:</strong></p>\n\n<ol>\n\t<li><strong>Используйте reverse domain naming</strong>: <code>com.company.project.module</code></li>\n\t<li><strong>Только строчные буквы</strong>: <code>com.example.myapp</code>, не <code>com.Example.MyApp</code></li>\n\t<li><strong>Разделяйте слова точками</strong>: <code>com.example.user.management</code></li>\n\t<li><strong>Избегайте подчеркиваний</strong>: используйте <code>userservice</code>, не <code>user_service</code></li>\n\t<li><strong>Будьте описательными</strong>: <code>com.example.ecommerce.orders</code>, не <code>com.example.app.stuff</code></li>\n</ol>\n\n<p><strong>Примеры хорошего именования:</strong></p>\n\n<pre><code class=\"language-scala\">package com.example.ecommerce.domain.user\npackage com.example.ecommerce.infrastructure.database\npackage com.example.ecommerce.application.services\npackage com.example.ecommerce.interfaces.rest</code></pre>\n\n<p><strong>Примеры плохого именования:</strong></p>\n\n<pre><code class=\"language-scala\">package com.example.App.User_Stuff    // заглавные буквы и подчеркивания\npackage com.example.things            // неописательное имя\npackage com.example.a.b.c.d.e.f      // слишком глубокая вложенность\npackage stuff                         // отсутствие reverse domain</code></pre>\n\n<ul>\n</ul>\n\n<h2 style=\"text-align:center;\">Организация пакетов</h2>\n\n<h3>Группировка по функциональности</h3>\n\n<p>Организуйте пакеты по доменным областям, а не по техническим слоям:</p>\n\n<pre style=\"background:transparent; color:#383a42; text-align:left;\"><code style=\"background:transparent; color:#383a42; text-align:left;\">com.example.ecommerce\n├── user\n│   ├── User\n│   ├── UserService\n│   └── UserRepository\n├── order\n│   ├── Order\n│   ├── OrderService\n│   └── OrderRepository\n├── product\n│   ├── Product\n│   ├── ProductService\n│   └── ProductRepository\n└── payment\n    ├── Payment\n    ├── PaymentService\n    └── PaymentProvider</code></pre>\n\n<h3>Слоистая архитектура через пакеты</h3>\n\n<p>Альтернативный подход - организация по архитектурным слоям:</p>\n\n<pre style=\"background:transparent; color:#383a42; text-align:left;\"><code style=\"background:transparent; color:#383a42; text-align:left;\">com.example.myapp\n├── domain                  // бизнес-логика\n│   ├── User\n│   ├── Order\n│   └── UserRepository (trait)\n├── application            // оркестрация\n│   ├── UserService\n│   ├── OrderService\n│   └── ApplicationConfig\n├── infrastructure         // технические детали\n│   ├── DatabaseUserRepository\n│   ├── FileSystemConfig\n│   └── EmailService\n└── interfaces             // API, контроллеры\n    ├── UserController\n    ├── OrderController\n    └── ApiRoutes</code></pre>\n\n<h3>&nbsp;<strong>Принципы организации:</strong></h3>\n\n<ul>\n\t<li><strong>Доменная группировка</strong> - лучше для микросервисов и модульных приложений</li>\n\t<li><strong>Слоистая архитектура</strong> - лучше для монолитных приложений с четким разделением ответственности</li>\n\t<li><strong>Избегайте циклических зависимостей</strong> между пакетами</li>\n\t<li><strong>Стабильные зависимости</strong> - менее стабильные пакеты зависят от более стабильных</li>\n</ul>\n\n<h2 style=\"text-align:center;\"><strong>Рекомендации по количеству </strong>верхнеуровневых&nbsp;<strong>определений в файле:</strong></h2>\n\n<ul>\n\t<li><strong>Одно основное определение</strong> - предпочтительный подход для больших классов и сложной логики</li>\n</ul>\n\n<pre><code class=\"language-scala\">// User.scala - один основной класс\npackage com.example.myapp.models\n\ncase class User(id: Long, name: String, email: String) {\n  // сложная логика валидации, методы, etc.\n}\n\nobject User {\n  // companion object с фабричными методами\n}</code></pre>\n\n<ul>\n\t<li><strong>Несколько связанных определений</strong> - допустимо для тесно связанных типов</li>\n</ul>\n\n<pre><code class=\"language-scala\">// ValidationResult.scala - группа небольших связанных классов\npackage com.example.myapp.validation\n\nsealed trait ValidationResult\ncase object Valid extends ValidationResult\ncase class Invalid(errors: List[String]) extends ValidationResult\n\ncase class ValidationError(field: String, message: String)\ncase class ValidationRule(name: String, check: String =&gt; Boolean)\n\nobject ValidationResult {\n  def combine(results: List[ValidationResult]): ValidationResult = ???\n  def fromErrors(errors: List[ValidationError]): ValidationResult = ???\n}</code></pre>\n\n<ul>\n\t<li><strong>Множественные определения</strong> - для утилит, констант и вспомогательных функций</li>\n</ul>\n\n<pre><code class=\"language-scala\">// ValidationUtils.scala - набор утилитарных функций\npackage com.example.myapp.utils\n\ndef validateEmail(email: String): Boolean = ???\ndef validatePhone(phone: String): Boolean = ???\ndef sanitizeInput(input: String): String = ???\n\nval EMAIL_REGEX = \"\"\"^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$\"\"\".r\nval PHONE_REGEX = \"\"\"\\+?[1-9]\\d{1,14}$\"\"\".r\n\nobject ValidationMessages {\n  val INVALID_EMAIL = \"Invalid email format\"\n  val INVALID_PHONE = \"Invalid phone format\"\n}</code></pre>\n\n<p><strong>Избегайте:</strong></p>\n\n<ul>\n\t<li>Слишком много несвязанных между собой определений в одном файле</li>\n\t<li>Файлы размером более 200-300 строк (исключение - автогенерируемый код)</li>\n\t<li>Смешивание разных доменных областей в одном файле</li>\n</ul>\n\n<h2 style=\"text-align:center;\">Top-level функции vs функции в статических контейнерах</h2>\n\n<p><strong>Зачем использовать статические контейнеры для группировки функций, если есть пакеты?</strong></p>\n\n<p>Пакеты и статические контейнеры решают задачи группировки на разных уровнях абстракции:</p>\n\n<p><strong>Пакеты</strong> предназначены для <strong>крупномасштабной архитектурной группировки</strong> - организации слоев приложения или доменных областей (например, <code>com.example.user</code>, <code>com.example.order</code>, <code>com.example.payment</code>).</p>\n\n<p><strong>Статические контейнеры</strong> обеспечивают <strong>локальную тематическую группировку</strong> внутри пакета - объединение семантически связанных функций для удобства использования и целостности API (например, <code>StringUtils</code>, <code>DateUtils</code>, <code>ValidationUtils</code>).</p>\n\n<h3>Принципы выбора размещения функции:</h3>\n\n<p><strong>Используйте top-level функции когда:</strong></p>\n\n<ul>\n\t<li>Функция очень востребована и универсальна для разнообразного использования.</li>\n\t<li>Функция компактна, независима и самодостаточна</li>\n\t<li>Нет риска конфликтов имен в большем пакете</li>\n</ul>\n\n<p><strong>Используйте статический контейнер когда:</strong></p>\n\n<ul>\n\t<li>Нужно сгруппировать связанную функциональность в небольшую, более связную группу</li>\n\t<li>Есть общее состояние или конфигурация</li>\n\t<li>Множественные перегрузки с одним именем</li>\n\t<li>Нужно избежать конфликтов имен</li>\n\t<li>Создается API с множественными связанными операциями</li>\n\t<li>Есть необходимость использовать контейнер как значение</li>\n</ul>\n\n<pre><code class=\"language-scala\">package com.example.utils.math\n\n// Простые утилитарные функции - идеально для top-level\ndef factorial(n: Int): Long = {\n  if (n &lt;= 1) 1L\n  else n * factorial(n - 1)\n}\n\ndef gcd(a: Int, b: Int): Int = {\n  if (b == 0) a else gcd(b, a % b)\n}\n\n\n// Использование: просто вызываем функции\nval result1 = factorial(5)\nval result2 = gcd(48, 18)</code></pre>\n\n<pre><code class=\"language-scala\">package com.example.config\n\n// Объект группирует связанные константы\nobject DatabaseDefaults {\n  val MaxConnections = 20\n  val ConnectionTimeoutMs = 5000\n  val RetryAttempts = 3\n  val BackoffMultiplier = 2.0\n  \n  val SupportedDrivers = Set(\"postgresql\", \"mysql\", \"sqlite\")\n  \n  def getConnectionString(host: String, db: String): String = {\n    s\"jdbc:postgresql://$host:5432/$db\"\n  }\n}\n\n// Top-level константы были бы разбросаны\n// val MaxConnections = 20  // Где это относится?\n// val ConnectionTimeoutMs = 5000  // К чему это?</code></pre>\n\n<pre><code class=\"language-scala\">package com.example.parsing\n\n// Избежание конфликтов имен\nobject JsonParser {\n  def parse(json: String): Either[String, JsonValue] = ???\n  def stringify(value: JsonValue): String = ???\n}\n\nobject XmlParser {\n  def parse(xml: String): Either[String, XmlNode] = ???\n  def stringify(node: XmlNode): String = ???\n}\n\n// С top-level функциями был бы конфликт:\n// def parse(json: String): Either[String, JsonValue] = ???  // Какой parse?\n// def parse(xml: String): Either[String, XmlNode] = ???     // Ошибка!</code></pre>\n\n<pre><code class=\"language-scala\">package com.example.validation\n\nobject Validator {\n  // Множественные перегрузки логически связаны\n  def validate(email: String): Either[String, String] = ???\n  def validate(age: Int): Either[String, Int] = ???\n  def validate(phone: String, country: String): Either[String, String] = ???\n  def validate[T](value: T)(using validator: ValidatorInstance[T]): Either[String, T] = ???\n  \n  // Вспомогательные методы\n  private def emailRegex = \"\"\"^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$\"\"\".r\n  private def phoneRegex = \"\"\"\\+?[1-9]\\d{1,14}$\"\"\".r\n}\n\n// Top-level перегрузки создали бы путаницу в пространстве имен пакета</code></pre>\n\n<p>Так же нужно помнить что контейнеры в Scala являются <strong>сущностями первого класса</strong> - их можно передавать как параметры, возвращать из функций, присваивать переменным.</p>\n\n<ul>\n</ul>",
    "video" : null,
    "options" : {
      
    },
    "subtitle_files" : [
    ],
    "is_deprecated" : false
  },
  "name" : "text",
  "course_id" : 195883,
  "course_name" : "Функциональная Scala 3 для начинающих",
  "exported_at" : "2025-12-20T22:21:42.9907495"
}