# Материал (Шаг 2)

## Информация о шаге

- **ID шага**: 7924871
- **Позиция**: 2
- **Тип**: text
- **Курс**: Функциональная Scala 3 для начинающих
- **Экспортирован**: 2026-01-10T10:17:38.0591488

## Содержание

# Практические рекомендации применения пакетов

## Конвенции именования пакетов

**Стандартные правила именования:**

- **Используйте reverse domain naming**: `com.company.project.module`

- **Только строчные буквы**: `com.example.myapp`, не `com.Example.MyApp`

- **Разделяйте слова точками**: `com.example.user.management`

- **Избегайте подчеркиваний**: используйте `userservice`, не `user_service`

- **Будьте описательными**: `com.example.ecommerce.orders`, не `com.example.app.stuff`

**Примеры хорошего именования:**

package com.example.ecommerce.domain.user
package com.example.ecommerce.infrastructure.database
package com.example.ecommerce.application.services
package com.example.ecommerce.interfaces.rest

**Примеры плохого именования:**

package com.example.App.User_Stuff // заглавные буквы и подчеркивания
package com.example.things // неописательное имя
package com.example.a.b.c.d.e.f // слишком глубокая вложенность
package stuff // отсутствие reverse domain

## Организация пакетов

### Группировка по функциональности

Организуйте пакеты по доменным областям, а не по техническим слоям:

com.example.ecommerce
├── user
│ ├── User
│ ├── UserService
│ └── UserRepository
├── order
│ ├── Order
│ ├── OrderService
│ └── OrderRepository
├── product
│ ├── Product
│ ├── ProductService
│ └── ProductRepository
└── payment
├── Payment
├── PaymentService
└── PaymentProvider

### Слоистая архитектура через пакеты

Альтернативный подход - организация по архитектурным слоям:

com.example.myapp
├── domain // бизнес-логика
│ ├── User
│ ├── Order
│ └── UserRepository (trait)
├── application // оркестрация
│ ├── UserService
│ ├── OrderService
│ └── ApplicationConfig
├── infrastructure // технические детали
│ ├── DatabaseUserRepository
│ ├── FileSystemConfig
│ └── EmailService
└── interfaces // API, контроллеры
├── UserController
├── OrderController
└── ApiRoutes

### **Принципы организации:**

- **Доменная группировка** - лучше для микросервисов и модульных приложений

- **Слоистая архитектура** - лучше для монолитных приложений с четким разделением ответственности

- **Избегайте циклических зависимостей** между пакетами

- **Стабильные зависимости** - менее стабильные пакеты зависят от более стабильных

## **Рекомендации по количеству **верхнеуровневых **определений в файле:**

- **Одно основное определение** - предпочтительный подход для больших классов и сложной логики

// User.scala - один основной класс
package com.example.myapp.models

case class User(id: Long, name: String, email: String) {
// сложная логика валидации, методы, etc.
}

object User {
// companion object с фабричными методами
}

- **Несколько связанных определений** - допустимо для тесно связанных типов

// ValidationResult.scala - группа небольших связанных классов
package com.example.myapp.validation

sealed trait ValidationResult
case object Valid extends ValidationResult
case class Invalid(errors: List[String]) extends ValidationResult

case class ValidationError(field: String, message: String)
case class ValidationRule(name: String, check: String => Boolean)

object ValidationResult {
def combine(results: List[ValidationResult]): ValidationResult = ???
def fromErrors(errors: List[ValidationError]): ValidationResult = ???
}

- **Множественные определения** - для утилит, констант и вспомогательных функций

// ValidationUtils.scala - набор утилитарных функций
package com.example.myapp.utils

def validateEmail(email: String): Boolean = ???
def validatePhone(phone: String): Boolean = ???
def sanitizeInput(input: String): String = ???

val EMAIL_REGEX = """^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$""".r
val PHONE_REGEX = """\+?[1-9]\d{1,14}$""".r

object ValidationMessages {
val INVALID_EMAIL = "Invalid email format"
val INVALID_PHONE = "Invalid phone format"
}

**Избегайте:**

- Слишком много несвязанных между собой определений в одном файле

- Файлы размером более 200-300 строк (исключение - автогенерируемый код)

- Смешивание разных доменных областей в одном файле

## Top-level функции vs функции в статических контейнерах

**Зачем использовать статические контейнеры для группировки функций, если есть пакеты?**

Пакеты и статические контейнеры решают задачи группировки на разных уровнях абстракции:

**Пакеты** предназначены для **крупномасштабной архитектурной группировки** - организации слоев приложения или доменных областей (например, `com.example.user`, `com.example.order`, `com.example.payment`).

**Статические контейнеры** обеспечивают **локальную тематическую группировку** внутри пакета - объединение семантически связанных функций для удобства использования и целостности API (например, `StringUtils`, `DateUtils`, `ValidationUtils`).

### Принципы выбора размещения функции:

**Используйте top-level функции когда:**

- Функция очень востребована и универсальна для разнообразного использования.

- Функция компактна, независима и самодостаточна

- Нет риска конфликтов имен в большем пакете

**Используйте статический контейнер когда:**

- Нужно сгруппировать связанную функциональность в небольшую, более связную группу

- Есть общее состояние или конфигурация

- Множественные перегрузки с одним именем

- Нужно избежать конфликтов имен

- Создается API с множественными связанными операциями

- Есть необходимость использовать контейнер как значение

package com.example.utils.math

// Простые утилитарные функции - идеально для top-level
def factorial(n: Int): Long = {
if (n <= 1) 1L
else n * factorial(n - 1)
}

def gcd(a: Int, b: Int): Int = {
if (b == 0) a else gcd(b, a % b)
}

// Использование: просто вызываем функции
val result1 = factorial(5)
val result2 = gcd(48, 18)

package com.example.config

// Объект группирует связанные константы
object DatabaseDefaults {
val MaxConnections = 20
val ConnectionTimeoutMs = 5000
val RetryAttempts = 3
val BackoffMultiplier = 2.0

val SupportedDrivers = Set("postgresql", "mysql", "sqlite")

def getConnectionString(host: String, db: String): String = {
s"jdbc:postgresql://$host:5432/$db"
}
}

// Top-level константы были бы разбросаны
// val MaxConnections = 20 // Где это относится?
// val ConnectionTimeoutMs = 5000 // К чему это?

package com.example.parsing

// Избежание конфликтов имен
object JsonParser {
def parse(json: String): Either[String, JsonValue] = ???
def stringify(value: JsonValue): String = ???
}

object XmlParser {
def parse(xml: String): Either[String, XmlNode] = ???
def stringify(node: XmlNode): String = ???
}

// С top-level функциями был бы конфликт:
// def parse(json: String): Either[String, JsonValue] = ??? // Какой parse?
// def parse(xml: String): Either[String, XmlNode] = ??? // Ошибка!

package com.example.validation

object Validator {
// Множественные перегрузки логически связаны
def validate(email: String): Either[String, String] = ???
def validate(age: Int): Either[String, Int] = ???
def validate(phone: String, country: String): Either[String, String] = ???
def validate[T](value: T)(using validator: ValidatorInstance[T]): Either[String, T] = ???

// Вспомогательные методы
private def emailRegex = """^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$""".r
private def phoneRegex = """\+?[1-9]\d{1,14}$""".r
}

// Top-level перегрузки создали бы путаницу в пространстве имен пакета

Так же нужно помнить что контейнеры в Scala являются **сущностями первого класса** - их можно передавать как параметры, возвращать из функций, присваивать переменным.

---

### Полные данные JSON

<details>
<summary>Показать JSON данные</summary>

```json
{
  "name" : "text",
  "text" : "<h1 style=\"text-align:center;\">Практические рекомендации применения пакетов&nbsp;</h1>\n\n<h2 style=\"text-align:center;\">Конвенции именования пакетов</h2>\n\n<p><strong>Стандартные правила именования:</strong></p>\n\n<ol>\n\t<li><strong>Используйте reverse domain naming</strong>: <code>com.company.project.module</code></li>\n\t<li><strong>Только строчные буквы</strong>: <code>com.example.myapp</code>, не <code>com.Example.MyApp</code></li>\n\t<li><strong>Разделяйте слова точками</strong>: <code>com.example.user.management</code></li>\n\t<li><strong>Избегайте подчеркиваний</strong>: используйте <code>userservice</code>, не <code>user_service</code></li>\n\t<li><strong>Будьте описательными</strong>: <code>com.example.ecommerce.orders</code>, не <code>com.example.app.stuff</code></li>\n</ol>\n\n<p><strong>Примеры хорошего именования:</strong></p>\n\n<pre><code class=\"language-scala\">package com.example.ecommerce.domain.user\npackage com.example.ecommerce.infrastructure.database\npackage com.example.ecommerce.application.services\npackage com.example.ecommerce.interfaces.rest</code></pre>\n\n<p><strong>Примеры плохого именования:</strong></p>\n\n<pre><code class=\"language-scala\">package com.example.App.User_Stuff    // заглавные буквы и подчеркивания\npackage com.example.things            // неописательное имя\npackage com.example.a.b.c.d.e.f      // слишком глубокая вложенность\npackage stuff                         // отсутствие reverse domain</code></pre>\n\n<ul>\n</ul>\n\n<h2 style=\"text-align:center;\">Организация пакетов</h2>\n\n<h3>Группировка по функциональности</h3>\n\n<p>Организуйте пакеты по доменным областям, а не по техническим слоям:</p>\n\n<pre style=\"background:transparent; color:#383a42; text-align:left;\"><code style=\"background:transparent; color:#383a42; text-align:left;\">com.example.ecommerce\n├── user\n│   ├── User\n│   ├── UserService\n│   └── UserRepository\n├── order\n│   ├── Order\n│   ├── OrderService\n│   └── OrderRepository\n├── product\n│   ├── Product\n│   ├── ProductService\n│   └── ProductRepository\n└── payment\n    ├── Payment\n    ├── PaymentService\n    └── PaymentProvider</code></pre>\n\n<h3>Слоистая архитектура через пакеты</h3>\n\n<p>Альтернативный подход - организация по архитектурным слоям:</p>\n\n<pre style=\"background:transparent; color:#383a42; text-align:left;\"><code style=\"background:transparent; color:#383a42; text-align:left;\">com.example.myapp\n├── domain                  // бизнес-логика\n│   ├── User\n│   ├── Order\n│   └── UserRepository (trait)\n├── application            // оркестрация\n│   ├── UserService\n│   ├── OrderService\n│   └── ApplicationConfig\n├── infrastructure         // технические детали\n│   ├── DatabaseUserRepository\n│   ├── FileSystemConfig\n│   └── EmailService\n└── interfaces             // API, контроллеры\n    ├── UserController\n    ├── OrderController\n    └── ApiRoutes</code></pre>\n\n<h3>&nbsp;<strong>Принципы организации:</strong></h3>\n\n<ul>\n\t<li><strong>Доменная группировка</strong> - лучше для микросервисов и модульных приложений</li>\n\t<li><strong>Слоистая архитектура</strong> - лучше для монолитных приложений с четким разделением ответственности</li>\n\t<li><strong>Избегайте циклических зависимостей</strong> между пакетами</li>\n\t<li><strong>Стабильные зависимости</strong> - менее стабильные пакеты зависят от более стабильных</li>\n</ul>\n\n<h2 style=\"text-align:center;\"><strong>Рекомендации по количеству </strong>верхнеуровневых&nbsp;<strong>определений в файле:</strong></h2>\n\n<ul>\n\t<li><strong>Одно основное определение</strong> - предпочтительный подход для больших классов и сложной логики</li>\n</ul>\n\n<pre><code class=\"language-scala\">// User.scala - один основной класс\npackage com.example.myapp.models\n\ncase class User(id: Long, name: String, email: String) {\n  // сложная логика валидации, методы, etc.\n}\n\nobject User {\n  // companion object с фабричными методами\n}</code></pre>\n\n<ul>\n\t<li><strong>Несколько связанных определений</strong> - допустимо для тесно связанных типов</li>\n</ul>\n\n<pre><code class=\"language-scala\">// ValidationResult.scala - группа небольших связанных классов\npackage com.example.myapp.validation\n\nsealed trait ValidationResult\ncase object Valid extends ValidationResult\ncase class Invalid(errors: List[String]) extends ValidationResult\n\ncase class ValidationError(field: String, message: String)\ncase class ValidationRule(name: String, check: String =&gt; Boolean)\n\nobject ValidationResult {\n  def combine(results: List[ValidationResult]): ValidationResult = ???\n  def fromErrors(errors: List[ValidationError]): ValidationResult = ???\n}</code></pre>\n\n<ul>\n\t<li><strong>Множественные определения</strong> - для утилит, констант и вспомогательных функций</li>\n</ul>\n\n<pre><code class=\"language-scala\">// ValidationUtils.scala - набор утилитарных функций\npackage com.example.myapp.utils\n\ndef validateEmail(email: String): Boolean = ???\ndef validatePhone(phone: String): Boolean = ???\ndef sanitizeInput(input: String): String = ???\n\nval EMAIL_REGEX = \"\"\"^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$\"\"\".r\nval PHONE_REGEX = \"\"\"\\+?[1-9]\\d{1,14}$\"\"\".r\n\nobject ValidationMessages {\n  val INVALID_EMAIL = \"Invalid email format\"\n  val INVALID_PHONE = \"Invalid phone format\"\n}</code></pre>\n\n<p><strong>Избегайте:</strong></p>\n\n<ul>\n\t<li>Слишком много несвязанных между собой определений в одном файле</li>\n\t<li>Файлы размером более 200-300 строк (исключение - автогенерируемый код)</li>\n\t<li>Смешивание разных доменных областей в одном файле</li>\n</ul>\n\n<h2 style=\"text-align:center;\">Top-level функции vs функции в статических контейнерах</h2>\n\n<p><strong>Зачем использовать статические контейнеры для группировки функций, если есть пакеты?</strong></p>\n\n<p>Пакеты и статические контейнеры решают задачи группировки на разных уровнях абстракции:</p>\n\n<p><strong>Пакеты</strong> предназначены для <strong>крупномасштабной архитектурной группировки</strong> - организации слоев приложения или доменных областей (например, <code>com.example.user</code>, <code>com.example.order</code>, <code>com.example.payment</code>).</p>\n\n<p><strong>Статические контейнеры</strong> обеспечивают <strong>локальную тематическую группировку</strong> внутри пакета - объединение семантически связанных функций для удобства использования и целостности API (например, <code>StringUtils</code>, <code>DateUtils</code>, <code>ValidationUtils</code>).</p>\n\n<h3>Принципы выбора размещения функции:</h3>\n\n<p><strong>Используйте top-level функции когда:</strong></p>\n\n<ul>\n\t<li>Функция очень востребована и универсальна для разнообразного использования.</li>\n\t<li>Функция компактна, независима и самодостаточна</li>\n\t<li>Нет риска конфликтов имен в большем пакете</li>\n</ul>\n\n<p><strong>Используйте статический контейнер когда:</strong></p>\n\n<ul>\n\t<li>Нужно сгруппировать связанную функциональность в небольшую, более связную группу</li>\n\t<li>Есть общее состояние или конфигурация</li>\n\t<li>Множественные перегрузки с одним именем</li>\n\t<li>Нужно избежать конфликтов имен</li>\n\t<li>Создается API с множественными связанными операциями</li>\n\t<li>Есть необходимость использовать контейнер как значение</li>\n</ul>\n\n<pre><code class=\"language-scala\">package com.example.utils.math\n\n// Простые утилитарные функции - идеально для top-level\ndef factorial(n: Int): Long = {\n  if (n &lt;= 1) 1L\n  else n * factorial(n - 1)\n}\n\ndef gcd(a: Int, b: Int): Int = {\n  if (b == 0) a else gcd(b, a % b)\n}\n\n\n// Использование: просто вызываем функции\nval result1 = factorial(5)\nval result2 = gcd(48, 18)</code></pre>\n\n<pre><code class=\"language-scala\">package com.example.config\n\n// Объект группирует связанные константы\nobject DatabaseDefaults {\n  val MaxConnections = 20\n  val ConnectionTimeoutMs = 5000\n  val RetryAttempts = 3\n  val BackoffMultiplier = 2.0\n  \n  val SupportedDrivers = Set(\"postgresql\", \"mysql\", \"sqlite\")\n  \n  def getConnectionString(host: String, db: String): String = {\n    s\"jdbc:postgresql://$host:5432/$db\"\n  }\n}\n\n// Top-level константы были бы разбросаны\n// val MaxConnections = 20  // Где это относится?\n// val ConnectionTimeoutMs = 5000  // К чему это?</code></pre>\n\n<pre><code class=\"language-scala\">package com.example.parsing\n\n// Избежание конфликтов имен\nobject JsonParser {\n  def parse(json: String): Either[String, JsonValue] = ???\n  def stringify(value: JsonValue): String = ???\n}\n\nobject XmlParser {\n  def parse(xml: String): Either[String, XmlNode] = ???\n  def stringify(node: XmlNode): String = ???\n}\n\n// С top-level функциями был бы конфликт:\n// def parse(json: String): Either[String, JsonValue] = ???  // Какой parse?\n// def parse(xml: String): Either[String, XmlNode] = ???     // Ошибка!</code></pre>\n\n<pre><code class=\"language-scala\">package com.example.validation\n\nobject Validator {\n  // Множественные перегрузки логически связаны\n  def validate(email: String): Either[String, String] = ???\n  def validate(age: Int): Either[String, Int] = ???\n  def validate(phone: String, country: String): Either[String, String] = ???\n  def validate[T](value: T)(using validator: ValidatorInstance[T]): Either[String, T] = ???\n  \n  // Вспомогательные методы\n  private def emailRegex = \"\"\"^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$\"\"\".r\n  private def phoneRegex = \"\"\"\\+?[1-9]\\d{1,14}$\"\"\".r\n}\n\n// Top-level перегрузки создали бы путаницу в пространстве имен пакета</code></pre>\n\n<p>Так же нужно помнить что контейнеры в Scala являются <strong>сущностями первого класса</strong> - их можно передавать как параметры, возвращать из функций, присваивать переменным.</p>\n\n<ul>\n</ul>",
  "video" : null,
  "options" : {
    
  },
  "subtitle_files" : [
  ],
  "is_deprecated" : false
}
```

</details>
