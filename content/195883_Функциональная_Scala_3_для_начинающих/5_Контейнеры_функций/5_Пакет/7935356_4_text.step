{
  "step_id" : 7935356,
  "lesson_id" : 1906022,
  "position" : 4,
  "type" : "unknown",
  "block" : {
    "name" : "text",
    "text" : "<h1 style=\"text-align:center;\">Модульная архитектура с пакетами</h1>\n\n<p style=\"text-align:center;\"><em>(обзорная статья)</em></p>\n\n<p>Пакеты в Scala 3 являются не просто механизмом организации файлов, но фундаментальным инструментом для создания модульной архитектуры. Правильное использование пакетов позволяет строить maintainable и scalable приложения, где каждый компонент имеет четко определенные границы и ответственность.</p>\n\n<h2 style=\"text-align:center;\">Философия пакетной архитектуры</h2>\n\n<h3>Пакеты как архитектурные границы</h3>\n\n<p>В традиционном подходе пакеты часто рассматриваются как простой способ группировки классов. Однако в современной разработке пакеты должны отражать <strong>архитектурные границы</strong> приложения. Каждый пакет представляет собой <strong>логический модуль</strong> со своей ответственностью, интерфейсами и правилами взаимодействия.</p>\n\n<p>Пакетная структура должна отвечать на вопросы: \"Какие компоненты могут изменяться независимо?\", \"Какие части системы должны быть изолированы от изменений в других частях?\", \"Как минимизировать влияние изменений на остальную систему?\"</p>\n\n<h3>Принцип единственной ответственности на уровне пакетов</h3>\n\n<p>Каждый пакет должен иметь <strong>одну причину для изменения</strong>. Это означает, что все классы и функции в пакете должны изменяться по одной и той же причине. Например, пакет <code>com.example.user.domain</code> изменяется только при изменении бизнес-правил, связанных с пользователями, а пакет <code>com.example.user.infrastructure</code> - только при изменении способа хранения данных о пользователях.</p>\n\n<p>Такой подход позволяет локализовать изменения и минимизировать их влияние на другие части системы. Когда требования к пользовательскому интерфейсу изменяются, затрагивается только пакет <code>interfaces</code>, когда изменяется база данных - только пакет <code>infrastructure</code>.</p>\n\n<h3>Стабильность пакетов</h3>\n\n<p><strong>Стабильные пакеты</strong> содержат код, который редко изменяется - базовые доменные модели, фундаментальные утилиты, общие интерфейсы. <strong>Нестабильные пакеты</strong> содержат код, который часто изменяется - пользовательские интерфейсы, интеграции с внешними системами, конфигурация.</p>\n\n<p>Правило зависимостей: нестабильные пакеты должны зависеть от стабильных, но не наоборот. Это обеспечивает, что изменения в нестабильных пакетах не влияют на стабильные компоненты системы.</p>\n\n<h2 style=\"text-align:center;\">Доменно-ориентированная пакетная структура</h2>\n\n<h3>Вертикальное разделение по доменам</h3>\n\n<p>Вместо традиционного <strong>горизонтального разделения</strong> по техническим слоям (<code>controllers</code>, <code>services</code>, <code>repositories</code>), современный подход предполагает <strong>вертикальное разделение</strong> по доменным областям (<code>user</code>, <code>order</code>, <code>product</code>, <code>payment</code>).</p>\n\n<p>Каждый доменный пакет содержит все необходимые слои для работы с конкретной предметной областью. Это позволяет командам работать независимо над разными доменами, минимизирует конфликты при слиянии кода и упрощает понимание системы.</p>\n\n<p>В пакете <code>com.example.ecommerce.user</code> находится всё, что связано с пользователями: доменные модели, бизнес-правила, сервисы, репозитории, контроллеры. Разработчик, работающий с функциональностью пользователей, может сосредоточиться на одном пакете, не отвлекаясь на другие области системы.</p>\n\n<h3>Микро-модули через пакеты</h3>\n\n<p>Каждый доменный пакет можно рассматривать как <strong>микро-модуль</strong> - независимый компонент с четко определенным API. Микро-модули взаимодействуют через публичные интерфейсы, скрывая детали реализации.</p>\n\n<p>Это особенно важно в больших командах, где разные группы разработчиков отвечают за разные домены. Пакетная структура обеспечивает <strong>естественные границы ответственности</strong> и позволяет командам развивать свои модули независимо.</p>\n\n<h3>Shared Kernel - общее ядро</h3>\n\n<p>Некоторые концепции являются общими для всех доменов. <strong>Shared Kernel</strong> - это набор пакетов, содержащих общие типы данных, утилиты и базовые абстракции, которые используются всеми доменными модулями.</p>\n\n<p>Пакет <code>com.example.shared.types</code> может содержать базовые value objects как <code>Money</code>, <code>Email</code>, <code>Address</code>. Пакет <code>com.example.shared.events</code> - общие интерфейсы для доменных событий. Пакет <code>com.example.shared.results</code> - стандартные типы для результатов операций.</p>\n\n<p>Shared Kernel должен быть <strong>максимально стабильным</strong>, поскольку изменения в нём влияют на все домены. Поэтому в него включаются только самые фундаментальные и устоявшиеся концепции.</p>\n\n<h2 style=\"text-align:center;\">Слоистая архитектура через пакеты</h2>\n\n<h3>Принцип инверсии зависимостей</h3>\n\n<p><strong>Clean Architecture</strong> и <strong>Hexagonal Architecture</strong> могут быть элегантно реализованы через пакетную структуру. Ключевой принцип - <strong>инверсия зависимостей</strong>: внешние слои зависят от внутренних, но внутренние слои не знают о внешних.</p>\n\n<p>Пакет <code>domain</code> находится в центре и не зависит ни от каких других пакетов приложения. Пакет <code>application</code> зависит от <code>domain</code>, но не знает о <code>infrastructure</code> или <code>interfaces</code>. Пакет <code>infrastructure</code> реализует интерфейсы, определённые в <code>domain</code>, но сам <code>domain</code> не знает о конкретных реализациях.</p>\n\n<h3>Пакеты как слои абстракции</h3>\n\n<p>Каждый пакет представляет определённый <strong>уровень абстракции</strong>. Пакет <code>domain</code> оперирует бизнес-концепциями и правилами. Пакет <code>application</code> координирует доменные объекты для выполнения use cases. Пакет <code>infrastructure</code> работает с техническими деталями - базами данных, файловыми системами, внешними API.</p>\n\n<p>Такое разделение позволяет <strong>тестировать каждый слой независимо</strong>. Доменную логику можно тестировать без базы данных, application services - с моками репозиториев, infrastructure компоненты - с тестовыми контейнерами.</p>\n\n<h2 style=\"text-align:center;\">Управление зависимостями между пакетами</h2>\n\n<h3>Избежание циклических зависимостей</h3>\n\n<p><strong>Циклические зависимости</strong> между пакетами - один из главных признаков плохой архитектуры. Они делают код сложным для понимания, тестирования и изменения. Пакетная структура должна формировать <strong>направленный ациклический граф</strong> (DAG).</p>\n\n<p>Для выявления циклических зависимостей можно использовать инструменты статического анализа или архитектурные тесты. Циклы часто возникают, когда нарушается принцип слоистости или когда доменные модули слишком тесно связаны.</p>\n\n<h3>Стратегии разрыва циклов</h3>\n\n<p>Когда циклическая зависимость обнаружена, существует несколько стратегий её разрыва. <strong>Вынос общих типов</strong> в отдельный пакет позволяет двум модулям зависеть от общего компонента вместо друг от друга.</p>\n\n<p><strong>Инверсия зависимостей</strong> через интерфейсы позволяет модулю высокого уровня определить интерфейс, который реализует модуль низкого уровня. <strong>Event-driven взаимодействие</strong> заменяет прямые вызовы на асинхронную передачу событий.</p>\n\n<h3>Метрики зависимостей</h3>\n\n<p>Для оценки качества пакетной архитектуры используются различные метрики. <strong>Afferent Coupling (Ca)</strong> показывает, сколько других пакетов зависит от данного пакета. <strong>Efferent Coupling (Ce)</strong> показывает, от скольких пакетов зависит данный пакет.</p>\n\n<p><strong>Instability (I)</strong> вычисляется как Ce/(Ca+Ce) и показывает нестабильность пакета. Значение близкое к 0 указывает на стабильный пакет, близкое к 1 - на нестабильный. <strong>Abstractness (A)</strong> показывает долю абстрактных классов и интерфейсов в пакете.</p>\n\n<h2 style=\"text-align:center;\">Эволюция пакетной архитектуры</h2>\n\n<h3>Рефакторинг пакетной структуры</h3>\n\n<p>По мере роста приложения пакетная структура должна эволюционировать. <strong>Разделение больших пакетов</strong> на более мелкие позволяет лучше отражать растущую сложность домена. <strong>Объединение мелких пакетов</strong> устраняет излишнюю фрагментацию.</p>\n\n<p><strong>Перемещение функциональности</strong> между пакетами должно выполняться осторожно, с учётом влияния на зависимости. Современные IDE предоставляют инструменты для безопасного рефакторинга пакетной структуры.</p>\n\n<h3>Версионирование пакетов</h3>\n\n<p>В больших системах разные части могут развиваться с разной скоростью. <strong>Семантическое версионирование</strong> на уровне пакетов позволяет управлять совместимостью API. Пакет <code>com.example.api.v1</code> может существовать параллельно с <code>com.example.api.v2</code> во время миграции.</p>\n\n<p><strong>Deprecated пакеты</strong> позволяют постепенно выводить старую функциональность из использования. Аннотации <code>@deprecated</code> на уровне пакетов предупреждают разработчиков о планируемых изменениях.</p>\n\n<h3>Модульное тестирование архитектуры</h3>\n\n<p><strong>Архитектурные тесты</strong> автоматически проверяют соблюдение архитектурных принципов. Они могут проверять, что слой <code>domain</code> не зависит от <code>infrastructure</code>, что нет циклических зависимостей, что все repository интерфейсы находятся в правильных пакетах.</p>\n\n<p>Такие тесты особенно важны в больших командах, где разные разработчики могут случайно нарушить архитектурные принципы. Они служат <strong>живой документацией</strong> архитектуры и предотвращают её деградацию.</p>\n\n<h2 style=\"text-align:center;\">Пакеты и производительность</h2>\n\n<h3>Время компиляции</h3>\n\n<p>Пакетная структура напрямую влияет на <strong>время компиляции</strong>. Scala компилятор может компилировать независимые пакеты параллельно, но изменения в часто используемых пакетах вызывают перекомпиляцию зависимых модулей.</p>\n\n<p><strong>Минимизация зависимостей</strong> между пакетами сокращает каскадную перекомпиляцию. <strong>Стабильные интерфейсы</strong> позволяют изменять реализацию без перекомпиляции клиентского кода.</p>\n\n<h3>Время загрузки приложения</h3>\n\n<p>В runtime пакетная структура влияет на <strong>время загрузки приложения</strong>. <strong>Lazy initialization</strong> позволяет загружать модули только при первом обращении. <strong>Модульная конфигурация</strong> позволяет отключать ненужные компоненты в определённых окружениях.</p>\n\n<p><strong>Dependency injection контейнеры</strong> должны учитывать пакетную структуру для оптимального порядка инициализации компонентов. Компоненты без зависимостей могут инициализироваться параллельно.</p>\n\n<h3>Размер артефактов</h3>\n\n<p>Пакетная структура может влиять на <strong>размер финальных артефактов</strong>. <strong>Dead code elimination</strong> работает эффективнее, когда неиспользуемые пакеты можно полностью исключить из сборки. <strong>Модульные JAR файлы</strong> позволяют развёртывать только необходимые компоненты.</p>\n\n<h2 style=\"text-align:center;\">Документирование пакетной архитектуры</h2>\n\n<h3>Архитектурная документация</h3>\n\n<p>Пакетная структура сама по себе является <strong>формой документации</strong>. Хорошо организованные пакеты рассказывают о структуре системы без дополнительных объяснений. Однако важно дополнять её <strong>архитектурными диаграммами</strong> и <strong>описанием принципов</strong>.</p>\n\n<p><strong>ADR (Architecture Decision Records)</strong> должны фиксировать решения о пакетной структуре. Почему выбрана именно такая организация? Какие альтернативы рассматривались? Какие компромиссы были сделаны?</p>\n\n<h3>Package-info файлы</h3>\n\n<p>В Java и Scala можно создавать <strong>package-info.scala</strong> файлы для документирования пакетов. Они содержат описание назначения пакета, основных компонентов, принципов использования.</p>\n\n<p>Хорошо документированные пакеты упрощают <strong>онбординг новых разработчиков</strong> и снижают когнитивную нагрузку при работе с кодом.</p>\n\n<h2 style=\"text-align:center;\">Интеграция с инструментами сборки</h2>\n\n<h3>Build-time проверки</h3>\n\n<p>Современные build tools позволяют настраивать <strong>проверки архитектуры</strong> на этапе сборки. SBT плагины могут анализировать зависимости между пакетами и предотвращать нарушения архитектурных принципов.</p>\n\n<p><strong>Incremental compilation</strong> в SBT работает эффективнее при правильной пакетной структуре. Изменения в листовых пакетах не вызывают перекомпиляцию корневых модулей.</p>\n\n<h3>Модульная сборка</h3>\n\n<p>Пакетная структура может отражаться в <strong>структуре build файлов</strong>. Каждый доменный модуль может быть отдельным SBT проектом с собственными зависимостями и настройками.</p>\n\n<p>Это позволяет <strong>независимо версионировать</strong> модули, <strong>параллельно собирать</strong> независимые компоненты, <strong>публиковать</strong> модули как отдельные артефакты.</p>\n\n<h2 style=\"text-align:center;\">Заключение</h2>\n\n<p>Пакеты в Scala 3 - это мощный инструмент для создания модульной архитектуры. Правильное использование пакетов позволяет создавать системы, которые легко понимать, тестировать, изменять и масштабировать.</p>\n\n<p><strong>Ключевые принципы эффективной пакетной архитектуры:</strong></p>\n\n<p><strong>Четкие границы ответственности</strong> - каждый пакет имеет определённую роль в системе и изменяется по конкретным причинам.</p>\n\n<p><strong>Управляемые зависимости</strong> - зависимости между пакетами образуют ациклический граф с четким направлением от нестабильных к стабильным компонентам.</p>\n\n<p><strong>Инкапсуляция на архитектурном уровне</strong> - детали реализации скрыты за пакетными границами и контролируются модификаторами доступа.</p>\n\n<p><strong>Соответствие доменной модели</strong> - пакетная структура отражает структуру предметной области и помогает разработчикам ориентироваться в коде.</p>\n\n<p><strong>Эволюционность</strong> - архитектура может адаптироваться к изменяющимся требованиям без кардинальной перестройки.</p>\n\n<p>Инвестиции в продуманную пакетную архитектуру окупаются многократно в долгосрочной перспективе, обеспечивая maintainability и extensibility системы на протяжении всего её жизненного цикла.</p>",
    "video" : null,
    "options" : {
      
    },
    "subtitle_files" : [
    ],
    "is_deprecated" : false
  },
  "name" : "text",
  "course_id" : 195883,
  "course_name" : "Функциональная Scala 3 для начинающих",
  "exported_at" : "2025-12-20T22:21:43.0006697"
}