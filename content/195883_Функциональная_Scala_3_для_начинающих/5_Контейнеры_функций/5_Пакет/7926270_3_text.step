{
  "step_id" : 7926270,
  "lesson_id" : 1906022,
  "position" : 3,
  "type" : "unknown",
  "block" : {
    "name" : "text",
    "text" : "<h1 style=\"text-align:center;\">Импорт</h1>\n\n<p><strong>Импорт</strong> позволяет использовать элементы из других пакетов без указания полного квалифицированного имени. <strong>Импорт не является обязательным</strong> - вы всегда можете использовать полный путь к классу.</p>\n\n<p><br>\n<strong>Синтаксис импорта:</strong></p>\n\n<pre><code class=\"language-scala\">import package.name.Element\nimport package.name.{Element1, Element2}\nimport package.name.{Element as Alias}\nimport package.name.*\nimport package.name.given</code></pre>\n\n<p><strong>Что такое импорт:</strong></p>\n\n<ul>\n\t<li><strong>Не определение</strong> - импорт не создает новые классы или объекты</li>\n\t<li><strong>Декларация видимости</strong> - делает существующие элементы доступными под короткими именами</li>\n\t<li><strong>Синоним имени</strong> - создает локальный псевдоним для полного квалифицированного имени</li>\n</ul>\n\n<p>Конструкция <code>import</code> так же является псевдо-выражением (возвращает тип Unit), и соответственно, может быть указано в любом месте программы, где допустимо выражение.</p>\n\n<h3>Без импорта - полные имена</h3>\n\n<pre><code class=\"language-scala\">package com.example.myapp.services\n\nclass UserService {\n  // Использование без импорта - через полное имя\n  def createUser(name: String): com.example.myapp.models.User = {\n    com.example.myapp.models.User(name)\n  }\n  \n  def processDate(): String = {\n    val now = java.time.Instant.now()\n    val formatter = java.time.format.DateTimeFormatter.ISO_INSTANT\n    formatter.format(now)\n  }\n}\n</code></pre>\n\n<h3>С импортом - короткие имена</h3>\n\n<pre><code class=\"language-scala\">package com.example.myapp.services\n\n// Импорт для удобства\nimport com.example.myapp.models.User\nimport java.time.{Instant, format.DateTimeFormatter}\nimport scala.util.Try\n\nclass UserService {\n  // Теперь можно использовать короткие имена\n  def createUser(name: String): User = {\n    User(name)\n  }\n  \n  def processDate(): String = {\n    val now = Instant.now()\n    val formatter = DateTimeFormatter.ISO_INSTANT\n    formatter.format(now)\n  }\n}\n</code></pre>\n\n<p><strong>Когда использовать полные имена без импорта:</strong></p>\n\n<ul>\n\t<li><strong>Редкое использование</strong> - класс нужен только в одном месте</li>\n\t<li><strong>Избежание конфликтов</strong> - когда импорт создал бы путаницу</li>\n\t<li><strong>Явность</strong> - когда важно подчеркнуть происхождение класса</li>\n</ul>\n\n<pre><code class=\"language-scala\">// Пример с конфликтом имен\nclass DateProcessor {\n  def processJavaDate(): String = {\n    val date = new java.util.Date()  // Явно Java Date\n    date.toString\n  }\n  \n  def processSqlDate(): String = {\n    val date = new java.sql.Date(System.currentTimeMillis())  // Явно SQL Date\n    date.toString\n  }\n  \n  // Без полных имен было бы неясно, какой Date используется\n}\n</code></pre>\n\n<h2 style=\"text-align:center;\">Конкретный импорт </h2>\n\n<pre><code class=\"language-scala\">package com.example.myapp.services\n\n// Импорт конкретного класса\nimport com.example.myapp.models.User\n\nclass UserService {\n  def createUser(name: String): User = {\n    User(name) // Используем без полного имени\n  }\n}\n</code></pre>\n\n<h2 style=\"text-align:center;\">Импорт нескольких элементов</h2>\n\n<pre><code class=\"language-scala\">// Импорт нескольких элементов из одного пакета\nimport com.example.myapp.models.{User, Product, Order}\n\n// Импорт всех элементов пакета\nimport com.example.myapp.models.*\n</code></pre>\n\n<h2 style=\"text-align:center;\">Импорт с переименованием</h2>\n\n<pre><code class=\"language-scala\">import com.example.auth.User as AuthUser\nimport com.example.billing.User as BillingUser\n\nclass UserService {\n  def authenticate(user: AuthUser): Boolean = ???\n  def getBilling(user: BillingUser): BigDecimal = ???\n}\n</code></pre>\n\n<h2 style=\"text-align:center;\">Импорт содержимого контейнера</h2>\n\n<pre><code class=\"language-scala\">// Импорт всего содержимого контейнера\nimport scala.math.Ordering.Implicits.*\n\n// Импорт функций контейнера\nimport scala.util.Random.{nextInt, nextDouble}\n\nclass MathProcessor {\n  def compare[T](a: T, b: T)(using ord: Ordering[T]): Int = ord.compare(a, b)\n  def randomValue(): (Int, Double) = (nextInt(100), nextDouble())\n}</code></pre>\n\n<h2 style=\"text-align:center;\">Локальный импорт</h2>\n\n<pre><code class=\"language-scala\">package com.example.myapp\n\nclass DataProcessor {\n  def processXml(xml: String): String = {\n    // локальный импорт\n    import scala.xml.*\n    \n    val parsed = XML.loadString(xml)\n    parsed.toString\n  }\n  \n  // parse и XML здесь недоступны\n}\n</code></pre>\n\n<h2 style=\"text-align:center;\">Импорт в блоках кода</h2>\n\n<pre><code class=\"language-scala\">def complexProcessing(data: String): Int = {\n  data.map{ item =&gt;\n    // Еще более локальный импорт\n    import java.security.MessageDigest\n    \n    val digest = MessageDigest.getInstance(\"SHA-256\")\n    digest.digest(item.getByte).length\n  }.sum\n}\n</code></pre>\n\n<h2 style=\"text-align:center;\">Автоматические импорты</h2>\n\n<p>Scala 3 автоматически импортирует несколько пакетов:</p>\n\n<pre><code class=\"language-scala\">// Эти импорты добавляются автоматически в каждый файл:\n// import java.lang.*\n// import scala.*\n// import scala.Predef.*\n\npackage com.example.myapp\n\nclass Example {\n  // Доступны без явного импорта:\n  val text: String = \"Hello\"           // java.lang.String\n  val number: Int = 42                 // scala.Int\n  val list: List[Int] = List(1, 2, 3)  // scala.collection.immutable.List\n  \n  def print(msg: String): Unit = {\n    println(msg)  // scala.Predef.println\n  }\n}\n</code></pre>\n\n<h2 style=\"text-align:center;\">Относительные импорты</h2>\n\n<pre><code class=\"language-scala\">package com.example.myapp.services\n\n// Относительный импорт - относительно текущего пакета\nimport models.User        // com.example.myapp.services.models.User\nimport utils.*            // com.example.myapp.services.utils.*\n\n// Переход на уровень выше\nimport ..models.Product   // com.example.myapp.models.Product\n</code></pre>\n\n<h2 style=\"text-align:center;\">Абсолютные импорты</h2>\n\n<pre><code class=\"language-scala\">package com.example.myapp.services\n\n// Абсолютный импорт - от корня\nimport com.example.myapp.models.User\nimport com.example.common.utils.StringUtils\n\n// Явное указание корня (для избежания конфликтов)\nimport _root_.java.util.Date\nimport _root_.scala.collection.mutable.Map\n</code></pre>\n\n<h2 style=\"text-align:center;\">Конфликты</h2>\n\n<pre><code class=\"language-scala\">// Плохо - неясно, какой List используется\nimport java.util.*\nimport scala.collection.mutable.*\n\n// Хорошо - явное указание\nimport java.util.{List as JavaList}\nimport scala.collection.mutable.{List as MutableList}\nimport scala.collection.immutable.List // default List\n\nclass DataProcessor {\n  val javaList: JavaList[String] = ???\n  val mutableList: MutableList[String] = ???\n  val immutableList: List[String] = ???\n}\n</code></pre>\n\n<h2 style=\"text-align:center;\">Минимизация импортов</h2>\n\n<pre><code class=\"language-scala\">// Плохо - излишние импорты\nimport scala.collection.mutable.*\nimport scala.util.*\n\n// Хорошо - только необходимое\nimport scala.collection.mutable.ListBuffer\nimport scala.util.{Try, Success}\n\nclass SimpleProcessor {\n  private val buffer = ListBuffer[String]()\n  \n  def process(data: String): Try[String] = {\n    Success(data.toUpperCase)\n  }\n}\n</code></pre>",
    "video" : null,
    "options" : {
      
    },
    "subtitle_files" : [
    ],
    "is_deprecated" : false
  },
  "name" : "text",
  "course_id" : 195883,
  "course_name" : "Функциональная Scala 3 для начинающих",
  "exported_at" : "2026-01-10T10:17:38.0695647"
}