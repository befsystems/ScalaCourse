# Материал (Шаг 1)

## Информация о шаге

- **ID шага**: 7866138
- **Позиция**: 1
- **Тип**: text
- **Курс**: Функциональная Scala 3 для начинающих
- **Экспортирован**: 2026-01-10T10:17:35.0966322

## Содержание

# Абстрактный контейнер функций

**Абстрактный контейнер функций** — это контейнер, который содержит как конкретные функции с полной реализацией, так и **абстрактные функции**, не имеющие реализации. Абстрактный контейнер нельзя создать напрямую — сначала необходимо создать наследующий контейнер, который реализует все абстрактные функции.

Абстрактные контейнеры служат **шаблонами** или **каркасами** для создания семейства совместимых контейнеров, обеспечивая общую структуру и частичную функциональность, которую наследники могут дополнить или переопределить.

**Абстрактная функция** — это объявление функции без её реализации. Она определяет **сигнатуру** (имя и параметры), но не содержит тела функции.

## Определение абстрактного контейнера

Абстрактный контейнер определяется с помощью ключевого слова `abstract` перед `class`. Внутри такого контейнера могут находиться:

- **Конкретные функции** с полной реализацией

- **Абстрактные функции** без реализации

- **Значения** (как конкретные, так и абстрактные)

**Синтаксис определения абстрактного контейнера:**

abstract class ContainerTypeName(params):
// Функции без реализации
def calculateResult(param: Type): ReturnType

// Конкретные функции (с реализацией)
def processData(param: Type): ReturnType =
// реализация

// Значения без инициализации
val configValue: Type

// Конкретные значения
val defaultValue: Type = value

**Пример определения абстрактного контейнера:**

// Абстрактный контейнер для работы с фигурами
abstract class Shape(val name: String):
// Функции без реализации - должны быть реализованы наследниками
def area(): Double
def perimeter(): Double

// Значение без инициализации
val color: String

// Конкретные функции - уже реализованы
def describe(): String =
s"$name with color $color"

def info(): String =
s"Shape: $name, Area: ${area()}, Perimeter: ${perimeter()}"

// Конкретное значение
val dimension: Int = 2

## Создание наследующих контейнеров

Чтобы использовать абстрактный контейнер, необходимо создать наследующий контейнер, который **реализует все элементы без реализации**.

**Пример реализации наследующих контейнеров:**

// Наследующий контейнер - Круг
class Circle(name: String, val radius: Double, val color: String) extends Shape(name):
// Реализуем функции без реализации
override def area(): Double =
math.Pi * radius * radius

override def perimeter(): Double =
2 * math.Pi * radius

// Можем добавить дополнительные функции
def diameter(): Double = 2 * radius

// Наследующий контейнер - Прямоугольник
class Rectangle(name: String, val width: Double, val height: Double, val color: String) extends Shape(name):
// Реализуем функции без реализации
override def area(): Double =
width * height

override def perimeter(): Double =
2 * (width + height)

// Можем переопределить конкретные функции родителя
override def describe(): String =
s"Rectangle $name ($width x $height) with color $color"

// Наследующий контейнер - Треугольник
class Triangle(name: String, val a: Double, val b: Double, val c: Double, val color: String) extends Shape(name):
override def area(): Double =
val s = perimeter() / 2
math.sqrt(s * (s - a) * (s - b) * (s - c))

override def perimeter(): Double =
a + b + c

## Использование абстрактных контейнеров

После создания наследующих контейнеров их можно использовать как обычные контейнеры:

// Создание экземпляров наследующих контейнеров
val circle = new Circle("MyCircle", 5.0, "red")
val rectangle = new Rectangle("MyRectangle", 4.0, 6.0, "blue")
val triangle = new Triangle("MyTriangle", 3.0, 4.0, 5.0, "green")

// Использование функций
println(circle.area()) // 78.54
println(circle.perimeter()) // 31.42
println(circle.describe()) // MyCircle with color red
println(circle.info()) // Shape: MyCircle, Area: 78.54, Perimeter: 31.42

println(rectangle.area()) // 24.0
println(rectangle.describe()) // Rectangle MyRectangle (4.0 x 6.0) with color blue

## Абстрактные контейнеры как типы

Абстрактный контейнер может использоваться как тип для значений, параметров функций и возвращаемых значений. Это обеспечивает **полиморфизм** — возможность работать с разными реализациями через общий набор функций и значений.

**Пример полиморфного использования:**

// Функция, работающая с любой фигурой
def printShapeInfo(shape: Shape): Unit =
println(s"Processing: ${shape.describe()}")
println(s"Area: ${shape.area()}")
println(s"Perimeter: ${shape.perimeter()}")

// Функция для сравнения площадей
def compareAreas(shape1: Shape, shape2: Shape): String =
val area1 = shape1.area()
val area2 = shape2.area()
if (area1 > area2) s"${shape1.name} больше ${shape2.name}"
else if (area1 < area2) s"${shape1.name} меньше ${shape2.name}"
else s"${shape1.name} равен ${shape2.name}"

// Использование
printShapeInfo(circle)
printShapeInfo(rectangle)
println(compareAreas(circle, rectangle))

## Абстрактные значения

Абстрактные контейнеры могут содержать не только функции без реализации, но и **значения без инициализации** (`val` без присвоения значения).

**Пример с значениями без инициализации:**

abstract class Vehicle(val model: String):
// Абстрактные значения
val maxSpeed: Int
val fuelType: String

// Абстрактная функция
def start(): String

// Конкретные функции
def info(): String =
s"$model (max speed: $maxSpeed km/h, fuel: $fuelType)"

def canExceedSpeedLimit(limit: Int): Boolean =
maxSpeed > limit

class Car(model: String, val maxSpeed: Int) extends Vehicle(model):
val fuelType: String = "gasoline"

override def start(): String =
"Engine started, ready to drive"

class ElectricCar(model: String, val maxSpeed: Int, val batteryCapacity: Int) extends Vehicle(model):
val fuelType: String = "electricity"

override def start(): String =
"Electric motor activated, silent start"

def chargingTime(): String =
s"Charging time: ${batteryCapacity / 10} hours"

## Применение абстрактных контейнеров

**1. Обеспечение общей структуры:** Гарантируют, что все наследники имеют определенный набор функций и значений.

**2. Переиспользование кода:** Общая функциональность реализуется один раз в абстрактном контейнере.

**3. Полиморфизм:** Возможность работать с разными реализациями через общий набор функций.

**4. Гибкость дизайна:** Баланс между обязательными требованиями и свободой реализации.

**5. Безопасность типов:** Компилятор проверяет, что все элементы без реализации реализованы.

Абстрактные контейнеры представляют собой мощный инструмент для создания иерархий контейнеров, обеспечивая структуру и переиспользование кода при сохранении гибкости реализации.

---

### Полные данные JSON

<details>
<summary>Показать JSON данные</summary>

```json
{
  "name" : "text",
  "text" : "<h1 style=\"text-align:center;\">Абстрактный контейнер функций</h1>\n\n<p><strong>Абстрактный контейнер функций</strong> — это контейнер, который содержит как конкретные функции с полной реализацией, так и <strong>абстрактные функции</strong>, не имеющие реализации. Абстрактный контейнер нельзя создать напрямую — сначала необходимо создать наследующий контейнер, который реализует все абстрактные функции.</p>\n\n<p>Абстрактные контейнеры служат <strong>шаблонами</strong> или <strong>каркасами</strong> для создания семейства совместимых контейнеров, обеспечивая общую структуру и частичную функциональность, которую наследники могут дополнить или переопределить.</p>\n\n<p><strong>Абстрактная функция</strong> — это объявление функции без её реализации. Она определяет <strong>сигнатуру</strong> (имя и параметры), но не содержит тела функции.</p>\n\n<h2 style=\"text-align:center;\">Определение абстрактного контейнера</h2>\n\n<p>Абстрактный контейнер определяется с помощью ключевого слова <code>abstract</code> перед <code>class</code>. Внутри такого контейнера могут находиться:</p>\n\n<ul>\n\t<li><strong>Конкретные функции</strong> с полной реализацией</li>\n\t<li><strong>Абстрактные функции</strong> без реализации</li>\n\t<li><strong>Значения</strong> (как конкретные, так и абстрактные)</li>\n</ul>\n\n<p><strong>Синтаксис определения абстрактного контейнера:</strong></p>\n\n<pre><code class=\"language-scala\">abstract class ContainerTypeName(params):\n  // Функции без реализации\n  def calculateResult(param: Type): ReturnType\n  \n  // Конкретные функции (с реализацией)\n  def processData(param: Type): ReturnType = \n    // реализация\n  \n  // Значения без инициализации\n  val configValue: Type\n  \n  // Конкретные значения\n  val defaultValue: Type = value</code></pre>\n\n<p><strong>Пример определения абстрактного контейнера:</strong></p>\n\n<pre><code class=\"language-scala\">// Абстрактный контейнер для работы с фигурами\nabstract class Shape(val name: String):\n  // Функции без реализации - должны быть реализованы наследниками\n  def area(): Double\n  def perimeter(): Double\n  \n  // Значение без инициализации\n  val color: String\n  \n  // Конкретные функции - уже реализованы\n  def describe(): String = \n    s\"$name with color $color\"\n  \n  def info(): String =\n    s\"Shape: $name, Area: ${area()}, Perimeter: ${perimeter()}\"\n  \n  // Конкретное значение\n  val dimension: Int = 2</code></pre>\n\n<h2 style=\"text-align:center;\">Создание наследующих контейнеров</h2>\n\n<p>Чтобы использовать абстрактный контейнер, необходимо создать наследующий контейнер, который <strong>реализует все элементы без реализации</strong>.</p>\n\n<p><strong>Пример реализации наследующих контейнеров:</strong></p>\n\n<pre><code class=\"language-scala\">// Наследующий контейнер - Круг\nclass Circle(name: String, val radius: Double, val color: String) extends Shape(name):\n  // Реализуем функции без реализации\n  override def area(): Double = \n    math.Pi * radius * radius\n  \n  override def perimeter(): Double = \n    2 * math.Pi * radius\n  \n  // Можем добавить дополнительные функции\n  def diameter(): Double = 2 * radius\n\n// Наследующий контейнер - Прямоугольник\nclass Rectangle(name: String, val width: Double, val height: Double, val color: String) extends Shape(name):\n  // Реализуем функции без реализации\n  override def area(): Double = \n    width * height\n  \n  override def perimeter(): Double = \n    2 * (width + height)\n  \n  // Можем переопределить конкретные функции родителя\n  override def describe(): String =\n    s\"Rectangle $name ($width x $height) with color $color\"\n\n// Наследующий контейнер - Треугольник\nclass Triangle(name: String, val a: Double, val b: Double, val c: Double, val color: String) extends Shape(name):\n  override def area(): Double = \n    val s = perimeter() / 2\n    math.sqrt(s * (s - a) * (s - b) * (s - c))\n  \n  override def perimeter(): Double = \n    a + b + c</code></pre>\n\n<h2 style=\"text-align:center;\">Использование абстрактных контейнеров</h2>\n\n<p>После создания наследующих контейнеров их можно использовать как обычные контейнеры:</p>\n\n<pre><code class=\"language-scala\">// Создание экземпляров наследующих контейнеров\nval circle = new Circle(\"MyCircle\", 5.0, \"red\")\nval rectangle = new Rectangle(\"MyRectangle\", 4.0, 6.0, \"blue\")\nval triangle = new Triangle(\"MyTriangle\", 3.0, 4.0, 5.0, \"green\")\n\n// Использование функций\nprintln(circle.area())        // 78.54\nprintln(circle.perimeter())   // 31.42\nprintln(circle.describe())    // MyCircle with color red\nprintln(circle.info())        // Shape: MyCircle, Area: 78.54, Perimeter: 31.42\n\nprintln(rectangle.area())     // 24.0\nprintln(rectangle.describe()) // Rectangle MyRectangle (4.0 x 6.0) with color blue</code></pre>\n\n<h2 style=\"text-align:center;\">Абстрактные контейнеры как типы</h2>\n\n<p>Абстрактный контейнер может использоваться как тип для значений, параметров функций и возвращаемых значений. Это обеспечивает <strong>полиморфизм</strong> — возможность работать с разными реализациями через общий набор функций и значений.</p>\n\n<p><strong>Пример полиморфного использования:</strong></p>\n\n<pre><code class=\"language-scala\">// Функция, работающая с любой фигурой\ndef printShapeInfo(shape: Shape): Unit = \n  println(s\"Processing: ${shape.describe()}\")\n  println(s\"Area: ${shape.area()}\")\n  println(s\"Perimeter: ${shape.perimeter()}\")\n\n// Функция для сравнения площадей\ndef compareAreas(shape1: Shape, shape2: Shape): String = \n  val area1 = shape1.area()\n  val area2 = shape2.area()\n  if (area1 &gt; area2) s\"${shape1.name} больше ${shape2.name}\"\n  else if (area1 &lt; area2) s\"${shape1.name} меньше ${shape2.name}\"\n  else s\"${shape1.name} равен ${shape2.name}\"\n\n// Использование\nprintShapeInfo(circle)\nprintShapeInfo(rectangle)\nprintln(compareAreas(circle, rectangle))</code></pre>\n\n<h2 style=\"text-align:center;\">Абстрактные значения</h2>\n\n<p>Абстрактные контейнеры могут содержать не только функции без реализации, но и <strong>значения без инициализации</strong> (<code>val</code> без присвоения значения).</p>\n\n<p><strong>Пример с значениями без инициализации:</strong></p>\n\n<pre><code class=\"language-scala\">abstract class Vehicle(val model: String):\n  // Абстрактные значения\n  val maxSpeed: Int\n  val fuelType: String\n  \n  // Абстрактная функция\n  def start(): String\n  \n  // Конкретные функции\n  def info(): String = \n    s\"$model (max speed: $maxSpeed km/h, fuel: $fuelType)\"\n  \n  def canExceedSpeedLimit(limit: Int): Boolean = \n    maxSpeed &gt; limit\n\nclass Car(model: String, val maxSpeed: Int) extends Vehicle(model):\n  val fuelType: String = \"gasoline\"\n  \n  override def start(): String = \n    \"Engine started, ready to drive\"\n\nclass ElectricCar(model: String, val maxSpeed: Int, val batteryCapacity: Int) extends Vehicle(model):\n  val fuelType: String = \"electricity\"\n  \n  override def start(): String = \n    \"Electric motor activated, silent start\"\n  \n  def chargingTime(): String = \n    s\"Charging time: ${batteryCapacity / 10} hours\"</code></pre>\n\n<h2 style=\"text-align:center;\">Применение абстрактных контейнеров</h2>\n\n<p><strong>1. Обеспечение общей структуры:</strong> Гарантируют, что все наследники имеют определенный набор функций и значений.</p>\n\n<p><strong>2. Переиспользование кода:</strong> Общая функциональность реализуется один раз в абстрактном контейнере.</p>\n\n<p><strong>3. Полиморфизм:</strong> Возможность работать с разными реализациями через общий набор функций.</p>\n\n<p><strong>4. Гибкость дизайна:</strong> Баланс между обязательными требованиями и свободой реализации.</p>\n\n<p><strong>5. Безопасность типов:</strong> Компилятор проверяет, что все элементы без реализации реализованы.</p>\n\n<p>Абстрактные контейнеры представляют собой мощный инструмент для создания иерархий контейнеров, обеспечивая структуру и переиспользование кода при сохранении гибкости реализации.</p>",
  "video" : null,
  "options" : {
    
  },
  "subtitle_files" : [
  ],
  "is_deprecated" : false
}
```

</details>
