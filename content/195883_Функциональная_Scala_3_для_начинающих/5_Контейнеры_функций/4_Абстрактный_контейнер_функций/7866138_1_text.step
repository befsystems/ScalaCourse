{
  "step_id" : 7866138,
  "lesson_id" : 1897512,
  "position" : 1,
  "type" : "unknown",
  "block" : {
    "name" : "text",
    "text" : "<h1 style=\"text-align:center;\">Абстрактный контейнер функций</h1>\n\n<p><strong>Абстрактный контейнер функций</strong> — это контейнер, который содержит как конкретные функции с полной реализацией, так и <strong>абстрактные функции</strong>, не имеющие реализации. Абстрактный контейнер нельзя создать напрямую — сначала необходимо создать наследующий контейнер, который реализует все абстрактные функции.</p>\n\n<p>Абстрактные контейнеры служат <strong>шаблонами</strong> или <strong>каркасами</strong> для создания семейства совместимых контейнеров, обеспечивая общую структуру и частичную функциональность, которую наследники могут дополнить или переопределить.</p>\n\n<p><strong>Абстрактная функция</strong> — это объявление функции без её реализации. Она определяет <strong>сигнатуру</strong> (имя и параметры), но не содержит тела функции.</p>\n\n<h2 style=\"text-align:center;\">Определение абстрактного контейнера</h2>\n\n<p>Абстрактный контейнер определяется с помощью ключевого слова <code>abstract</code> перед <code>class</code>. Внутри такого контейнера могут находиться:</p>\n\n<ul>\n\t<li><strong>Конкретные функции</strong> с полной реализацией</li>\n\t<li><strong>Абстрактные функции</strong> без реализации</li>\n\t<li><strong>Значения</strong> (как конкретные, так и абстрактные)</li>\n</ul>\n\n<p><strong>Синтаксис определения абстрактного контейнера:</strong></p>\n\n<pre><code class=\"language-scala\">abstract class ContainerTypeName(params):\n  // Функции без реализации\n  def calculateResult(param: Type): ReturnType\n  \n  // Конкретные функции (с реализацией)\n  def processData(param: Type): ReturnType = \n    // реализация\n  \n  // Значения без инициализации\n  val configValue: Type\n  \n  // Конкретные значения\n  val defaultValue: Type = value</code></pre>\n\n<p><strong>Пример определения абстрактного контейнера:</strong></p>\n\n<pre><code class=\"language-scala\">// Абстрактный контейнер для работы с фигурами\nabstract class Shape(val name: String):\n  // Функции без реализации - должны быть реализованы наследниками\n  def area(): Double\n  def perimeter(): Double\n  \n  // Значение без инициализации\n  val color: String\n  \n  // Конкретные функции - уже реализованы\n  def describe(): String = \n    s\"$name with color $color\"\n  \n  def info(): String =\n    s\"Shape: $name, Area: ${area()}, Perimeter: ${perimeter()}\"\n  \n  // Конкретное значение\n  val dimension: Int = 2</code></pre>\n\n<h2 style=\"text-align:center;\">Создание наследующих контейнеров</h2>\n\n<p>Чтобы использовать абстрактный контейнер, необходимо создать наследующий контейнер, который <strong>реализует все элементы без реализации</strong>.</p>\n\n<p><strong>Пример реализации наследующих контейнеров:</strong></p>\n\n<pre><code class=\"language-scala\">// Наследующий контейнер - Круг\nclass Circle(name: String, val radius: Double, val color: String) extends Shape(name):\n  // Реализуем функции без реализации\n  override def area(): Double = \n    math.Pi * radius * radius\n  \n  override def perimeter(): Double = \n    2 * math.Pi * radius\n  \n  // Можем добавить дополнительные функции\n  def diameter(): Double = 2 * radius\n\n// Наследующий контейнер - Прямоугольник\nclass Rectangle(name: String, val width: Double, val height: Double, val color: String) extends Shape(name):\n  // Реализуем функции без реализации\n  override def area(): Double = \n    width * height\n  \n  override def perimeter(): Double = \n    2 * (width + height)\n  \n  // Можем переопределить конкретные функции родителя\n  override def describe(): String =\n    s\"Rectangle $name ($width x $height) with color $color\"\n\n// Наследующий контейнер - Треугольник\nclass Triangle(name: String, val a: Double, val b: Double, val c: Double, val color: String) extends Shape(name):\n  override def area(): Double = \n    val s = perimeter() / 2\n    math.sqrt(s * (s - a) * (s - b) * (s - c))\n  \n  override def perimeter(): Double = \n    a + b + c</code></pre>\n\n<h2 style=\"text-align:center;\">Использование абстрактных контейнеров</h2>\n\n<p>После создания наследующих контейнеров их можно использовать как обычные контейнеры:</p>\n\n<pre><code class=\"language-scala\">// Создание экземпляров наследующих контейнеров\nval circle = new Circle(\"MyCircle\", 5.0, \"red\")\nval rectangle = new Rectangle(\"MyRectangle\", 4.0, 6.0, \"blue\")\nval triangle = new Triangle(\"MyTriangle\", 3.0, 4.0, 5.0, \"green\")\n\n// Использование функций\nprintln(circle.area())        // 78.54\nprintln(circle.perimeter())   // 31.42\nprintln(circle.describe())    // MyCircle with color red\nprintln(circle.info())        // Shape: MyCircle, Area: 78.54, Perimeter: 31.42\n\nprintln(rectangle.area())     // 24.0\nprintln(rectangle.describe()) // Rectangle MyRectangle (4.0 x 6.0) with color blue</code></pre>\n\n<h2 style=\"text-align:center;\">Абстрактные контейнеры как типы</h2>\n\n<p>Абстрактный контейнер может использоваться как тип для значений, параметров функций и возвращаемых значений. Это обеспечивает <strong>полиморфизм</strong> — возможность работать с разными реализациями через общий набор функций и значений.</p>\n\n<p><strong>Пример полиморфного использования:</strong></p>\n\n<pre><code class=\"language-scala\">// Функция, работающая с любой фигурой\ndef printShapeInfo(shape: Shape): Unit = \n  println(s\"Processing: ${shape.describe()}\")\n  println(s\"Area: ${shape.area()}\")\n  println(s\"Perimeter: ${shape.perimeter()}\")\n\n// Функция для сравнения площадей\ndef compareAreas(shape1: Shape, shape2: Shape): String = \n  val area1 = shape1.area()\n  val area2 = shape2.area()\n  if (area1 &gt; area2) s\"${shape1.name} больше ${shape2.name}\"\n  else if (area1 &lt; area2) s\"${shape1.name} меньше ${shape2.name}\"\n  else s\"${shape1.name} равен ${shape2.name}\"\n\n// Использование\nprintShapeInfo(circle)\nprintShapeInfo(rectangle)\nprintln(compareAreas(circle, rectangle))</code></pre>\n\n<h2 style=\"text-align:center;\">Абстрактные значения</h2>\n\n<p>Абстрактные контейнеры могут содержать не только функции без реализации, но и <strong>значения без инициализации</strong> (<code>val</code> без присвоения значения).</p>\n\n<p><strong>Пример с значениями без инициализации:</strong></p>\n\n<pre><code class=\"language-scala\">abstract class Vehicle(val model: String):\n  // Абстрактные значения\n  val maxSpeed: Int\n  val fuelType: String\n  \n  // Абстрактная функция\n  def start(): String\n  \n  // Конкретные функции\n  def info(): String = \n    s\"$model (max speed: $maxSpeed km/h, fuel: $fuelType)\"\n  \n  def canExceedSpeedLimit(limit: Int): Boolean = \n    maxSpeed &gt; limit\n\nclass Car(model: String, val maxSpeed: Int) extends Vehicle(model):\n  val fuelType: String = \"gasoline\"\n  \n  override def start(): String = \n    \"Engine started, ready to drive\"\n\nclass ElectricCar(model: String, val maxSpeed: Int, val batteryCapacity: Int) extends Vehicle(model):\n  val fuelType: String = \"electricity\"\n  \n  override def start(): String = \n    \"Electric motor activated, silent start\"\n  \n  def chargingTime(): String = \n    s\"Charging time: ${batteryCapacity / 10} hours\"</code></pre>\n\n<h2 style=\"text-align:center;\">Применение абстрактных контейнеров</h2>\n\n<p><strong>1. Обеспечение общей структуры:</strong> Гарантируют, что все наследники имеют определенный набор функций и значений.</p>\n\n<p><strong>2. Переиспользование кода:</strong> Общая функциональность реализуется один раз в абстрактном контейнере.</p>\n\n<p><strong>3. Полиморфизм:</strong> Возможность работать с разными реализациями через общий набор функций.</p>\n\n<p><strong>4. Гибкость дизайна:</strong> Баланс между обязательными требованиями и свободой реализации.</p>\n\n<p><strong>5. Безопасность типов:</strong> Компилятор проверяет, что все элементы без реализации реализованы.</p>\n\n<p>Абстрактные контейнеры представляют собой мощный инструмент для создания иерархий контейнеров, обеспечивая структуру и переиспользование кода при сохранении гибкости реализации.</p>",
    "video" : null,
    "options" : {
      
    },
    "subtitle_files" : [
    ],
    "is_deprecated" : false
  },
  "name" : "text",
  "course_id" : 195883,
  "course_name" : "Функциональная Scala 3 для начинающих",
  "exported_at" : "2025-12-20T22:21:39.9638197"
}