{
  "step_id" : 7923521,
  "lesson_id" : 1897512,
  "position" : 3,
  "type" : "unknown",
  "block" : {
    "name" : "text",
    "text" : "<h1 style=\"text-align:center;\">Интерфейс контейнера vs Абстрактный контейнер </h1>\n\n<p>Выбор между абстрактными контейнерами и trait-интерфейсами зависит от задач и архитектурных требований.</p>\n\n<h3>Используйте абстрактные контейнеры когда:</h3>\n\n<p><strong>1. Есть общая реализация:</strong> Когда несколько контейнеров должны разделять не только сигнатуры функций, но и их реализацию.</p>\n\n<pre><code class=\"language-scala\">abstract class Shape(val name: String):\n  def area(): Double  // Каждый наследник реализует по-своему\n  \n  // Общая реализация для всех фигур\n  def describe(): String = s\"Фигура $name с площадью ${area()}\"\n  def isLarge(): Boolean = area() &gt; 100</code></pre>\n\n<p><strong>2. Нужно состояние:</strong> Когда требуется общее состояние (параметры конструктора, общие значения).</p>\n\n<pre><code class=\"language-scala\">abstract class Vehicle(val brand: String, val year: Int):\n  val age: Int = 2024 - year  // Общее состояние\n  def start(): String  // Каждый тип запускается по-своему</code></pre>\n\n<p><strong>3. Строгая иерархия:</strong> Когда контейнеры образуют четкую иерархию \"является разновидностью\".</p>\n\n<pre><code class=\"language-scala\">abstract class Animal(val species: String)\nclass Dog(name: String) extends Animal(\"Canine\")  // Собака ЯВЛЯЕТСЯ животным</code></pre>\n\n<h3>Используйте trait-интерфейсы когда:</h3>\n\n<p><strong>1. Только описание возможностей:</strong> Когда нужно описать \"что может делать\", без предоставления реализации.</p>\n\n<pre><code class=\"language-scala\">trait Flyable:\n  def fly(): String\n  def land(): String\n\n// Разные контейнеры могут летать по-разному\nclass Bird extends Flyable:\n  def fly(): String = \"Машет крыльями\"\n\nclass Airplane extends Flyable:\n  def fly(): String = \"Включает двигатели\"</code></pre>\n\n<p><strong>2. Множественные возможности:</strong> Когда контейнер должен обладать несколькими независимыми способностями.</p>\n\n<pre><code class=\"language-scala\">trait Drawable:\n  def draw(): String\n\ntrait Saveable:\n  def save(): String\n\ntrait Printable:\n  def print(): String\n\n// Один контейнер может иметь много возможностей\nclass Document extends Drawable, Saveable, Printable:\n  def draw(): String = \"Отрисовка документа\"\n  def save(): String = \"Сохранение документа\"\n  def print(): String = \"Печать документа\"</code></pre>\n\n<p><strong>3. Добавление возможностей к существующим иерархиям:</strong> Когда нужно добавить новые возможности, не нарушая существующее наследование.</p>\n\n<pre><code class=\"language-scala\">// Уже есть иерархия контейнеров\nclass Car(brand: String)\nclass Truck(brand: String)\n\n// Добавляем новую возможность через интерфейс\ntrait GPS:\n  def navigate(): String\n\nclass SmartCar(brand: String) extends Car(brand), GPS:\n  def navigate(): String = \"GPS навигация включена\"</code></pre>\n\n<h3>Практические рекомендации:</h3>\n\n<p><strong>Используйте абстрактные контейнеры для:</strong></p>\n\n<ul>\n\t<li>Базовых сущностей предметной области (Shape, Vehicle, Animal)</li>\n\t<li>Случаев с общим кодом и состоянием</li>\n\t<li>Тесно связанных иерархий типов</li>\n</ul>\n\n<p><strong>Используйте trait-интерфейсы для:</strong></p>\n\n<ul>\n\t<li>Описания способностей и возможностей (Drawable, Flyable, Saveable)</li>\n\t<li>Ортогональной функциональности</li>\n\t<li>Композиции возможностей</li>\n</ul>\n\n<h3>Пример комбинированного использования:</h3>\n\n<pre><code class=\"language-scala\">// Абстрактный класс для общей структуры\nabstract class GameCharacter(val name: String, var health: Int):\n  def isAlive(): Boolean = health &gt; 0\n  def takeDamage(damage: Int): Unit = health -= damage\n  def attack(): String  // Каждый персонаж атакует по-своему\n\n// Интерфейсы для дополнительных возможностей\ntrait Magical:\n  def castSpell(): String\n\ntrait Stealthy:\n  def sneak(): String\n\ntrait Healing:\n  def heal(target: GameCharacter): Unit\n\n// Конкретные персонажи комбинируют базовую структуру и возможности\nclass Warrior(name: String) extends GameCharacter(name, 100):\n  def attack(): String = s\"$name атакует мечом\"\n\nclass Mage(name: String) extends GameCharacter(name, 80), Magical, Healing:\n  def attack(): String = s\"$name атакует заклинанием\"\n  def castSpell(): String = s\"$name читает заклинание\"\n  def heal(target: GameCharacter): Unit = target.health += 20\n\nclass Rogue(name: String) extends GameCharacter(name, 90), Stealthy:\n  def attack(): String = s\"$name атакует из тени\"\n  def sneak(): String = s\"$name скрывается в тенях\"</code></pre>\n\n<p><strong>Главное правило:</strong> Абстрактные контейнеры для \"является разновидностью\", trait-интерфейсы для \"может делать\".</p>",
    "video" : null,
    "options" : {
      
    },
    "subtitle_files" : [
    ],
    "is_deprecated" : false
  },
  "name" : "text",
  "course_id" : 195883,
  "course_name" : "Функциональная Scala 3 для начинающих",
  "exported_at" : "2025-12-20T22:21:39.9801785"
}