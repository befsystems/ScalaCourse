# Материал (Шаг 3)

## Информация о шаге

- **ID шага**: 7923521
- **Позиция**: 3
- **Тип**: text
- **Курс**: Функциональная Scala 3 для начинающих
- **Экспортирован**: 2026-01-10T10:17:35.1194506

## Содержание

# Интерфейс контейнера vs Абстрактный контейнер 

Выбор между абстрактными контейнерами и trait-интерфейсами зависит от задач и архитектурных требований.

### Используйте абстрактные контейнеры когда:

**1. Есть общая реализация:** Когда несколько контейнеров должны разделять не только сигнатуры функций, но и их реализацию.

abstract class Shape(val name: String):
def area(): Double // Каждый наследник реализует по-своему

// Общая реализация для всех фигур
def describe(): String = s"Фигура $name с площадью ${area()}"
def isLarge(): Boolean = area() > 100

**2. Нужно состояние:** Когда требуется общее состояние (параметры конструктора, общие значения).

abstract class Vehicle(val brand: String, val year: Int):
val age: Int = 2024 - year // Общее состояние
def start(): String // Каждый тип запускается по-своему

**3. Строгая иерархия:** Когда контейнеры образуют четкую иерархию "является разновидностью".

abstract class Animal(val species: String)
class Dog(name: String) extends Animal("Canine") // Собака ЯВЛЯЕТСЯ животным

### Используйте trait-интерфейсы когда:

**1. Только описание возможностей:** Когда нужно описать "что может делать", без предоставления реализации.

trait Flyable:
def fly(): String
def land(): String

// Разные контейнеры могут летать по-разному
class Bird extends Flyable:
def fly(): String = "Машет крыльями"

class Airplane extends Flyable:
def fly(): String = "Включает двигатели"

**2. Множественные возможности:** Когда контейнер должен обладать несколькими независимыми способностями.

trait Drawable:
def draw(): String

trait Saveable:
def save(): String

trait Printable:
def print(): String

// Один контейнер может иметь много возможностей
class Document extends Drawable, Saveable, Printable:
def draw(): String = "Отрисовка документа"
def save(): String = "Сохранение документа"
def print(): String = "Печать документа"

**3. Добавление возможностей к существующим иерархиям:** Когда нужно добавить новые возможности, не нарушая существующее наследование.

// Уже есть иерархия контейнеров
class Car(brand: String)
class Truck(brand: String)

// Добавляем новую возможность через интерфейс
trait GPS:
def navigate(): String

class SmartCar(brand: String) extends Car(brand), GPS:
def navigate(): String = "GPS навигация включена"

### Практические рекомендации:

**Используйте абстрактные контейнеры для:**

- Базовых сущностей предметной области (Shape, Vehicle, Animal)

- Случаев с общим кодом и состоянием

- Тесно связанных иерархий типов

**Используйте trait-интерфейсы для:**

- Описания способностей и возможностей (Drawable, Flyable, Saveable)

- Ортогональной функциональности

- Композиции возможностей

### Пример комбинированного использования:

// Абстрактный класс для общей структуры
abstract class GameCharacter(val name: String, var health: Int):
def isAlive(): Boolean = health > 0
def takeDamage(damage: Int): Unit = health -= damage
def attack(): String // Каждый персонаж атакует по-своему

// Интерфейсы для дополнительных возможностей
trait Magical:
def castSpell(): String

trait Stealthy:
def sneak(): String

trait Healing:
def heal(target: GameCharacter): Unit

// Конкретные персонажи комбинируют базовую структуру и возможности
class Warrior(name: String) extends GameCharacter(name, 100):
def attack(): String = s"$name атакует мечом"

class Mage(name: String) extends GameCharacter(name, 80), Magical, Healing:
def attack(): String = s"$name атакует заклинанием"
def castSpell(): String = s"$name читает заклинание"
def heal(target: GameCharacter): Unit = target.health += 20

class Rogue(name: String) extends GameCharacter(name, 90), Stealthy:
def attack(): String = s"$name атакует из тени"
def sneak(): String = s"$name скрывается в тенях"

**Главное правило:** Абстрактные контейнеры для "является разновидностью", trait-интерфейсы для "может делать".

---

### Полные данные JSON

<details>
<summary>Показать JSON данные</summary>

```json
{
  "name" : "text",
  "text" : "<h1 style=\"text-align:center;\">Интерфейс контейнера vs Абстрактный контейнер </h1>\n\n<p>Выбор между абстрактными контейнерами и trait-интерфейсами зависит от задач и архитектурных требований.</p>\n\n<h3>Используйте абстрактные контейнеры когда:</h3>\n\n<p><strong>1. Есть общая реализация:</strong> Когда несколько контейнеров должны разделять не только сигнатуры функций, но и их реализацию.</p>\n\n<pre><code class=\"language-scala\">abstract class Shape(val name: String):\n  def area(): Double  // Каждый наследник реализует по-своему\n  \n  // Общая реализация для всех фигур\n  def describe(): String = s\"Фигура $name с площадью ${area()}\"\n  def isLarge(): Boolean = area() &gt; 100</code></pre>\n\n<p><strong>2. Нужно состояние:</strong> Когда требуется общее состояние (параметры конструктора, общие значения).</p>\n\n<pre><code class=\"language-scala\">abstract class Vehicle(val brand: String, val year: Int):\n  val age: Int = 2024 - year  // Общее состояние\n  def start(): String  // Каждый тип запускается по-своему</code></pre>\n\n<p><strong>3. Строгая иерархия:</strong> Когда контейнеры образуют четкую иерархию \"является разновидностью\".</p>\n\n<pre><code class=\"language-scala\">abstract class Animal(val species: String)\nclass Dog(name: String) extends Animal(\"Canine\")  // Собака ЯВЛЯЕТСЯ животным</code></pre>\n\n<h3>Используйте trait-интерфейсы когда:</h3>\n\n<p><strong>1. Только описание возможностей:</strong> Когда нужно описать \"что может делать\", без предоставления реализации.</p>\n\n<pre><code class=\"language-scala\">trait Flyable:\n  def fly(): String\n  def land(): String\n\n// Разные контейнеры могут летать по-разному\nclass Bird extends Flyable:\n  def fly(): String = \"Машет крыльями\"\n\nclass Airplane extends Flyable:\n  def fly(): String = \"Включает двигатели\"</code></pre>\n\n<p><strong>2. Множественные возможности:</strong> Когда контейнер должен обладать несколькими независимыми способностями.</p>\n\n<pre><code class=\"language-scala\">trait Drawable:\n  def draw(): String\n\ntrait Saveable:\n  def save(): String\n\ntrait Printable:\n  def print(): String\n\n// Один контейнер может иметь много возможностей\nclass Document extends Drawable, Saveable, Printable:\n  def draw(): String = \"Отрисовка документа\"\n  def save(): String = \"Сохранение документа\"\n  def print(): String = \"Печать документа\"</code></pre>\n\n<p><strong>3. Добавление возможностей к существующим иерархиям:</strong> Когда нужно добавить новые возможности, не нарушая существующее наследование.</p>\n\n<pre><code class=\"language-scala\">// Уже есть иерархия контейнеров\nclass Car(brand: String)\nclass Truck(brand: String)\n\n// Добавляем новую возможность через интерфейс\ntrait GPS:\n  def navigate(): String\n\nclass SmartCar(brand: String) extends Car(brand), GPS:\n  def navigate(): String = \"GPS навигация включена\"</code></pre>\n\n<h3>Практические рекомендации:</h3>\n\n<p><strong>Используйте абстрактные контейнеры для:</strong></p>\n\n<ul>\n\t<li>Базовых сущностей предметной области (Shape, Vehicle, Animal)</li>\n\t<li>Случаев с общим кодом и состоянием</li>\n\t<li>Тесно связанных иерархий типов</li>\n</ul>\n\n<p><strong>Используйте trait-интерфейсы для:</strong></p>\n\n<ul>\n\t<li>Описания способностей и возможностей (Drawable, Flyable, Saveable)</li>\n\t<li>Ортогональной функциональности</li>\n\t<li>Композиции возможностей</li>\n</ul>\n\n<h3>Пример комбинированного использования:</h3>\n\n<pre><code class=\"language-scala\">// Абстрактный класс для общей структуры\nabstract class GameCharacter(val name: String, var health: Int):\n  def isAlive(): Boolean = health &gt; 0\n  def takeDamage(damage: Int): Unit = health -= damage\n  def attack(): String  // Каждый персонаж атакует по-своему\n\n// Интерфейсы для дополнительных возможностей\ntrait Magical:\n  def castSpell(): String\n\ntrait Stealthy:\n  def sneak(): String\n\ntrait Healing:\n  def heal(target: GameCharacter): Unit\n\n// Конкретные персонажи комбинируют базовую структуру и возможности\nclass Warrior(name: String) extends GameCharacter(name, 100):\n  def attack(): String = s\"$name атакует мечом\"\n\nclass Mage(name: String) extends GameCharacter(name, 80), Magical, Healing:\n  def attack(): String = s\"$name атакует заклинанием\"\n  def castSpell(): String = s\"$name читает заклинание\"\n  def heal(target: GameCharacter): Unit = target.health += 20\n\nclass Rogue(name: String) extends GameCharacter(name, 90), Stealthy:\n  def attack(): String = s\"$name атакует из тени\"\n  def sneak(): String = s\"$name скрывается в тенях\"</code></pre>\n\n<p><strong>Главное правило:</strong> Абстрактные контейнеры для \"является разновидностью\", trait-интерфейсы для \"может делать\".</p>",
  "video" : null,
  "options" : {
    
  },
  "subtitle_files" : [
  ],
  "is_deprecated" : false
}
```

</details>
