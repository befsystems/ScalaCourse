{
  "step_id" : 5763653,
  "lesson_id" : 1301870,
  "position" : 4,
  "type" : "unknown",
  "block" : {
    "name" : "text",
    "text" : "<h1 style=\"text-align: center;\">Конструкция PartialFunction</h1>\n\n<p>В языке Scala присутствует конструкция называемая как <strong>PartialFunction </strong>(частичная функция). Несмотря на название, она имеет более широкие возможности, чем просто создание частично определенных функции. К тому же, тотальные функции на данной конструкции получаются не хуже, чем частичные функции.</p>\n\n<p>Конструкция PartialFunction <strong>полностью совместима по функциональному типу</strong> с анонимной функцией, и может заменять её во всех смыслах. Более того, иногда она оказывается много удобнее и мощнее, чем анонимная функция.</p>\n\n<p>Единственное ограничение, что PartialFunction имеет только <strong>единственный входной параметр</strong>, то есть может создавать только <strong>унарные </strong>функции. Но многие функции высшего порядка, как раз и используют унарные лямда-функции. Также, ограничение в один параметр можно легко обойти используя <strong>кортеж</strong>.</p>\n\n<p>Анонимная функция, как известно, задается функциональным выражением, PartialFunction же создается <strong>набором</strong> функциональных выражений, которые называются <strong>альтернативными функциональными выражениями</strong>, и они все начинаются с ключевого слова <strong><code>case</code></strong>.</p>\n\n<p>Пример создания PartialFunction c одним альтернативным функциональным выражением:</p>\n\n<pre><code class=\"language-scala\">val fun: PartialFunction[Int, Int] =   // тип PartialFunction для функционального типа Int =&gt; Int\n  case x =&gt; x + 1      // одно альтернативное функциональное выражение</code></pre>\n\n<p>Если сравнить с созданием анонимной функцией:</p>\n\n<pre><code class=\"language-scala\">val fun2: Int =&gt; Int =   // функциональный тип Int =&gt; Int\n  x =&gt; x + 1            // функциональное выражение</code></pre>\n\n<p>то видим дополнительное ключевое слово <strong><code>case</code></strong>перед объявлением параметра.</p>\n\n<p>Совместимость PartialFunction с анонимной функцией можно показать приведением типа PartialFunction к функциональному типу:</p>\n\n<pre><code class=\"language-scala\">val fun: Int =&gt; Int =   // функциональный тип Int =&gt; Int получает тип PartialFunction (приведение типов)\n  case x =&gt; x + 1      // одно альтернативное функциональное выражение</code></pre>\n\n<p>Учтите, что после приведения типа PartialFunction к функциональному типу, операции типа PartialFunction будут уже не доступны.</p>\n\n<p>Также можно видеть совместимость типов при использовании функций:</p>\n\n<pre><code class=\"language-scala\">\"abc\".map(      char =&gt; char + 1 ) // используется функциональное выражение (анонимная функция)\n\"abc\".map{ case char =&gt; char + 1 } // используется альтернативное функциональное выражение (PartialFunction)\n// Результаты полностью одинаковые</code></pre>\n\n<p>Все альтернативы могут находится только в блоке выражений, поэтому используем <strong>фигурные </strong>скобки вместо круглых, где это необходимо.</p>\n\n<p>Альтернативных выражений может быть <strong>несколько</strong> в одной конструкции PartialFunction.</p>\n\n<p>Пример:</p>\n\n<pre><code class=\"language-scala\">val fun: PartialFunction[Int, Int] =           // функциональный тип Int =&gt; Int\n  case x if x &gt; 0 =&gt; x + 1      // одно альтернативное функциональное выражение\n  case x =&gt; x - 1               // второе альтернативное функциональное выражение</code></pre>\n\n<p>Выбор, какое выражение будет использовано, производиться <strong>последовательно сверху вниз</strong>, перебором условий и ограничений для параметра выражений. В данном примере, в первой альтернативе используется конструкция <strong><code>if</code></strong> для проверки значения параметра выражения. Если проверка положительная, то используется первое альтернативное выражение, второе пропускается. Если проверка отрицательная, первая альтернатива пропускается, и используется второе выражение безусловно, так как у него нет проверок.</p>\n\n<p>Количество альтернатив <strong>не ограничено</strong>.</p>\n\n<p>Пример с тремя альтернативными выражениями:</p>\n\n<pre><code class=\"language-scala\">val fun: PartialFunction[Int, Int] =        // функциональный тип Int =&gt; Int\n  case x if x == 0 =&gt; x      // одно альтернативное функциональное выражение\n  case x if x &gt; 0 =&gt; x + 1   // второе альтернативное функциональное выражение\n  case x =&gt; x - 1            // третье альтернативное функциональное выражение</code></pre>\n\n<p>Полнота и логичность проверок полностью <strong>определяется программистом</strong>. Компилятор не запретит абсурдных или повторных проверок в последовательности. Возможно будут некоторые предупреждения от компилятора, при совсем явных ошибках.</p>\n\n<p>Можно заметить, что все созданные ранее функции <strong>тотальные</strong>, то есть присутствуют подходящие выражения для всего спектра входных значений.</p>\n\n<p>Но можно легко сделать и частично определенную функцию.</p>\n\n<p>Пример:</p>\n\n<pre><code class=\"language-scala\">val fun: PartialFunction[Int, Int] =        // функциональный тип Int =&gt; Int\n  case x if x == 0 =&gt; x      // одно альтернативное функциональное выражение\n  case x if x &gt; 0 =&gt; x + 1   // второе альтернативное функциональное выражение\n</code></pre>\n\n<p>Убрали третью альтернативу, и значения меньше нуля не могут быть обработаны. Функция выдаст ошибку на такие значения.</p>\n\n<h2 style=\"text-align: center;\"><br>\nОперация isDefinedAt&nbsp;</h2>\n\n<p>Операция <strong>isDefinedAt </strong>для функции типа&nbsp;PartialFunction производит проверку на доступность обработки аргумента данной функцией, еще до этапа вызова функции с этим аргументом.</p>\n\n<p>Пример:</p>\n\n<pre><code class=\"language-scala\">val fun: PartialFunction[Int, Int] =           // функциональный тип Int =&gt; Int\n  case x if x &gt; 0 =&gt; x + 1      // альтернативное функциональное выражение\n\nval res = fun.isDefinedAt(1) // результат true\n\n​val res = fun(1) // результат 2\n\nval res2 = fun.isDefinedAt(0) // результат false\n\n​val res3 = fun(0) // результат - ошибка при выполнении</code></pre>\n\n<p>Если функция является тотальной, то <strong>isDefinedAt </strong>для любого аргумента будет возвращать true.</p>\n\n<p>Данная операция в основном используется компилятором при композиции нескольких таких функций, но можно её использовать и при конвертации частичной функции в тотальную.</p>\n\n<p>Пример:</p>\n\n<pre><code class=\"language-scala\">val fun: PartialFunction[Int, Int] =     // существующая частичная функция\n  case x if x &gt; 0 =&gt; x + 1               \n\ndef totalFun(x: Int): Int =  // новая тотальная функция\n  if fun.isDefinedAt(x) then // проверка аргумента на допустимость\n    fun(x)                   // для допустимого аргумента используем частичную функцию\n  else\n    0                        // для недопустимого аргумента отдаем специальное значение 0</code></pre>",
    "video" : null,
    "options" : {
      
    },
    "subtitle_files" : [
    ],
    "is_deprecated" : false
  },
  "name" : "text",
  "course_id" : 195883,
  "course_name" : "Функциональная Scala 3 для начинающих",
  "exported_at" : "2026-01-10T10:17:21.7922954"
}