{
  "step_id" : 5808625,
  "lesson_id" : 1301870,
  "position" : 9,
  "type" : "unknown",
  "block" : {
    "name" : "text",
    "text" : "<h1 style=\"text-align:center;\">Композиция и объединение функций типа PartialFunction</h1>\n\n<p>Композиция функций — это процесс объединения двух функций таким образом, чтобы результат одной функции передавался как вход другой функции. В случае с PartialFunction также дополнительно учитываются&nbsp;области определения обеих функций,что позволяет строить логически сложные композиции.</p>\n\n<h2 style=\"text-align:center;\">Операция <code>andThen</code></h2>\n\n<ul>\n\t<li>Композиция двух PartialFunction с помощью <strong><code>andThen</code></strong> приводит к созданию новой PartialFunction.</li>\n\t<li>Операция <code>isDefinedAt</code> новой функции проверяет, определена ли первая функция на заданном значении, и затем проверяет, определена ли вторая функция на результате первой.</li>\n</ul>\n\n<p>Таким образом в результате получаем полноценную новую PartialFunction функцию с корректной общей операцией <code>isDefinedAt.</code>Новая функция будет определена только на тех значениях, где определена первая функция, и результат первой функции лежит в области определения второй функции. Это похоже на оператор логического \"И\" для областей определения функций.</p>\n\n<p>Пример композиции функций:</p>\n\n<pre><code class=\"language-scala\">val doubling: PartialFunction[Int, Int] = \n  case x if x % 2 == 0 =&gt; x * 2           // удваивание только четных чисел\n\n\nval addThree: PartialFunction[Int, Int] = \n  case x if x &gt; 0 =&gt; x + 3                // добавление 3 к только положительным числам\n\n\nval composedFunction = doubling andThen addThree\n\n\nprintln(composedFunction.isDefinedAt(2))  // true\nprintln(composedFunction.isDefinedAt(1))  // false</code></pre>\n\n<p>Для <code>2</code>:<code>doubling.isDefinedAt(2)</code> вернет <code>true</code> (так как 2 четное), результат будет <code>4</code>. Затем <code>addThree.isDefinedAt(4)</code> вернет <code>true</code> (так как 4 &gt; 0). В результате <code>true &amp; true = true.</code></p>\n\n<p>Для <code>1</code>: <code>doubling.isDefinedAt(1)</code> вернет <code>false</code> (так как 1 нечетное), поэтому <code>composedFunction.isDefinedAt(1)</code> вернет <code>false</code>.</p>\n\n<p>&nbsp;</p>\n\n<p>Цепочка операций <code>andThen </code>может быть сколь угодно длинной. Область определения итоговой функции будет при этом будет уменьшаться или остаться постоянной, по сравнению со всеми входящими в композицию функциями.</p>\n\n<pre><code class=\"language-scala\">val composedFunction = fun1 andThen fun2 andThen fun3 andThen fun4</code></pre>\n\n<p>Позиция функции в цепочке <strong>влияет </strong>на результат.</p>\n\n<h2 style=\"text-align:center;\">Операция orElse</h2>\n\n<p>Операция<strong><code>orElse</code></strong> объединяет две <code>PartialFunction</code> таким образом, что если первая функция не определена для заданного значения, то будет использована вторая функция, если она определена для заданного значения. Это похоже на оператор логического \"ИЛИ\" для областей определения функций. Операция <code>orElse</code> не является композицией функций, а логическим объединением функций. Использование <code>orElse</code> позволяет создать функцию, которая определена на большем множестве значений, чем каждая из функций по отдельности.</p>\n\n<p>Пример:</p>\n\n<pre><code class=\"language-scala\">val combinedFunction = partialFunction1 orElse partialFunction2</code></pre>\n\n<p>Сначала пытаемся применить <code>partialFunction1</code>. Если она не определена для данного входа, то применяется <code>partialFunction2</code>.</p>\n\n<p>Еще пример:</p>\n\n<pre><code class=\"language-scala\">val evenNumbers: PartialFunction[Int, String] = {\n  case x if x % 2 == 0 =&gt; s\"$x is even\"\n}\n\nval oddNumbers: PartialFunction[Int, String] = {\n  case x if x % 2 != 0 =&gt; s\"$x is odd\"\n}\n\nval numbersDescription = evenNumbers orElse oddNumbers  // объединение функций\n\n// Использование\nprintln(numbersDescription(2))  // Output: \"2 is even\"\nprintln(numbersDescription(3))  // Output: \"3 is odd\"\n\n// Область определения\nprintln(numbersDescription.isDefinedAt(2))  // true\nprintln(numbersDescription.isDefinedAt(3))  // true</code></pre>\n\n<p>Цепочка операций <strong><code>orElse</code></strong>может быть сколь угодно длинной. Область определения итоговой функции будет при этом будет увеличиваться или остаться постоянной, по сравнению со всеми входящими в композицию функциями.</p>\n\n<pre><code class=\"language-scala\">val combinedFunction = fun1 orElse fun2 orElse fun3 orElse fun4</code></pre>\n\n<p>Позиция функции в цепочке <strong>влияет </strong>на результат.</p>\n\n<h2 style=\"text-align:center;\">Сравнение <code>orElse</code> и <code>andThen</code></h2>\n\n<h3><code>andThen</code></h3>\n\n<ul>\n\t<li><strong>Композиция</strong>: Результат первой функции передается как вход во вторую функцию.</li>\n\t<li><strong>Область определения</strong>: Новая функция определена только на тех значениях, где первая функция определена, и результат первой функции лежит в области определения второй функции.</li>\n\t<li><strong>Порядок функций</strong>: Важен, так как результат первой функции влияет на возможность применения второй функции.</li>\n</ul>\n\n<h3><code>orElse</code></h3>\n\n<ul>\n\t<li><strong>Объединение</strong>: Если первая функция не определена для данного входа, используется вторая функция.</li>\n\t<li><strong>Область определения</strong>: Новая функция определена на объединении областей определения обеих функций.</li>\n\t<li><strong>Порядок функций</strong>: Важен, так как первая функция имеет приоритет при определении результата для входных значений, где обе функции определены.</li>\n</ul>",
    "video" : null,
    "options" : {
      
    },
    "subtitle_files" : [
    ],
    "is_deprecated" : false
  },
  "name" : "text",
  "course_id" : 195883,
  "course_name" : "Функциональная Scala 3 для начинающих",
  "exported_at" : "2026-01-10T10:17:21.7987435"
}