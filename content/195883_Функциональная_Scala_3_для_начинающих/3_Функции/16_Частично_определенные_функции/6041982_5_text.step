{
  "step_id" : 6041982,
  "lesson_id" : 1301870,
  "position" : 5,
  "type" : "unknown",
  "block" : {
    "name" : "text",
    "text" : "<h2 style=\"text-align:center;\">Табличная функция на PartialFunction</h2>\n\n<p>На основе PartialFunction легко задать <strong>табличную функцию</strong>.</p>\n\n<p>Пример:</p>\n\n<pre><code class=\"language-scala\">val fun: PartialFunction[Int, Char] =        // функциональный тип Int =&gt; Char\n  case 1 =&gt; 'a'      // первое альтернативное функциональное выражение\n  case 2 =&gt; 'b'      // второе альтернативное функциональное выражение\n  case 3 =&gt; 'c'      // третье альтернативное функциональное выражение\n  case _ =&gt; 'x'      // четвертое альтернативное функциональное выражение</code></pre>\n\n<p>Здесь используется неявное сравнение входного значения со образцом-числом. Писать <strong><code>if</code></strong>для этого ненужно. Входное значение в функции является ключом для получения нужного символа.</p>\n\n<p>Обратите внимание, что создана <strong>тотальная функция</strong>. Проверка в четвертом выражении, использует универсальный&nbsp; постановочный символ, который подходит для всех значений типа Int. Будут обработаны все значения, которые не смогли обработать более ранние выражения.</p>\n\n<p>Также можно использовать&nbsp; различные виды альтернатив одновременно в одной конструкции PartialFunction.</p>\n\n<p>Пример:</p>\n\n<pre><code class=\"language-scala\">val fun: PartialFunction[Int, Char] =        // функциональный тип Int =&gt; Char\n  case 1 =&gt; 'a'               // первое альтернативное функциональное выражение\n  case x if x &gt; 2 =&gt; 'b'      // второе альтернативное функциональное выражение\n  case _ =&gt; 'x'               // третье альтернативное функциональное выражение</code></pre>\n\n<p>Все выше перечисленные приемы легко реализуются на условных конструкциях и в обычных функциях. Однако, альтернативы это не только конструкция <strong><code>if</code></strong>, но и сложные декомпозиции структур данных, которых мы коснемся в других уроках. Они позволяют&nbsp; удобно заглянуть внутрь структур и определить подходящую альтернативу для их обработки. К сожалению декомпозиция невозможна для строк и примитивных типов.&nbsp;</p>",
    "video" : null,
    "options" : {
      
    },
    "subtitle_files" : [
    ],
    "is_deprecated" : false
  },
  "name" : "text",
  "course_id" : 195883,
  "course_name" : "Функциональная Scala 3 для начинающих",
  "exported_at" : "2025-12-20T22:21:25.0404993"
}