# Материал (Шаг 1)

## Информация о шаге

- **ID шага**: 5397526
- **Позиция**: 1
- **Тип**: text
- **Курс**: Функциональная Scala 3 для начинающих
- **Экспортирован**: 2025-12-20T22:21:25.0256189

## Содержание

# Частично определенная функция

**Частичная определенная функция** (частичная функция) — это функция, которая **не в состоянии** просчитать выходной результат **для всех** возможных входных значений, которые ему могут быть заданы. Он дает ответ **только для части** (подмножества) возможных значений, которые он **может** обрабатывать. Для остальных входных значений функция возвращает **ошибку**.

Частичная функция противоположна по смыслу **тотальной функции**, которая может обработать **все входные значения**, без исключений.

Любая функция любого вида, созданная в языке Scala, может быть или **тотальной **или **частичной**. Это зависит и от **типа данных** и от** алгоритма** вычисления выходного значения. Компилятор, в большинстве случаев, не выдаст предупреждений о использовании частичной функции. И без дополнительных описаний трудно заметить её частичность, но некоторые входные значения могут привести к ошибке вычислений.

Пример частичной функции:

`def div(a: Int, b: Int): Int = a / b`

Эта функция является частичной, так как использует операцию целочисленного деления, которая не может работать с нулевым делителем и при этом выдает ошибку.

Создание и использование частичных функций нежелательно, так как это мешает работать в функциональном стиле. Также, частичные функции не являются **чистыми**, и не могут иметь полезные свойства чистых функций.

Нередкая причина использования частичных функций, это большие затраты на перевод простой и дешевой частичной функции в более сложную и дорогую тотальную функцию. Всегда существует компромисс между правильностью и затратами.

Можно переделать выше приведенный пример, превратив частичную функцию в тотальную, но ценой введения больших граничных погрешностей вычислений:

def div(a: Int, b: Int): Int =
if b == 0 then
if a == 0 then
0 // имитация неопределенности
else
if a < 0 then
Int.MinValue // имитация минус бесконечности
else
Int.MaxValue // имитация плюс бесконечности
else
a / b

Функция получилась тотальной, без выдачи ошибок на нулевой делитель, но с большими допущениями.

Теперь, если вы подумаете об этом, вы можете заметить множество подобных ситуаций в реальных программах, когда неявно ожидается, что функции будут работать правильно только для некоторых входных значений. Частичные функции очень распространены, и мало кто на это обращает внимание. Как минимум, такие функции должны быть обернуты проверками для своих входных аргументов.

Хорошим решением является использование в параметрах функции более подходящих для вычислений типов данных, в которых просто нет проблемных значений. В таком случае, частичная функция превращается в тотальную.

Также можно возвращать специальные значения типа, для случаев, когда вычисление невозможно. Например в типе Double есть специальное значение NaN.

## Табличная функция

Особый вид частичной функции, это **табличная функция**. Если в обычной частичной функции невозможно обработать только небольшую часть значений типа, то в табличной функции только небольшую часть значений типа обработать **можно**, и эти значения заданы явно, отдельно друг от друга, как бы перечислены в таблице возможных значений (таблица соответствий).

Таблицами значений можно представить многие **коллекции **в Scala, и табличные функции получения элементов коллекций довольно часто используются, несмотря на их частичность в определении значений.

`val res = "abc" apply 0 // Получение символа 'a'`

Например строка, это коллекция символов. По существу, это таблица значений. Если принять, что индекс символа - это входной аргумент, а символ, связанный с этим индексом является значением, то операция получения символа подпадает под определение табличной функции. B случае отсутствия значения для индекса, будет ошибка при вызове функции.

`val res = "abc" apply 3 // ошибка, нет значения для указанного аргумента`

Обратите внимание, что функции получения элементов часто бывают неявными, как например функция **apply**, что означает, что явно они не указываются, но выполняют свою операцию**.**

val res = "abc".apply(0) // Получение символа 'a'
val res = "abc"(0) // аналог в другой форме записи, неявный apply

Пример дешифратора текста, с использованием строки как функции-дешифратора:

val res = "213340" // исходный текст
.map(_.toString.toInt) // преобразование каждого символа в индекс-число от 0 до 4
.map("!eHlo") // сопостовление каждого индекса с новым символом из строки-ключа, операция доступа к символу скрыта
.mkString // создание новой строки из коллекции новых символов

В результате получим слово "Hello!"

Кроме табличных, частичных функций получения элементов, есть и тотальные функции, которые используют сложные типы выходных результатов. Их рекомендуется использовать при функциональном стиле.

---

### Полные данные JSON

<details>
<summary>Показать JSON данные</summary>

```json
{
  "name" : "text",
  "text" : "<h1 style=\"text-align:center;\">Частично определенная функция</h1>\n\n<p><strong>Частичная определенная функция</strong> (частичная функция) — это функция, которая <strong>не в состоянии</strong> просчитать выходной результат <strong>для всех</strong> возможных входных значений, которые ему могут быть заданы. Он дает ответ <strong>только для части</strong> (подмножества) возможных значений, которые он <strong>может</strong> обрабатывать. Для остальных входных значений функция возвращает <strong>ошибку</strong>.</p>\n\n<p>Частичная функция противоположна по смыслу <strong>тотальной функции</strong>, которая может обработать <strong>все входные значения</strong>, без исключений.</p>\n\n<p>Любая функция любого вида, созданная в языке Scala, может быть или <strong>тотальной </strong>или <strong>частичной</strong>. Это зависит и от <strong>типа данных</strong> и от<strong> алгоритма</strong> вычисления выходного значения. Компилятор, в большинстве случаев, не выдаст предупреждений о использовании частичной функции. И без дополнительных описаний трудно заметить её частичность, но некоторые входные значения могут привести к ошибке вычислений.</p>\n\n<p>Пример частичной функции:</p>\n\n<pre><code class=\"language-scala\">def div(a: Int, b: Int): Int = a / b</code></pre>\n\n<p>Эта функция является частичной, так как использует операцию целочисленного деления, которая не может работать с нулевым делителем и при этом выдает ошибку.</p>\n\n<p>Создание и использование частичных функций нежелательно, так как это мешает работать в функциональном стиле. Также, частичные функции не являются <strong>чистыми</strong>, и не могут иметь полезные свойства чистых функций.</p>\n\n<p>Нередкая причина использования частичных функций, это большие затраты на перевод простой и дешевой частичной функции в более сложную и дорогую тотальную функцию. Всегда существует компромисс между правильностью и затратами.</p>\n\n<p>Можно переделать выше приведенный пример, превратив частичную функцию в тотальную, но ценой введения больших граничных погрешностей вычислений:</p>\n\n<pre><code class=\"language-scala\">def div(a: Int, b: Int): Int =\n  if b == 0 then\n    if a == 0 then\n      0             // имитация неопределенности\n    else\n      if a &lt; 0 then\n        Int.MinValue  // имитация минус бесконечности\n      else\n        Int.MaxValue // имитация плюс бесконечности\n  else\n    a / b</code></pre>\n\n<p>Функция получилась тотальной, без выдачи ошибок на нулевой делитель, но с большими допущениями.</p>\n\n<p>Теперь, если вы подумаете об этом, вы можете заметить множество подобных ситуаций в реальных программах, когда неявно ожидается, что функции будут работать правильно только для некоторых входных значений. Частичные функции очень распространены, и мало кто на это обращает внимание. Как минимум, такие функции должны быть обернуты проверками для своих входных аргументов.</p>\n\n<p>Хорошим решением является использование в параметрах функции более подходящих для вычислений типов данных, в которых просто нет проблемных значений. В таком случае, частичная функция превращается в тотальную.</p>\n\n<p>Также можно возвращать специальные значения типа, для случаев, когда вычисление невозможно. Например в типе Double есть специальное значение NaN.</p>\n\n<h2 style=\"text-align:center;\">Табличная функция</h2>\n\n<p>Особый вид частичной функции, это <strong>табличная функция</strong>. Если в обычной частичной функции невозможно обработать только небольшую часть значений типа, то в табличной функции только небольшую часть значений типа обработать <strong>можно</strong>, и эти значения заданы явно, отдельно друг от друга, как бы перечислены в таблице возможных значений (таблица соответствий).</p>\n\n<p>Таблицами значений можно представить многие <strong>коллекции </strong>в Scala, и табличные функции получения элементов коллекций довольно часто используются, несмотря на их частичность в определении значений.</p>\n\n<pre><code class=\"language-scala\">val res = \"abc\" apply 0  // Получение символа 'a'</code></pre>\n\n<p>Например строка, это коллекция символов. По существу, это таблица значений. Если принять, что индекс символа - это входной аргумент, а символ, связанный с этим индексом&nbsp; является значением, то операция&nbsp; получения символа подпадает под определение табличной функции. B случае отсутствия значения для индекса, будет ошибка при вызове функции.</p>\n\n<pre><code class=\"language-scala\">val res = \"abc\" apply 3  // ошибка, нет значения для указанного аргумента</code></pre>\n\n<p>Обратите внимание, что функции получения элементов часто бывают неявными, как например функция <strong>apply</strong>, что означает, что явно они не указываются, но выполняют свою операцию<strong>.</strong></p>\n\n<pre><code class=\"language-scala\">val res = \"abc\".apply(0) // Получение символа 'a'\nval res = \"abc\"(0)       // аналог в другой форме записи, неявный apply</code></pre>\n\n<p>Пример дешифратора текста, с использованием строки как функции-дешифратора:</p>\n\n<pre><code class=\"language-scala\">val res = \"213340\"          // исходный текст\n    .map(_.toString.toInt)  // преобразование каждого символа в индекс-число от 0 до 4\n    .map(\"!eHlo\")           // сопостовление каждого индекса с новым символом из строки-ключа, операция доступа к символу скрыта  \n    .mkString               // создание новой строки из коллекции новых символов</code></pre>\n\n<p>В результате получим слово \"Hello!\"</p>\n\n<p>Кроме табличных, частичных функций получения элементов, есть и тотальные функции, которые используют сложные типы выходных результатов. Их рекомендуется использовать при функциональном стиле.</p>",
  "video" : null,
  "options" : {
    
  },
  "subtitle_files" : [
  ],
  "is_deprecated" : false
}
```

</details>
