{
  "step_id" : 5397526,
  "lesson_id" : 1301870,
  "position" : 1,
  "type" : "unknown",
  "block" : {
    "name" : "text",
    "text" : "<h1 style=\"text-align:center;\">Частично определенная функция</h1>\n\n<p><strong>Частичная определенная функция</strong> (частичная функция) — это функция, которая <strong>не в состоянии</strong> просчитать выходной результат <strong>для всех</strong> возможных входных значений, которые ему могут быть заданы. Он дает ответ <strong>только для части</strong> (подмножества) возможных значений, которые он <strong>может</strong> обрабатывать. Для остальных входных значений функция возвращает <strong>ошибку</strong>.</p>\n\n<p>Частичная функция противоположна по смыслу <strong>тотальной функции</strong>, которая может обработать <strong>все входные значения</strong>, без исключений.</p>\n\n<p>Любая функция любого вида, созданная в языке Scala, может быть или <strong>тотальной </strong>или <strong>частичной</strong>. Это зависит и от <strong>типа данных</strong> и от<strong> алгоритма</strong> вычисления выходного значения. Компилятор, в большинстве случаев, не выдаст предупреждений о использовании частичной функции. И без дополнительных описаний трудно заметить её частичность, но некоторые входные значения могут привести к ошибке вычислений.</p>\n\n<p>Пример частичной функции:</p>\n\n<pre><code class=\"language-scala\">def div(a: Int, b: Int): Int = a / b</code></pre>\n\n<p>Эта функция является частичной, так как использует операцию целочисленного деления, которая не может работать с нулевым делителем и при этом выдает ошибку.</p>\n\n<p>Создание и использование частичных функций нежелательно, так как это мешает работать в функциональном стиле. Также, частичные функции не являются <strong>чистыми</strong>, и не могут иметь полезные свойства чистых функций.</p>\n\n<p>Нередкая причина использования частичных функций, это большие затраты на перевод простой и дешевой частичной функции в более сложную и дорогую тотальную функцию. Всегда существует компромисс между правильностью и затратами.</p>\n\n<p>Можно переделать выше приведенный пример, превратив частичную функцию в тотальную, но ценой введения больших граничных погрешностей вычислений:</p>\n\n<pre><code class=\"language-scala\">def div(a: Int, b: Int): Int =\n  if b == 0 then\n    if a == 0 then\n      0             // имитация неопределенности\n    else\n      if a &lt; 0 then\n        Int.MinValue  // имитация минус бесконечности\n      else\n        Int.MaxValue // имитация плюс бесконечности\n  else\n    a / b</code></pre>\n\n<p>Функция получилась тотальной, без выдачи ошибок на нулевой делитель, но с большими допущениями.</p>\n\n<p>Теперь, если вы подумаете об этом, вы можете заметить множество подобных ситуаций в реальных программах, когда неявно ожидается, что функции будут работать правильно только для некоторых входных значений. Частичные функции очень распространены, и мало кто на это обращает внимание. Как минимум, такие функции должны быть обернуты проверками для своих входных аргументов.</p>\n\n<p>Хорошим решением является использование в параметрах функции более подходящих для вычислений типов данных, в которых просто нет проблемных значений. В таком случае, частичная функция превращается в тотальную.</p>\n\n<p>Также можно возвращать специальные значения типа, для случаев, когда вычисление невозможно. Например в типе Double есть специальное значение NaN.</p>\n\n<h2 style=\"text-align:center;\">Табличная функция</h2>\n\n<p>Особый вид частичной функции, это <strong>табличная функция</strong>. Если в обычной частичной функции невозможно обработать только небольшую часть значений типа, то в табличной функции только небольшую часть значений типа обработать <strong>можно</strong>, и эти значения заданы явно, отдельно друг от друга, как бы перечислены в таблице возможных значений (таблица соответствий).</p>\n\n<p>Таблицами значений можно представить многие <strong>коллекции </strong>в Scala, и табличные функции получения элементов коллекций довольно часто используются, несмотря на их частичность в определении значений.</p>\n\n<pre><code class=\"language-scala\">val res = \"abc\" apply 0  // Получение символа 'a'</code></pre>\n\n<p>Например строка, это коллекция символов. По существу, это таблица значений. Если принять, что индекс символа - это входной аргумент, а символ, связанный с этим индексом&nbsp; является значением, то операция&nbsp; получения символа подпадает под определение табличной функции. B случае отсутствия значения для индекса, будет ошибка при вызове функции.</p>\n\n<pre><code class=\"language-scala\">val res = \"abc\" apply 3  // ошибка, нет значения для указанного аргумента</code></pre>\n\n<p>Обратите внимание, что функции получения элементов часто бывают неявными, как например функция <strong>apply</strong>, что означает, что явно они не указываются, но выполняют свою операцию<strong>.</strong></p>\n\n<pre><code class=\"language-scala\">val res = \"abc\".apply(0) // Получение символа 'a'\nval res = \"abc\"(0)       // аналог в другой форме записи, неявный apply</code></pre>\n\n<p>Пример дешифратора текста, с использованием строки как функции-дешифратора:</p>\n\n<pre><code class=\"language-scala\">val res = \"213340\"          // исходный текст\n    .map(_.toString.toInt)  // преобразование каждого символа в индекс-число от 0 до 4\n    .map(\"!eHlo\")           // сопостовление каждого индекса с новым символом из строки-ключа, операция доступа к символу скрыта  \n    .mkString               // создание новой строки из коллекции новых символов</code></pre>\n\n<p>В результате получим слово \"Hello!\"</p>\n\n<p>Кроме табличных, частичных функций получения элементов, есть и тотальные функции, которые используют сложные типы выходных результатов. Их рекомендуется использовать при функциональном стиле.</p>",
    "video" : null,
    "options" : {
      
    },
    "subtitle_files" : [
    ],
    "is_deprecated" : false
  },
  "name" : "text",
  "course_id" : 195883,
  "course_name" : "Функциональная Scala 3 для начинающих",
  "exported_at" : "2025-12-20T22:21:25.024128"
}