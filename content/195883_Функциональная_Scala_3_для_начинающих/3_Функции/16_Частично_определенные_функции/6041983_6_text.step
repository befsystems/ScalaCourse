{
  "step_id" : 6041983,
  "lesson_id" : 1301870,
  "position" : 6,
  "type" : "unknown",
  "block" : {
    "name" : "text",
    "text" : "<h2 style=\"text-align: center;\"> Использование кортежа как входного параметра</h2>\n\n<p>Декомпозиция доступна для кортежа. <strong>Декомпозиция </strong>- означает разложение сложного значения на составные части, и использование таких частей, как обычных значений.</p>\n\n<p>Пример декомпозиции кортежа в альтернативе:</p>\n\n<pre><code class=\"language-scala\">val fun: PartialFunction[(Int, Char), Int] =        // функциональный тип (Int, Char) =&gt; Int\n  case (x, y) =&gt; x + y                                // альтернативное функциональное выражение\n</code></pre>\n\n<p>Кортеж в альтернативе был представлен как перечень именованных значений <code><strong>x</strong></code> и <code><strong>y </strong></code>элементов кортежа, заключенных в круглые скобки.</p>\n\n<p>Использование кортежа как параметра красиво решает проблему одного входного параметра. При вызове такой функции даже не надо специально создавать кортеж.</p>\n\n<p>Пример:</p>\n\n<pre><code class=\"language-scala\">val res = fun(1, 'a')\n// результат 98\n</code></pre>\n\n<p>При декомпозиции кортежа также можно использовать сопоставление с образцом, то есть, если декомпозированный кортеж не сопоставим с заданным образцом-кортежем, то альтернатива не может быть использована для вычислений. </p>\n\n<p>Пример:</p>\n\n<pre><code class=\"language-scala\">val fun: PartialFunction[(Int, Char), Int] =        // функциональный тип (Int, Char) =&gt; Int\n  case (1, y) =&gt; y.toInt                            // первое альтернативное функциональное выражение \n  case (x, y) =&gt; x + y                              // второе альтернативное функциональное выражение\n</code></pre>\n\n<p>В данном случае первая альтернатива накладывает ограничение, что первым элементом кортежа должна быть единица, только тогда она может быть использована. Вторая альтернатива не накладывает никаких ограничений на декомпозицию, и сработает в любом случае, если первая альтернатива не подойдет.</p>\n\n<p>Создание альтернатив очень обширная тема. В данном уроке мы коснулись её только поверхностно, чтобы иметь возможность создавать функции PartialFunction. Более полно эту тему рассмотрим в уроке о Pattern matching.</p>",
    "video" : null,
    "options" : {
      
    },
    "subtitle_files" : [
    ],
    "is_deprecated" : false
  },
  "name" : "text",
  "course_id" : 195883,
  "course_name" : "Функциональная Scala 3 для начинающих",
  "exported_at" : "2025-12-20T22:21:25.0434764"
}