# Материал (Шаг 1)

## Информация о шаге

- **ID шага**: 9236613
- **Позиция**: 1
- **Тип**: text
- **Курс**: Функциональная Scala 3 для начинающих
- **Экспортирован**: 2026-01-10T10:17:12.7150398

## Содержание

# Как индийская приправа захватила Scala

## Curry — это не только специя

Программист открывает код на Scala и видит: `def add(x: Int)(y: Int) = x + y`. Две пары скобок? Это опечатка или разработчик сошёл с ума?

Нет, это каррирование — техника, названная в честь Хаскелла Карри. Хотя индийское карри тоже при чём: обе вещи острые, многослойные и вызывают привыкание. Но прежде чем разбираться с синтаксисом Scala, нужно вернуться назад — в 1920-е годы, когда один забытый математик совершил прорыв.

## Забытый гений из Екатеринослава

Настоящий отец каррирования — Моисей Исаевич Шейнфинкель, родившийся в Екатеринославе (ныне Днепр) в 1888 году. В 1924-м он опубликовал работу "О строительных блоках математической логики", где доказал революционную идею: **все функции можно свести к функциям одного аргумента**.

Представьте: функция от двух переменных `f(x, y)` — это на самом деле функция `f(x)`, которая возвращает другую функцию `g(y)`. Вместо одной функции с двумя входами — цепочка функций с одним входом каждая.

Зачем такое извращение? Шейнфинкель работал над упрощением математической логики. Если все функции имеют ровно один аргумент, логические системы становятся проще и единообразнее. Это как собирать конструктор из одинаковых деталей вместо разношёрстного набора.

Но коллеги посчитали это бесполезной абстракцией. Статья была написана на немецком, опубликована в малоизвестном журнале. Шейнфинкель покинул академический мир, спился и умер в нищете в психиатрической больнице в 1942 году. Его работа пролежала мёртвым грузом два десятилетия.

## Карри подхватывает эстафету

Хаскелл Брукс Карри родился в 1900 году в США и посвятил жизнь комбинаторной логике — изучению того, как строить сложные вычисления из простых строительных блоков. В 1958 году он независимо переоткрыл идею Шейнфинкеля, развил её и популяризировал.

Карри показал, что это не просто математический трюк, а фундаментальное свойство функций. Он встроил эту концепцию в основы теории вычислений. Работы Карри стали широко известны, его цитировали, приглашали на конференции.

Результат? Три языка программирования названы в честь Карри: Haskell, Curry и Brook. Единственный математик с таким достижением! А техника получила название "каррирование" (currying).

Справедливость требует называть её "шейнфинкелизацией", но попробуйте произнести это слово три раза подряд без запинки. Поэтому мир программирования выбрал более простой вариант, и имя настоящего первооткрывателя оказалось забыто.

## Лямбда-исчисление: теоретический фундамент

Чтобы понять каррирование, нужно нырнуть в лямбда-исчисление Алонзо Чёрча (1930-е годы). Это математическая модель вычислений, где существуют только функции. Три правила:

- **Переменная**: `x` — это выражение

- **Абстракция**: `λx.M` — функция с параметром x и телом M

- **Применение**: `(M N)` — применение функции M к аргументу N

Ключевой момент: в чистом лямбда-исчислении функции принимают ровно один аргумент! Как же тогда реализовать сложение двух чисел? Каррирование! Функция `λx.λy.(x+y)` принимает x и возвращает новую функцию, ожидающую y.

Чёрч и Карри общались, обменивались идеями. Лямбда-исчисление и комбинаторная логика — две стороны одной медали. 

## Революция в программировании

В 1960-х годах идея каррирования проникла в языки программирования. Первопроходцем стал ML, затем появился Haskell (названный в честь Карри). Программисты обнаружили волшебство: можно создавать новые функции на лету, не объявляя их явно.

Представьте: вместо написания отдельной функции для прибавления пяти, вы берете универсальную функцию сложения и "замораживаете" первый аргумент. Получается специализированная функция! Код становится короче, выразительнее, элегантнее.

## Scala и каррирование

В Scala каррирование встроено в ДНК языка:

def multiply(x: Int)(y: Int): Int = x * y

val double = multiply(2) _ // частичное применение
val result = double(5) // 10

Почему две пары скобок, а не `(x: Int, y: Int)`? Потому что это разные типы! Первый вариант: `Int => (Int => Int)`. Второй: `(Int, Int) => Int`. Компилятор видит принципиальную разницу.

Мартин Одерски, создатель Scala, сделал каррирование синтаксически красивым. В Haskell все функции каррированы по умолчанию — там нет выбора. Scala даёт свободу: используй когда нужно, игнорируй когда не нужно.

## Магия частичного применения

Главная суперсила каррирования — создание специализированных функций:

def withTax(rate: Double)(price: Double): Double =
price * (1 + rate)

val withNYTax = withTax(0.08875) _
val withCATax = withTax(0.0725) _

val nyPrice = withNYTax(100.0) // 108.875
val caPrice = withCATax(100.0) // 107.25

Одна функция породила семейство специализированных! Это паттерн "фабрика функций". В объектно-ориентированном программировании для этого нужны классы, интерфейсы, шаблоны проектирования. Здесь — одна строка.

Библиотека Cats активно использует каррирование для создания type classes. Монады, функторы, аппликативы — всё строится на частичном применении. Абстрактная алгебра встречается с практическим кодом.

## Неявные параметры и контекстные абстракции

В Scala каррирование раскрывается через implicit параметры (в Scala 2) или using/given (в Scala 3):

def serialize[A](value: A)(implicit writer: Writer[A]): String =
writer.write(value)

// компилятор автоматически подставит нужный Writer
val json = serialize(Person("Alice", 30))

Почему implicit параметр в отдельной группе? Каррирование! Первая группа — явные аргументы, вторая — неявные. Компилятор видит два отдельных применения функции и может резолвить implicit на втором шаге.

Это фундамент для dependency injection без фреймворков. Type classes, extension methods, контекстные абстракции Scala 3 — всё держится на каррировании. Элегантная теория порождает практичный инструмент.

## Композиция и конвейеры

Каррирование делает композицию функций естественной:

val pipeline: String => Int =
trim _ andThen toLowerCase _ andThen countWords _

val result = pipeline(" HELLO World ") // 2

Без каррирования это невозможно! Функции `trim`, `toLowerCase`, `countWords` имеют тип `A => B`, идеально подходящий для цепочек. С некаррированными функциями пришлось бы городить адаптеры.

Библиотека ZIO использует каррирование для построения эффектов. Вместо callback hell получается читаемый код: `for { user <- getUser(id); orders <- getOrders(user) } yield orders`. Под капотом — цепочки каррированных функций.

## Теория категорий входит

Внимание, сейчас станет по-настоящему математически! Каррирование — это изоморфизм между множествами:

**`Hom(A × B, C) ≅ Hom(A, C^B),`**где **`C^B`** обозначает "функции из B в C".

На человеческом: функция от пары аргументов`(A × B → C)`эквивалентна функции, возвращающей функцию `(A → (B → C))`. Этот изоморфизм называется **curry-uncurry** соответствием и является определяющим свойством декартово замкнутых категорий.

Scala с её системой типов моделирует именно такую категорию! Типы — это объекты категории, функции — морфизмы. Каррирование — естественная трансформация между функторами. Программист на Scala занимается прикладной теорией категорий, даже не подозревая об этом.

Работы математика Сондерса Маклейна 1940-х годов о категориях напрямую влияют на дизайн Scala. Круг замыкается: от Шейнфинкеля через Карри к Маклейну и современным языкам.

## Производительность: ложка дёгтя

Каждый вызов каррированной функции создаёт новый объект функции:

def add(x: Int)(y: Int) = x + y
val result = add(2)(3) // создаётся промежуточная Function1

JVM-оптимизатор научился инлайнить такой код, но гарантий нет. В горячих циклах некаррированная версия быстрее. Benchmarks показывают разницу в 10-30% для тривиальных операций.

Решение? Аннотация `@inline` и компиляторные оптимизации. GraalVM агрессивно оптимизирует каррированный код. В реальных приложениях разница теряется в шуме сетевых запросов и БД.

## Каррирование vs частичное применение

Важное уточнение: это не синонимы!

**Каррирование** — преобразование `f(x, y)` в `f(x)(y)`. Структурное изменение функции.

**Частичное применение** — фиксация части аргументов: `g(y) = f(3, y)`. Использование существующей функции.

В Scala они работают вместе:

def greet(greeting: String)(name: String) = s"$greeting, $name!"
val hello = greet("Hello") _ // частичное применение каррированной функции

Путаница возникла из-за JavaScript и Python, где `.bind()` и `functools.partial` называют "каррированием". Технически неверно, но кто считает?

---

### Полные данные JSON

<details>
<summary>Показать JSON данные</summary>

```json
{
  "name" : "text",
  "text" : "<h1 style=\"text-align:center;\">Как индийская приправа захватила Scala</h1>\n\n<h2 style=\"text-align:center;\">Curry — это не только специя</h2>\n\n<p>Программист открывает код на Scala и видит: <code>def add(x: Int)(y: Int) = x + y</code>. Две пары скобок? Это опечатка или разработчик сошёл с ума?</p>\n\n<p>Нет, это каррирование — техника, названная в честь Хаскелла Карри. Хотя индийское карри тоже при чём: обе вещи острые, многослойные и вызывают привыкание. Но прежде чем разбираться с синтаксисом Scala, нужно вернуться назад — в 1920-е годы, когда один забытый математик совершил прорыв.</p>\n\n<h2 style=\"text-align:center;\">Забытый гений из Екатеринослава</h2>\n\n<p>Настоящий отец каррирования — Моисей Исаевич Шейнфинкель, родившийся в Екатеринославе (ныне Днепр) в 1888 году. В 1924-м он опубликовал работу \"О строительных блоках математической логики\", где доказал революционную идею: <strong>все функции можно свести к функциям одного аргумента</strong>.</p>\n\n<p>Представьте: функция от двух переменных <code>f(x, y)</code> — это на самом деле функция <code>f(x)</code>, которая возвращает другую функцию <code>g(y)</code>. Вместо одной функции с двумя входами — цепочка функций с одним входом каждая.</p>\n\n<p>Зачем такое извращение? Шейнфинкель работал над упрощением математической логики. Если все функции имеют ровно один аргумент, логические системы становятся проще и единообразнее. Это как собирать конструктор из одинаковых деталей вместо разношёрстного набора.</p>\n\n<p>Но коллеги посчитали это бесполезной абстракцией. Статья была написана на немецком, опубликована в малоизвестном журнале. Шейнфинкель покинул академический мир, спился и умер в нищете в психиатрической больнице в 1942 году. Его работа пролежала мёртвым грузом два десятилетия.</p>\n\n<h2 style=\"text-align:center;\">Карри подхватывает эстафету</h2>\n\n<p>Хаскелл Брукс Карри родился в 1900 году в США и посвятил жизнь комбинаторной логике — изучению того, как строить сложные вычисления из простых строительных блоков. В 1958 году он независимо переоткрыл идею Шейнфинкеля, развил её и популяризировал.</p>\n\n<p>Карри показал, что это не просто математический трюк, а фундаментальное свойство функций. Он встроил эту концепцию в основы теории вычислений. Работы Карри стали широко известны, его цитировали, приглашали на конференции.</p>\n\n<p>Результат? Три языка программирования названы в честь Карри: Haskell, Curry и Brook. Единственный математик с таким достижением! А техника получила название \"каррирование\" (currying).</p>\n\n<p>Справедливость требует называть её \"шейнфинкелизацией\", но попробуйте произнести это слово три раза подряд без запинки. Поэтому мир программирования выбрал более простой вариант, и имя настоящего первооткрывателя оказалось забыто.</p>\n\n<h2 style=\"text-align:center;\">Лямбда-исчисление: теоретический фундамент</h2>\n\n<p>Чтобы понять каррирование, нужно нырнуть в лямбда-исчисление Алонзо Чёрча (1930-е годы). Это математическая модель вычислений, где существуют только функции. Три правила:</p>\n\n<ol>\n\t<li><strong>Переменная</strong>: <code>x</code> — это выражение</li>\n\t<li><strong>Абстракция</strong>: <code>λx.M</code> — функция с параметром x и телом M</li>\n\t<li><strong>Применение</strong>: <code>(M N)</code> — применение функции M к аргументу N</li>\n</ol>\n\n<p>Ключевой момент: в чистом лямбда-исчислении функции принимают ровно один аргумент! Как же тогда реализовать сложение двух чисел? Каррирование! Функция <code>λx.λy.(x+y)</code> принимает x и возвращает новую функцию, ожидающую y.</p>\n\n<p>Чёрч и Карри общались, обменивались идеями. Лямбда-исчисление и комбинаторная логика — две стороны одной медали. </p>\n\n<h2 style=\"text-align:center;\">Революция в программировании</h2>\n\n<p>В 1960-х годах идея каррирования проникла в языки программирования. Первопроходцем стал ML, затем появился Haskell (названный в честь Карри). Программисты обнаружили волшебство: можно создавать новые функции на лету, не объявляя их явно.</p>\n\n<p>Представьте: вместо написания отдельной функции для прибавления пяти, вы берете универсальную функцию сложения и \"замораживаете\" первый аргумент. Получается специализированная функция! Код становится короче, выразительнее, элегантнее.</p>\n\n<h2 style=\"text-align:center;\">Scala и каррирование</h2>\n\n<p>В Scala каррирование встроено в ДНК языка:</p>\n\n<pre><code class=\"language-scala\">def multiply(x: Int)(y: Int): Int = x * y\n\nval double = multiply(2) _  // частичное применение\nval result = double(5)      // 10\n</code></pre>\n\n<p>Почему две пары скобок, а не <code>(x: Int, y: Int)</code>? Потому что это разные типы! Первый вариант: <code>Int =&gt; (Int =&gt; Int)</code>. Второй: <code>(Int, Int) =&gt; Int</code>. Компилятор видит принципиальную разницу.</p>\n\n<p>Мартин Одерски, создатель Scala, сделал каррирование синтаксически красивым. В Haskell все функции каррированы по умолчанию — там нет выбора. Scala даёт свободу: используй когда нужно, игнорируй когда не нужно.</p>\n\n<h2 style=\"text-align:center;\">Магия частичного применения</h2>\n\n<p>Главная суперсила каррирования — создание специализированных функций:</p>\n\n<pre><code class=\"language-scala\">def withTax(rate: Double)(price: Double): Double = \n  price * (1 + rate)\n\nval withNYTax = withTax(0.08875) _\nval withCATax = withTax(0.0725) _\n\nval nyPrice = withNYTax(100.0)  // 108.875\nval caPrice = withCATax(100.0)  // 107.25\n</code></pre>\n\n<p>Одна функция породила семейство специализированных! Это паттерн \"фабрика функций\". В объектно-ориентированном программировании для этого нужны классы, интерфейсы, шаблоны проектирования. Здесь — одна строка.</p>\n\n<p>Библиотека Cats активно использует каррирование для создания type classes. Монады, функторы, аппликативы — всё строится на частичном применении. Абстрактная алгебра встречается с практическим кодом.</p>\n\n<h2 style=\"text-align:center;\">Неявные параметры и контекстные абстракции</h2>\n\n<p>В Scala каррирование раскрывается через implicit параметры (в Scala 2) или using/given (в Scala 3):</p>\n\n<pre><code class=\"language-scala\">def serialize[A](value: A)(implicit writer: Writer[A]): String = \n  writer.write(value)\n\n// компилятор автоматически подставит нужный Writer\nval json = serialize(Person(\"Alice\", 30))\n</code></pre>\n\n<p>Почему implicit параметр в отдельной группе? Каррирование! Первая группа — явные аргументы, вторая — неявные. Компилятор видит два отдельных применения функции и может резолвить implicit на втором шаге.</p>\n\n<p>Это фундамент для dependency injection без фреймворков. Type classes, extension methods, контекстные абстракции Scala 3 — всё держится на каррировании. Элегантная теория порождает практичный инструмент.</p>\n\n<h2 style=\"text-align:center;\">Композиция и конвейеры</h2>\n\n<p>Каррирование делает композицию функций естественной:</p>\n\n<pre><code class=\"language-scala\">val pipeline: String =&gt; Int = \n  trim _ andThen toLowerCase _ andThen countWords _\n\nval result = pipeline(\"  HELLO World  \")  // 2\n</code></pre>\n\n<p>Без каррирования это невозможно! Функции <code>trim</code>, <code>toLowerCase</code>, <code>countWords</code> имеют тип <code>A =&gt; B</code>, идеально подходящий для цепочек. С некаррированными функциями пришлось бы городить адаптеры.</p>\n\n<p>Библиотека ZIO использует каррирование для построения эффектов. Вместо callback hell получается читаемый код: <code>for { user &lt;- getUser(id); orders &lt;- getOrders(user) } yield orders</code>. Под капотом — цепочки каррированных функций.</p>\n\n<h2 style=\"text-align:center;\">Теория категорий входит</h2>\n\n<p>Внимание, сейчас станет по-настоящему математически! Каррирование — это изоморфизм между множествами:</p>\n\n<p><strong><code>Hom(A × B, C) ≅ Hom(A, C^B),</code></strong>где <strong><code>C^B</code></strong> обозначает \"функции из B в C\".</p>\n\n<p>На человеческом: функция от пары аргументов<code>(A × B → C)</code>эквивалентна функции, возвращающей функцию <code>(A → (B → C))</code>. Этот изоморфизм называется <strong>curry-uncurry</strong> соответствием и является определяющим свойством декартово замкнутых категорий.</p>\n\n<p>Scala с её системой типов моделирует именно такую категорию! Типы — это объекты категории, функции — морфизмы. Каррирование — естественная трансформация между функторами. Программист на Scala занимается прикладной теорией категорий, даже не подозревая об этом.</p>\n\n<p>Работы математика Сондерса Маклейна 1940-х годов о категориях напрямую влияют на дизайн Scala. Круг замыкается: от Шейнфинкеля через Карри к Маклейну и современным языкам.</p>\n\n<h2 style=\"text-align:center;\">Производительность: ложка дёгтя</h2>\n\n<p>Каждый вызов каррированной функции создаёт новый объект функции:</p>\n\n<pre><code class=\"language-scala\">def add(x: Int)(y: Int) = x + y\nval result = add(2)(3)  // создаётся промежуточная Function1\n</code></pre>\n\n<p>JVM-оптимизатор научился инлайнить такой код, но гарантий нет. В горячих циклах некаррированная версия быстрее. Benchmarks показывают разницу в 10-30% для тривиальных операций.</p>\n\n<p>Решение? Аннотация <code>@inline</code> и компиляторные оптимизации. GraalVM агрессивно оптимизирует каррированный код. В реальных приложениях разница теряется в шуме сетевых запросов и БД.</p>\n\n<h2 style=\"text-align:center;\">Каррирование vs частичное применение</h2>\n\n<p>Важное уточнение: это не синонимы!</p>\n\n<p><strong>Каррирование</strong> — преобразование <code>f(x, y)</code> в <code>f(x)(y)</code>. Структурное изменение функции.</p>\n\n<p><strong>Частичное применение</strong> — фиксация части аргументов: <code>g(y) = f(3, y)</code>. Использование существующей функции.</p>\n\n<p>В Scala они работают вместе:</p>\n\n<pre><code class=\"language-scala\">def greet(greeting: String)(name: String) = s\"$greeting, $name!\"\nval hello = greet(\"Hello\") _  // частичное применение каррированной функции\n</code></pre>\n\n<p>Путаница возникла из-за JavaScript и Python, где <code>.bind()</code> и <code>functools.partial</code> называют \"каррированием\". Технически неверно, но кто считает?</p>",
  "video" : null,
  "options" : {
    
  },
  "subtitle_files" : [
  ],
  "is_deprecated" : false
}
```

</details>
