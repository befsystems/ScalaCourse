{
  "step_id" : 5462169,
  "lesson_id" : 1255297,
  "position" : 4,
  "type" : "unknown",
  "block" : {
    "name" : "text",
    "text" : "<h1 style=\"text-align:center;\">Каррирование</h1>\n\n<p><strong>Каррирование</strong> (currying) — это преобразование функции с несколькими аргументами в последовательность функций, принимающих <strong>только один</strong> аргумент. Каждая функция возвращает другую функцию, которая принимает следующий аргумент.</p>\n\n<h3>Преобразование обычной функции в каррированную</h3>\n\n<pre><code class=\"language-scala\">def add(x: Int, y: Int): Int = x + y        // обычная функция с двумя параметрами\nval addFunction: (Int, Int) =&gt; Int = add    // функциональный тип этой функции \nval curriedAdd: Int =&gt; Int =&gt; Int = addFunction.curried  // каррирование функции</code></pre>\n\n<p>Операция <code>curried</code> выполняет преобразование функции:</p>\n\n<ul>\n\t<li>Изначальный тип: <code>(Int, Int) =&gt; Int</code> — функция с двумя параметрами</li>\n\t<li>Каррированный тип: <code>Int =&gt; Int =&gt; Int</code> — цепочка функций с одним параметром</li>\n</ul>\n\n<h3>Использование каррированной функции</h3>\n\n<pre><code class=\"language-scala\">val addFive: Int =&gt; Int = curriedAdd(5)  // фиксируем первый аргумент, получаем функцию с одним параметром\nval result: Int = addFive(3)             // применяем второй аргумент, результат: 8\n\n// Или можно применить сразу оба аргумента\nval directResult: Int = curriedAdd(5)(3) // результат: 8</code></pre>\n\n<h3>Изначально каррированные функции</h3>\n\n<p>В Scala можно определять функции сразу в каррированном виде, с помощью групп параметров:</p>\n\n<pre><code class=\"language-scala\">def multiply(x: Int)(y: Int): Int = x * y\nval multiplyFunction: Int =&gt; Int =&gt; Int = multiply\n\n// Использование\nval double: Int =&gt; Int = multiply(2)  // функция удваивания\nval doubled = double(4)               // результат: 8</code></pre>\n\n<h2 style=\"text-align:center;\">Практические применения</h2>\n\n<h3>1. Частичное применение аргументов</h3>\n\n<p>Фиксировать часть аргументов и создавать новые, более специализированные функции. Аргументы могут передаваться поэтапно, что полезно для отложенных операций или асинхронных сценариев (<strong>ленивые вычисления</strong>).</p>\n\n<pre><code class=\"language-scala\">def log(level: String)(message: String): Unit = \n  println(s\"[$level] $message\")\n\nval error = log(\"ERROR\")    // частично применённая функция\nval info = log(\"INFO\")\n\nerror(\"Database connection failed\")  // [ERROR] Database connection failed\ninfo(\"Application started\")          // [INFO] Application started</code></pre>\n\n<p>Обычное частичное применение аргументов (без каррирования) позволяет добиться аналогичного результата, но с каррированием это более математически правильно и наглядней.</p>\n\n<h3>2. Конфигурирование функций</h3>\n\n<p>Создание шаблонных функций для повторного использования в разных контекстах.</p>\n\n<pre><code class=\"language-scala\">def calculate(operation: String)(x: Double)(y: Double): Double = operation match {\n  case \"add\" =&gt; x + y\n  case \"multiply\" =&gt; x * y\n  case \"subtract\" =&gt; x - y\n  case _ =&gt; throw new IllegalArgumentException(\"Unknown operation\")\n}\n\nval adder = calculate(\"add\")\nval multiplier = calculate(\"multiply\")\n\nval sum = adder(10)(5)      // 15.0\nval product = multiplier(3)(4)  // 12.0</code></pre>\n\n<h3>3. Композиция функций с несколькими параметрами</h3>\n\n<p>Для композиции функций требуется, чтобы функции были с одним параметром. Каррирование позволяет решить эту проблему, делая все функции с одним параметром:</p>\n\n<pre><code class=\"language-scala\">// Каррированные функции для обработки данных\ndef add(x: Int)(y: Int): Int = x + y\ndef multiply(x: Int)(y: Int): Int = x * y\ndef power(base: Int)(exponent: Int): Int = math.pow(base, exponent).toInt\n\n// Создаём специализированные функции\nval addTen = add(10)\nval double = multiply(2)\nval square = power(_)(2)  // возводим в квадрат\n\n// Используем композицию функций\nval pipeline: Int =&gt; Int = addTen andThen square andThen double\nval sameResult = pipeline(5) // 450</code></pre>\n\n<h3>4. Абстрактные библиотеки и функторы</h3>\n\n<p>Каррирование помогает создавать функциональные библиотеки, которые работают единообразно с любыми абстрактными типами данных (функторы, монады, контейнеры). Многие операции над контейнерами (как <code>map</code>, <code>flatMap</code>, <code>filter</code>) естественным образом каррированы, и часто принимают лямбда-функцию как<strong> </strong>свой<strong> последний</strong> параметр, что естественно подходит для каррирования.</p>\n\n<h2 style=\"text-align:center;\">Каррирование vs Частичное применение</h2>\n\n<p>Важно различать каррирование и частичное применение:</p>\n\n<pre><code class=\"language-scala\">// Каррирование - преобразование структуры функции\ndef uncurried(x: Int, y: Int, z: Int): Int = x + y + z\nval curried: Int =&gt; Int =&gt; Int =&gt; Int = uncurried.curried\n\n// Частичное применение - фиксация некоторых аргументов\nval partiallyApplied = uncurried(1, _, _)  // фиксируем первый аргумент</code></pre>\n\n<h2 style=\"text-align:center;\">Рекомендации по использованию</h2>\n\n<p><strong>Используйте каррирование когда</strong>:</p>\n\n<ul>\n\t<li>Часто применяете функцию с одними и теми же начальными аргументами</li>\n\t<li>Создаёте DSL (Domain Specific Language)</li>\n\t<li>Работаете с функциями высшего порядка</li>\n\t<li>Нужно улучшить композицию функций</li>\n</ul>\n\n<p>Каррирование — мощный инструмент функционального программирования в Scala 3, который делает код более <strong>гибким</strong> и <strong>декларативным</strong>. Однако важно использовать его разумно и обоснованно, чтобы не снижать читаемость кода.</p>",
    "video" : null,
    "options" : {
      
    },
    "subtitle_files" : [
    ],
    "is_deprecated" : false
  },
  "name" : "text",
  "course_id" : 195883,
  "course_name" : "Функциональная Scala 3 для начинающих",
  "exported_at" : "2026-01-10T10:17:12.7284306"
}