# Материал (Шаг 2)

## Информация о шаге

- **ID шага**: 8806869
- **Позиция**: 2
- **Тип**: text
- **Курс**: Функциональная Scala 3 для начинающих
- **Экспортирован**: 2025-12-20T22:21:18.696401

## Содержание

# Область видимости given определений

Контекстные значения образуют отдельную область видимости, но следуют обычным правилам видимости Scala с некоторыми особенностями.

### Локальная область видимости

def processOrder(): Unit = {
// Given определён локально в этой функции
given discount: Double = 0.1 // 10% скидка

def applyDiscount(price: Double)(using disc: Double): Double =
price * (1.0 - disc)

println(applyDiscount(1000.0)) // 900.0
}

// Здесь discount недоступен
// println(applyDiscount(1000.0)) // Ошибка компиляции

### Вложенные области видимости

При вложенных областях видимости более близкие `given` имеют приоритет:

given globalRate: Double = 0.05 // Глобальная ставка 5%

def calculateTax(amount: Double)(using rate: Double): Double =
amount * rate

def process1(): Unit = {
println(calculateTax(1000.0)) // 50.0 - использует globalRate
}

def process2(): Unit = {
given localRate: Double = 0.13 // Локальная ставка 13%
println(calculateTax(1000.0)) // 130.0 - использует localRate

def nested(): Unit = {
given nestedRate: Double = 0.20 // Вложенная ставка 20%
println(calculateTax(1000.0)) // 200.0 - использует nestedRate
}

nested()
println(calculateTax(1000.0)) // 130.0 - снова localRate
}

process1()
process2()

## Импорт given определений

Given определения можно импортировать из других мест.

### Импорт именованных given

object Config {
given serverHost: String = "localhost"
given serverPort: Int = 8080
given debugMode: Boolean = true
}

object Application {
// Импорт конкретного given
import Config.serverHost

def start()(using host: String): Unit = {
println(s"Запуск приложения на $host")
}

// Использует импортированный serverHost
start()
}

### Импорт всех given определений

object DatabaseConfig {
given dbHost: String = "db.example.com"
given dbPort: Int = 5432
}

object DatabaseConnection {
// Импорт всех given определений
import DatabaseConfig.given

def connect()(using host: String, port: Int): String = {
s"Подключение на $host:$port"
}

println(connect())
// Подключение на db.example.com:5432
}

### Селективный импорт given по типу

object Settings {
given maxConnections: Int = 100
given connectionTimeout: Int = 5000
given appName: String = "MyApp"
}

object Service {
// Импортируем только given типа String
import Settings.given String

def printInfo()(using name: String): Unit = {
println(s"$name")
}

printInfo() // MyApp
}

## Приоритеты разрешения given

Когда компилятор ищет контекстное значение, он следует определённым правилам приоритета.

### Правила приоритета (от высшего к низшему):

- **Локальные given** в текущей области видимости

- **Унаследованные given** из внешних областей видимости

- **Импортированные given** (явный импорт)

- **Given из объекта-компаньона** типа параметра

- **Given из пакетного объекта**

### Пример: Замещение given определений

// Глобальное определение
given globalValue: Int = 100

def testPriority(): Unit = {
def inner1(): Unit = {
// Локальное определение перекрывает глобальное
given localValue: Int = 200

def useValue()(using value: Int): Unit = {
println(s"Значение: $value")
}

useValue() // Значение: 200 (использует localValue)
}

def inner2(): Unit = {
def useValue()(using value: Int): Unit = {
println(s"Значение: $value")
}

useValue() // Значение: 100 (использует globalValue)
}

inner1()
inner2()
}

testPriority()

## Given определения с условиями

Иногда нужно определять контекстные значения в зависимости от условий:

### Пример: Динамическая конфигурация

def runInEnvironment(env: String): Unit = {
// Определяем given в зависимости от окружения
given apiEndpoint: String = env match {
case "prod" => "https://api.production.com"
case "staging" => "https://api.staging.com"
case "dev" => "http://localhost:8080"
case _ => "http://localhost:3000"
}

given timeout: Int = env match {
case "prod" => 10
case _ => 30
}

def callApi(path: String)(using endpoint: String, timeout: Int): String = {
s"Вызов $endpoint$path с таймаутом ${timeout}с"
}

println(callApi("/users"))
}

runInEnvironment("prod")
// Вызов https://api.production.com/users с таймаутом 10с

runInEnvironment("dev")
// Вызов http://localhost:8080/users с таймаутом 30с

## Передача контекста через цепочку вызовов

Одно из главных преимуществ контекстных параметров — автоматическая передача через несколько уровней вызовов.

### Пример: Цепочка логирования

// Определяем уровень логирования
given logLevel: String = "INFO"

def log(message: String)(using level: String): Unit = {
println(s"[$level] $message")
}

def saveData(data: String)(using level: String): Unit = {
log(s"Начало сохранения данных: $data")
// ... сохранение ...
log("Данные успешно сохранены")
}

def processRequest(request: String)(using level: String): Unit = {
log(s"Получен запрос: $request")
saveData(request)
log("Запрос обработан")
}

def handleApi(endpoint: String)(using level: String): Unit = {
log(s"API вызов: $endpoint")
processRequest(endpoint)
log("API ответ отправлен")
}

// Один given передаётся через всю цепочку
handleApi("/api/users")

Вывод:

[INFO] API вызов: /api/users
[INFO] Получен запрос: /api/users
[INFO] Начало сохранения данных: /api/users
[INFO] Данные успешно сохранены
[INFO] Запрос обработан
[INFO] API ответ отправлен

Без контекстных параметров пришлось бы явно передавать `logLevel` через каждую функцию!

## Контекстные параметры и рекурсия

Контекстные параметры отлично работают с рекурсивными функциями:

given indent: Int = 2

def printTree(node: String, level: Int)(using indentSize: Int): Unit = {
println(" " * (level * indentSize) + node)
}

def generateHierarchy(name: String, level: Int, maxLevel: Int)
(using indentSize: Int): Unit = {
if (level <= maxLevel) {
printTree(s"$name-$level", level)
generateHierarchy(name, level + 1, maxLevel)
}
}

generateHierarchy("Node", 0, 3)

Вывод:

Node-0
Node-1
Node-2
Node-3

## Захват контекстных значений

Можно получить текущее контекстное значение в любом месте кода с помощью **`summon`**

given debug: Boolean = true

def performAction(action: String): Unit = {
val debugMode = summon[Boolean] // Захват контекстного значения

if (debugMode) {
println(s"[DEBUG] Выполняется: $action")
}
println(s"Действие '$action' выполнено")
}

performAction("сохранение данных")

---

### Полные данные JSON

<details>
<summary>Показать JSON данные</summary>

```json
{
  "name" : "text",
  "text" : "<h1 style=\"text-align:center;\">Область видимости given определений</h1>\n\n<p>Контекстные значения образуют отдельную область видимости, но следуют обычным правилам видимости Scala с некоторыми особенностями.</p>\n\n<h3>Локальная область видимости</h3>\n\n<pre><code class=\"language-scala\">def processOrder(): Unit = {\n  // Given определён локально в этой функции\n  given discount: Double = 0.1  // 10% скидка\n  \n  def applyDiscount(price: Double)(using disc: Double): Double = \n    price * (1.0 - disc)\n  \n  println(applyDiscount(1000.0))  // 900.0\n}\n\n// Здесь discount недоступен\n// println(applyDiscount(1000.0))  // Ошибка компиляции\n</code></pre>\n\n<h3>Вложенные области видимости</h3>\n\n<p>При вложенных областях видимости более близкие <code>given</code> имеют приоритет:</p>\n\n<pre><code class=\"language-scala\">given globalRate: Double = 0.05  // Глобальная ставка 5%\n\ndef calculateTax(amount: Double)(using rate: Double): Double = \n  amount * rate\n\ndef process1(): Unit = {\n  println(calculateTax(1000.0))  // 50.0 - использует globalRate\n}\n\ndef process2(): Unit = {\n  given localRate: Double = 0.13  // Локальная ставка 13%\n  println(calculateTax(1000.0))    // 130.0 - использует localRate\n  \n  def nested(): Unit = {\n    given nestedRate: Double = 0.20  // Вложенная ставка 20%\n    println(calculateTax(1000.0))     // 200.0 - использует nestedRate\n  }\n  \n  nested()\n  println(calculateTax(1000.0))      // 130.0 - снова localRate\n}\n\nprocess1()\nprocess2()\n</code></pre>\n\n<h2 style=\"text-align:center;\">Импорт given определений</h2>\n\n<p>Given определения можно импортировать из других мест.</p>\n\n<h3>Импорт именованных given</h3>\n\n<pre><code class=\"language-scala\">object Config {\n  given serverHost: String = \"localhost\"\n  given serverPort: Int = 8080\n  given debugMode: Boolean = true\n}\n\nobject Application {\n  // Импорт конкретного given\n  import Config.serverHost\n  \n  def start()(using host: String): Unit = {\n    println(s\"Запуск приложения на $host\")\n  }\n  \n  // Использует импортированный serverHost\n  start()\n}\n</code></pre>\n\n<h3>Импорт всех given определений</h3>\n\n<pre><code class=\"language-scala\">object DatabaseConfig {\n  given dbHost: String = \"db.example.com\"\n  given dbPort: Int = 5432\n}\n\nobject DatabaseConnection {\n  // Импорт всех given определений\n  import DatabaseConfig.given\n  \n  def connect()(using host: String, port: Int): String = {\n    s\"Подключение на $host:$port\"\n  }\n  \n  println(connect())\n  // Подключение на db.example.com:5432\n}\n</code></pre>\n\n<h3>Селективный импорт given по типу</h3>\n\n<pre><code class=\"language-scala\">object Settings {\n  given maxConnections: Int = 100\n  given connectionTimeout: Int = 5000\n  given appName: String = \"MyApp\"\n}\n\nobject Service {\n  // Импортируем только given типа String\n  import Settings.given String\n  \n  def printInfo()(using name: String): Unit = {\n    println(s\"$name\")\n  }\n  \n  printInfo()  // MyApp \n}\n</code></pre>\n\n<h2 style=\"text-align:center;\">Приоритеты разрешения given</h2>\n\n<p>Когда компилятор ищет контекстное значение, он следует определённым правилам приоритета.</p>\n\n<h3>Правила приоритета (от высшего к низшему):</h3>\n\n<ol>\n\t<li><strong>Локальные given</strong> в текущей области видимости</li>\n\t<li><strong>Унаследованные given</strong> из внешних областей видимости</li>\n\t<li><strong>Импортированные given</strong> (явный импорт)</li>\n\t<li><strong>Given из объекта-компаньона</strong> типа параметра</li>\n\t<li><strong>Given из пакетного объекта</strong></li>\n</ol>\n\n<h3>Пример: Замещение given определений</h3>\n\n<pre><code class=\"language-scala\">// Глобальное определение\ngiven globalValue: Int = 100\n\ndef testPriority(): Unit = {\n  def inner1(): Unit = {\n    // Локальное определение перекрывает глобальное\n    given localValue: Int = 200\n    \n    def useValue()(using value: Int): Unit = {\n      println(s\"Значение: $value\")\n    }\n    \n    useValue()  // Значение: 200 (использует localValue)\n  }\n  \n  def inner2(): Unit = {\n    def useValue()(using value: Int): Unit = {\n      println(s\"Значение: $value\")\n    }\n    \n    useValue()  // Значение: 100 (использует globalValue)\n  }\n  \n  inner1()\n  inner2()\n}\n\ntestPriority()\n</code></pre>\n\n<h2 style=\"text-align:center;\">Given определения с условиями</h2>\n\n<p>Иногда нужно определять контекстные значения в зависимости от условий:</p>\n\n<h3>Пример: Динамическая конфигурация</h3>\n\n<pre><code class=\"language-scala\">def runInEnvironment(env: String): Unit = {\n  // Определяем given в зависимости от окружения\n  given apiEndpoint: String = env match {\n    case \"prod\" =&gt; \"https://api.production.com\"\n    case \"staging\" =&gt; \"https://api.staging.com\"\n    case \"dev\" =&gt; \"http://localhost:8080\"\n    case _ =&gt; \"http://localhost:3000\"\n  }\n  \n  given timeout: Int = env match {\n    case \"prod\" =&gt; 10\n    case _ =&gt; 30\n  }\n  \n  def callApi(path: String)(using endpoint: String, timeout: Int): String = {\n    s\"Вызов $endpoint$path с таймаутом ${timeout}с\"\n  }\n  \n  println(callApi(\"/users\"))\n}\n\nrunInEnvironment(\"prod\")\n// Вызов https://api.production.com/users с таймаутом 10с\n\nrunInEnvironment(\"dev\")\n// Вызов http://localhost:8080/users с таймаутом 30с\n</code></pre>\n\n<h2 style=\"text-align:center;\">Передача контекста через цепочку вызовов</h2>\n\n<p>Одно из главных преимуществ контекстных параметров — автоматическая передача через несколько уровней вызовов.</p>\n\n<h3>Пример: Цепочка логирования</h3>\n\n<pre><code class=\"language-scala\">// Определяем уровень логирования\ngiven logLevel: String = \"INFO\"\n\ndef log(message: String)(using level: String): Unit = {\n  println(s\"[$level] $message\")\n}\n\ndef saveData(data: String)(using level: String): Unit = {\n  log(s\"Начало сохранения данных: $data\")\n  // ... сохранение ...\n  log(\"Данные успешно сохранены\")\n}\n\ndef processRequest(request: String)(using level: String): Unit = {\n  log(s\"Получен запрос: $request\")\n  saveData(request)\n  log(\"Запрос обработан\")\n}\n\ndef handleApi(endpoint: String)(using level: String): Unit = {\n  log(s\"API вызов: $endpoint\")\n  processRequest(endpoint)\n  log(\"API ответ отправлен\")\n}\n\n// Один given передаётся через всю цепочку\nhandleApi(\"/api/users\")\n</code></pre>\n\n<p>Вывод:</p>\n\n<pre><code>[INFO] API вызов: /api/users\n[INFO] Получен запрос: /api/users\n[INFO] Начало сохранения данных: /api/users\n[INFO] Данные успешно сохранены\n[INFO] Запрос обработан\n[INFO] API ответ отправлен\n</code></pre>\n\n<p>Без контекстных параметров пришлось бы явно передавать <code>logLevel</code> через каждую функцию!</p>\n\n<h2 style=\"text-align:center;\">Контекстные параметры и рекурсия</h2>\n\n<p>Контекстные параметры отлично работают с рекурсивными функциями:</p>\n\n<pre><code class=\"language-scala\">given indent: Int = 2\n\ndef printTree(node: String, level: Int)(using indentSize: Int): Unit = {\n  println(\" \" * (level * indentSize) + node)\n}\n\ndef generateHierarchy(name: String, level: Int, maxLevel: Int)\n                     (using indentSize: Int): Unit = {\n  if (level &lt;= maxLevel) {\n    printTree(s\"$name-$level\", level)\n    generateHierarchy(name, level + 1, maxLevel)\n  }\n}\n\ngenerateHierarchy(\"Node\", 0, 3)\n</code></pre>\n\n<p>Вывод:</p>\n\n<pre><code>Node-0\n  Node-1\n    Node-2\n      Node-3\n</code></pre>\n\n<h2 style=\"text-align:center;\">Захват контекстных значений</h2>\n\n<p>Можно получить текущее контекстное значение в любом месте кода с помощью <strong><code>summon</code></strong></p>\n\n<pre><code class=\"language-scala\">given debug: Boolean = true\n\ndef performAction(action: String): Unit = {\n  val debugMode = summon[Boolean]  // Захват контекстного значения\n  \n  if (debugMode) {\n    println(s\"[DEBUG] Выполняется: $action\")\n  }\n  println(s\"Действие '$action' выполнено\")\n}\n\nperformAction(\"сохранение данных\")\n</code></pre>",
  "video" : null,
  "options" : {
    
  },
  "subtitle_files" : [
  ],
  "is_deprecated" : false
}
```

</details>
