# Материал (Шаг 1)

## Информация о шаге

- **ID шага**: 8665541
- **Позиция**: 1
- **Тип**: text
- **Курс**: Функциональная Scala 3 для начинающих
- **Экспортирован**: 2025-12-20T22:21:18.6849936

## Содержание

# Контекстные параметры функции

**Контекстные значения** — это именованные или анонимные определения любых **значений**, созданные с ключевым словом `given`(вместо val), которые формируют **контекстную** (особую)** область видимости** (context scope).

**Контекстные параметры** — это параметры функции, для которых компилятор сам находит и подставляет подходящие аргументы в текущей области видимости **контекстных значений**. Такие параметры выделяются в отдельную секцию параметров функции.

Также контекстные значения и параметры можно назвать **неявными**, так как их смысл проникать в функцию неявным образом, то есть, нет необходимости указывать их явно при вызове функции. Термин **контекст -** указывает на архитектурную цель использования таких параметров, то есть передача контекста окружения функции.

Контекстные параметры решают несколько задач:

- **Уменьшение повторяющегося кода** — не нужно явно передавать одни и те же параметры через множество уровней вызовов функций

- **Моделирование окружения** — можно описать "контекст выполнения" (например, конфигурацию, настройки логирования)

- **Улучшение читаемости** — фокус на важной бизнес-логике, а не на технических деталях передачи параметров

## Синтаксис: ключевые слова `using и given`

Для определения **контекстных параметров** используется ключевое слово `using`в отдельной секции параметров функции.

Для определения **контекстных значений** используется ключевое слово `given` (вместо val). Несмотря на отдельную область видимости контекстных значений, их имена не должны повторять имена обычных значений.

Компилятор производит поиск доступного контекстного значения в соответствии **с типом** контекстного параметра**.**

Функция может иметь как обычные, так и контекстные параметры.

### Пример 1: Простейший контекстный параметр

// Функция с контекстным параметром
def greet(name: String)(using language: String): String =
language match {
case "ru" => s"Привет, $name!"
case "en" => s"Hello, $name!"
case "es" => s"¡Hola, $name!"
case _ => s"Hi, $name!"
}

// Определяем контекстное значение
given defaultLanguage: String = "ru"

// Вызов функции без явной передачи языка
val greeting1 = greet("Иван") // "Привет, Иван!"

// Можно явно указать другое значение
val greeting2 = greet("John")(using "en") // "Hello, John!"

В этом примере:

- Параметр `language` объявлен с ключевым словом `using`

- Мы определили `given defaultLanguage` — контекстное значение типа String

- При вызове `greet("Иван")` компилятор автоматически находит и подставляет `defaultLanguage`

- При необходимости можно явно передать значение с помощью `using`

##  Именованные и анонимные given

Так как при неявной передаче аргумента имя такого значения не важно, то вы можете не давать имена своим `given` определениям:

### Пример 2: Анонимное given

// Анонимное given - только неявное использование
given Int = 443

def connectSecure(host: String)(using port: Int): String =
s"Безопасное подключение к $host:$port"

println(connectSecure("example.com")) // Безопасное подключение к example.com:443

// Именованное given - можно использовать явно
given standardPort: Int = 8080

def connectToServer(host: String)(using port: Int): String =
s"Подключение к $host:$port"

// Можно использовать неявно
println(connectToServer("localhost")) // Подключение к localhost:8080

// Или явно по имени
println(connectToServer("localhost")(using standardPort))

### Пример 3: Контекстные параметры и вычисления

// Налоговая ставка как контекстный параметр
def calculatePrice(basePrice: Double)(using taxRate: Double): Double =
basePrice * (1.0 + taxRate)

// Определяем разные налоговые ставки для разных контекстов
def calculateInMoscow(): Double = {
given Double = 0.20 // НДС 20%
calculatePrice(1000.0)
}

def calculateInDelaware(): Double = {
given Double = 0.0 // Нет налога с продаж
calculatePrice(1000.0)
}

println(calculateInMoscow()) // 1200.0
println(calculateInDelaware()) // 1000.0

Здесь контекстный параметр `taxRate` позволяет вычислять цену с учётом разных налоговых ставок в зависимости от контекста.

### Пример 4: Точность вычислений

// Функция сравнения чисел с плавающей точкой
def areEqual(a: Double, b: Double)(using epsilon: Double): Boolean =
Math.abs(a - b) < epsilon

// Контекст высокой точности
def highPrecisionCalculation(): Unit = {
given Double = 0.0001

val result1 = 1.0 / 3.0 * 3.0
val result2 = 1.0

println(areEqual(result1, result2)) // true
println(s"Разница: ${Math.abs(result1 - result2)}")
}

// Контекст низкой точности
def lowPrecisionCalculation(): Unit = {
given Double = 0.01

val result1 = 1.005
val result2 = 1.008

println(areEqual(result1, result2)) // true, разница 0.003 < 0.01
}

highPrecisionCalculation()
lowPrecisionCalculation()

### Пример 5: Given с вычисляемым значением

// Given с вычисляемым значением
given String = {
val hour = java.time.LocalTime.now().getHour
if (hour < 12) "Доброе утро"
else if (hour < 18) "Добрый день"
else "Добрый вечер"
}

def printGreeting(using greeting: String): Unit =
println(greeting)

printGreeting

## Множественные контекстные параметры

Функция может иметь несколько контекстных параметров. Все они указываются в одном блоке `using`.

### Пример 6: Несколько контекстных параметров

// Функция форматирования числа с учётом локали
def formatCurrency(amount: Double)(using
currencySymbol: String,
decimalPlaces: Int
): String = {
val rounded = BigDecimal(amount).setScale(decimalPlaces, BigDecimal.RoundingMode.HALF_UP)
s"$currencySymbol${rounded.toString}"
}

// Русская локаль
def formatForRussia(): Unit = {
given String = "₽"
given Int = 2
println(formatCurrency(1234.567)) // ₽1234.57
}

// Американская локаль
def formatForUSA(): Unit = {
given String = "$"
given Int = 2
println(formatCurrency(1234.567)) // $1234.57
}

// Научная точность
def formatScientific(): Unit = {
given String = "$"
given Int = 6
println(formatCurrency(1234.567)) // $1234.567000
}

formatForRussia()
formatForUSA()
formatScientific()

### Проблема множественных контекстных параметров одного типа

Если мы имеем несколько контекстных параметров одного типа, то компилятор не сможет подобрать какой аргумент к какому параметру подходит, так как он подбирает контекстное значение по типу, и выдаст ошибку компиляции. Однозначно, в списке контекстных параметров не должно быть одинаковых типов!

Решение проблемы это группировка параметров в сложную структуру или создание непрозрачных типов (opaque types - вне рамок данного урока).

### Пример 7: Группировка контекстных параметров

// Используем Tuple для группировки параметров одного типа
def formatCurrency(amount: Double)(using format: (String, String)): String = {
val (currencySymbol, decimalSeparator) = format
val wholePart = amount.toInt
val fractionalPart = ((amount - wholePart) * 100).toInt
s"$currencySymbol$wholePart$decimalSeparator${fractionalPart.toString.padTo(2, '0')}"
}

// Русская локаль
def formatForRussia(): Unit = {
given (String, String) = ("₽", ",")
println(formatCurrency(1234.56)) // ₽1234,56
}

// Американская локаль
def formatForUSA(): Unit = {
given (String, String) = ("$", ".")
println(formatCurrency(1234.56)) // $1234.56
}

formatForRussia()
formatForUSA()

## Вызов функций с контекстными параметрами

Существует три способа вызова функций с контекстными параметрами:

### 1. Неявная передача (рекомендуется)

def process(value: Int)(using multiplier: Int): Int = value * multiplier

given Int = 10
println(process(5)) // 50

### 2. Явная передача с `using`

println(process(5)(using 20)) // 100

### 3. Явная именованная передача

println(process(5)(using multiplier = 15)) // 75

---

### Полные данные JSON

<details>
<summary>Показать JSON данные</summary>

```json
{
  "name" : "text",
  "text" : "<h1 style=\"text-align:center;\">Контекстные параметры функции</h1>\n\n<p><strong>Контекстные значения</strong> — это именованные или анонимные определения любых <strong>значений</strong>, созданные с ключевым словом <code>given</code>(вместо val), которые формируют <strong>контекстную</strong> (особую)<strong> область видимости</strong> (context scope).</p>\n\n<p><strong>Контекстные параметры</strong> — это параметры функции, для которых компилятор сам находит и подставляет подходящие аргументы в текущей области видимости <strong>контекстных значений</strong>. Такие параметры выделяются в отдельную секцию параметров функции.</p>\n\n<p>Также контекстные значения и параметры можно назвать <strong>неявными</strong>, так как их смысл проникать в функцию неявным образом, то есть, нет необходимости указывать их явно при вызове функции. Термин <strong>контекст -</strong> указывает на архитектурную цель использования таких параметров, то есть передача контекста окружения функции.</p>\n\n<p>Контекстные параметры решают несколько задач:</p>\n\n<ol>\n\t<li><strong>Уменьшение повторяющегося кода</strong> — не нужно явно передавать одни и те же параметры через множество уровней вызовов функций</li>\n\t<li><strong>Моделирование окружения</strong> — можно описать \"контекст выполнения\" (например, конфигурацию, настройки логирования)</li>\n\t<li><strong>Улучшение читаемости</strong> — фокус на важной бизнес-логике, а не на технических деталях передачи параметров</li>\n</ol>\n\n<h2 style=\"text-align:center;\">Синтаксис: ключевые слова <code>using и given</code></h2>\n\n<p>Для определения <strong>контекстных параметров</strong> используется ключевое слово <code>using</code>в отдельной секции параметров функции.</p>\n\n<p>Для определения <strong>контекстных значений</strong> используется ключевое слово <code>given</code> (вместо val). Несмотря на отдельную область видимости контекстных значений, их имена не должны повторять имена обычных значений.</p>\n\n<p>Компилятор производит поиск доступного контекстного значения в соответствии <strong>с типом</strong> контекстного параметра<strong>.</strong></p>\n\n<p>Функция может иметь как обычные, так и контекстные параметры.</p>\n\n<h3>Пример 1: Простейший контекстный параметр</h3>\n\n<pre><code class=\"language-scala\">// Функция с контекстным параметром\ndef greet(name: String)(using language: String): String = \n  language match {\n    case \"ru\" =&gt; s\"Привет, $name!\"\n    case \"en\" =&gt; s\"Hello, $name!\"\n    case \"es\" =&gt; s\"¡Hola, $name!\"\n    case _ =&gt; s\"Hi, $name!\"\n  }\n\n// Определяем контекстное значение\ngiven defaultLanguage: String = \"ru\"\n\n// Вызов функции без явной передачи языка\nval greeting1 = greet(\"Иван\")  // \"Привет, Иван!\"\n\n// Можно явно указать другое значение\nval greeting2 = greet(\"John\")(using \"en\")  // \"Hello, John!\"\n</code></pre>\n\n<p>В этом примере:</p>\n\n<ul>\n\t<li>Параметр <code>language</code> объявлен с ключевым словом <code>using</code></li>\n\t<li>Мы определили <code>given defaultLanguage</code> — контекстное значение типа String</li>\n\t<li>При вызове <code>greet(\"Иван\")</code> компилятор автоматически находит и подставляет <code>defaultLanguage</code></li>\n\t<li>При необходимости можно явно передать значение с помощью <code>using</code></li>\n</ul>\n\n<h2 style=\"text-align:center;\"> Именованные и анонимные given</h2>\n\n<p>Так как при неявной передаче аргумента имя такого значения не важно, то вы можете не давать имена своим <code>given</code> определениям:</p>\n\n<h3>Пример 2: Анонимное given</h3>\n\n<pre><code class=\"language-scala\">// Анонимное given - только неявное использование\ngiven Int = 443\n\ndef connectSecure(host: String)(using port: Int): String = \n  s\"Безопасное подключение к $host:$port\"\n\nprintln(connectSecure(\"example.com\"))  // Безопасное подключение к example.com:443\n\n\n// Именованное given - можно использовать явно\ngiven standardPort: Int = 8080\n\ndef connectToServer(host: String)(using port: Int): String = \n  s\"Подключение к $host:$port\"\n\n// Можно использовать неявно\nprintln(connectToServer(\"localhost\"))  // Подключение к localhost:8080\n\n// Или явно по имени\nprintln(connectToServer(\"localhost\")(using standardPort))</code></pre>\n\n<h3>Пример 3: Контекстные параметры и вычисления</h3>\n\n<pre><code class=\"language-scala\">// Налоговая ставка как контекстный параметр\ndef calculatePrice(basePrice: Double)(using taxRate: Double): Double = \n  basePrice * (1.0 + taxRate)\n\n// Определяем разные налоговые ставки для разных контекстов\ndef calculateInMoscow(): Double = {\n  given Double = 0.20  // НДС 20%\n  calculatePrice(1000.0)\n}\n\ndef calculateInDelaware(): Double = {\n  given Double = 0.0  // Нет налога с продаж\n  calculatePrice(1000.0)\n}\n\nprintln(calculateInMoscow())     // 1200.0\nprintln(calculateInDelaware())   // 1000.0\n</code></pre>\n\n<p>Здесь контекстный параметр <code>taxRate</code> позволяет вычислять цену с учётом разных налоговых ставок в зависимости от контекста.</p>\n\n<h3>Пример 4: Точность вычислений</h3>\n\n<pre><code class=\"language-scala\">// Функция сравнения чисел с плавающей точкой\ndef areEqual(a: Double, b: Double)(using epsilon: Double): Boolean = \n  Math.abs(a - b) &lt; epsilon\n\n// Контекст высокой точности\ndef highPrecisionCalculation(): Unit = {\n  given Double = 0.0001\n  \n  val result1 = 1.0 / 3.0 * 3.0\n  val result2 = 1.0\n  \n  println(areEqual(result1, result2))  // true\n  println(s\"Разница: ${Math.abs(result1 - result2)}\")\n}\n\n// Контекст низкой точности\ndef lowPrecisionCalculation(): Unit = {\n  given Double = 0.01\n  \n  val result1 = 1.005\n  val result2 = 1.008\n  \n  println(areEqual(result1, result2))  // true, разница 0.003 &lt; 0.01\n}\n\nhighPrecisionCalculation()\nlowPrecisionCalculation()\n</code></pre>\n\n<h3>Пример 5: Given с вычисляемым значением</h3>\n\n<pre><code class=\"language-scala\">// Given с вычисляемым значением\ngiven String = {\n  val hour = java.time.LocalTime.now().getHour\n  if (hour &lt; 12) \"Доброе утро\"\n  else if (hour &lt; 18) \"Добрый день\"\n  else \"Добрый вечер\"\n}\n\ndef printGreeting(using greeting: String): Unit =\n  println(greeting)\n\nprintGreeting</code></pre>\n\n<h2 style=\"text-align:center;\">Множественные контекстные параметры</h2>\n\n<p>Функция может иметь несколько контекстных параметров. Все они указываются в одном блоке <code>using</code>.</p>\n\n<h3>Пример 6: Несколько контекстных параметров</h3>\n\n<pre><code class=\"language-scala\">// Функция форматирования числа с учётом локали\ndef formatCurrency(amount: Double)(using \n  currencySymbol: String,\n  decimalPlaces: Int\n): String = {\n  val rounded = BigDecimal(amount).setScale(decimalPlaces, BigDecimal.RoundingMode.HALF_UP)\n  s\"$currencySymbol${rounded.toString}\"\n}\n\n// Русская локаль\ndef formatForRussia(): Unit = {\n  given String = \"₽\"\n  given Int = 2\n  println(formatCurrency(1234.567))  // ₽1234.57\n}\n\n// Американская локаль\ndef formatForUSA(): Unit = {\n  given String = \"$\"\n  given Int = 2\n  println(formatCurrency(1234.567))  // $1234.57\n}\n\n// Научная точность\ndef formatScientific(): Unit = {\n  given String = \"$\"\n  given Int = 6\n  println(formatCurrency(1234.567))  // $1234.567000\n}\n\nformatForRussia()\nformatForUSA()\nformatScientific()</code></pre>\n\n<h3 style=\"text-align:center;\">Проблема множественных контекстных параметров одного типа</h3>\n\n<p>Если мы имеем несколько контекстных параметров одного типа, то компилятор не сможет подобрать какой аргумент к какому параметру подходит, так как он подбирает контекстное значение по типу, и выдаст ошибку компиляции. Однозначно, в списке контекстных параметров не должно быть одинаковых типов!</p>\n\n<p>Решение проблемы это группировка параметров в сложную структуру или создание непрозрачных типов (opaque types - вне рамок данного урока).</p>\n\n<h3>Пример 7: Группировка контекстных параметров</h3>\n\n<pre><code class=\"language-scala\">// Используем Tuple для группировки параметров одного типа\ndef formatCurrency(amount: Double)(using format: (String, String)): String = {\n  val (currencySymbol, decimalSeparator) = format\n  val wholePart = amount.toInt\n  val fractionalPart = ((amount - wholePart) * 100).toInt\n  s\"$currencySymbol$wholePart$decimalSeparator${fractionalPart.toString.padTo(2, '0')}\"\n}\n\n// Русская локаль\ndef formatForRussia(): Unit = {\n  given (String, String) = (\"₽\", \",\")\n  println(formatCurrency(1234.56))  // ₽1234,56\n}\n\n// Американская локаль\ndef formatForUSA(): Unit = {\n  given (String, String) = (\"$\", \".\")\n  println(formatCurrency(1234.56))  // $1234.56\n}\n\nformatForRussia()\nformatForUSA()</code></pre>\n\n<h2 style=\"text-align:center;\">Вызов функций с контекстными параметрами</h2>\n\n<p>Существует три способа вызова функций с контекстными параметрами:</p>\n\n<h3>1. Неявная передача (рекомендуется)</h3>\n\n<pre><code class=\"language-scala\">def process(value: Int)(using multiplier: Int): Int = value * multiplier\n\ngiven Int = 10\nprintln(process(5))  // 50\n</code></pre>\n\n<h3>2. Явная передача с <code>using</code></h3>\n\n<pre><code class=\"language-scala\">println(process(5)(using 20))  // 100\n</code></pre>\n\n<h3>3. Явная именованная передача</h3>\n\n<pre><code class=\"language-scala\">println(process(5)(using multiplier = 15))  // 75\n</code></pre>",
  "video" : null,
  "options" : {
    
  },
  "subtitle_files" : [
  ],
  "is_deprecated" : false
}
```

</details>
