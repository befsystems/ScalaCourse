{
  "step_id" : 8806869,
  "lesson_id" : 2041279,
  "position" : 2,
  "type" : "unknown",
  "block" : {
    "name" : "text",
    "text" : "<h1 style=\"text-align:center;\">Область видимости given определений</h1>\n\n<p>Контекстные значения образуют отдельную область видимости, но следуют обычным правилам видимости Scala с некоторыми особенностями.</p>\n\n<h3>Локальная область видимости</h3>\n\n<pre><code class=\"language-scala\">def processOrder(): Unit = {\n  // Given определён локально в этой функции\n  given discount: Double = 0.1  // 10% скидка\n  \n  def applyDiscount(price: Double)(using disc: Double): Double = \n    price * (1.0 - disc)\n  \n  println(applyDiscount(1000.0))  // 900.0\n}\n\n// Здесь discount недоступен\n// println(applyDiscount(1000.0))  // Ошибка компиляции\n</code></pre>\n\n<h3>Вложенные области видимости</h3>\n\n<p>При вложенных областях видимости более близкие <code>given</code> имеют приоритет:</p>\n\n<pre><code class=\"language-scala\">given globalRate: Double = 0.05  // Глобальная ставка 5%\n\ndef calculateTax(amount: Double)(using rate: Double): Double = \n  amount * rate\n\ndef process1(): Unit = {\n  println(calculateTax(1000.0))  // 50.0 - использует globalRate\n}\n\ndef process2(): Unit = {\n  given localRate: Double = 0.13  // Локальная ставка 13%\n  println(calculateTax(1000.0))    // 130.0 - использует localRate\n  \n  def nested(): Unit = {\n    given nestedRate: Double = 0.20  // Вложенная ставка 20%\n    println(calculateTax(1000.0))     // 200.0 - использует nestedRate\n  }\n  \n  nested()\n  println(calculateTax(1000.0))      // 130.0 - снова localRate\n}\n\nprocess1()\nprocess2()\n</code></pre>\n\n<h2 style=\"text-align:center;\">Импорт given определений</h2>\n\n<p>Given определения можно импортировать из других мест.</p>\n\n<h3>Импорт именованных given</h3>\n\n<pre><code class=\"language-scala\">object Config {\n  given serverHost: String = \"localhost\"\n  given serverPort: Int = 8080\n  given debugMode: Boolean = true\n}\n\nobject Application {\n  // Импорт конкретного given\n  import Config.serverHost\n  \n  def start()(using host: String): Unit = {\n    println(s\"Запуск приложения на $host\")\n  }\n  \n  // Использует импортированный serverHost\n  start()\n}\n</code></pre>\n\n<h3>Импорт всех given определений</h3>\n\n<pre><code class=\"language-scala\">object DatabaseConfig {\n  given dbHost: String = \"db.example.com\"\n  given dbPort: Int = 5432\n}\n\nobject DatabaseConnection {\n  // Импорт всех given определений\n  import DatabaseConfig.given\n  \n  def connect()(using host: String, port: Int): String = {\n    s\"Подключение на $host:$port\"\n  }\n  \n  println(connect())\n  // Подключение на db.example.com:5432\n}\n</code></pre>\n\n<h3>Селективный импорт given по типу</h3>\n\n<pre><code class=\"language-scala\">object Settings {\n  given maxConnections: Int = 100\n  given connectionTimeout: Int = 5000\n  given appName: String = \"MyApp\"\n}\n\nobject Service {\n  // Импортируем только given типа String\n  import Settings.given String\n  \n  def printInfo()(using name: String): Unit = {\n    println(s\"$name\")\n  }\n  \n  printInfo()  // MyApp \n}\n</code></pre>\n\n<h2 style=\"text-align:center;\">Приоритеты разрешения given</h2>\n\n<p>Когда компилятор ищет контекстное значение, он следует определённым правилам приоритета.</p>\n\n<h3>Правила приоритета (от высшего к низшему):</h3>\n\n<ol>\n\t<li><strong>Локальные given</strong> в текущей области видимости</li>\n\t<li><strong>Унаследованные given</strong> из внешних областей видимости</li>\n\t<li><strong>Импортированные given</strong> (явный импорт)</li>\n\t<li><strong>Given из объекта-компаньона</strong> типа параметра</li>\n\t<li><strong>Given из пакетного объекта</strong></li>\n</ol>\n\n<h3>Пример: Замещение given определений</h3>\n\n<pre><code class=\"language-scala\">// Глобальное определение\ngiven globalValue: Int = 100\n\ndef testPriority(): Unit = {\n  def inner1(): Unit = {\n    // Локальное определение перекрывает глобальное\n    given localValue: Int = 200\n    \n    def useValue()(using value: Int): Unit = {\n      println(s\"Значение: $value\")\n    }\n    \n    useValue()  // Значение: 200 (использует localValue)\n  }\n  \n  def inner2(): Unit = {\n    def useValue()(using value: Int): Unit = {\n      println(s\"Значение: $value\")\n    }\n    \n    useValue()  // Значение: 100 (использует globalValue)\n  }\n  \n  inner1()\n  inner2()\n}\n\ntestPriority()\n</code></pre>\n\n<h2 style=\"text-align:center;\">Given определения с условиями</h2>\n\n<p>Иногда нужно определять контекстные значения в зависимости от условий:</p>\n\n<h3>Пример: Динамическая конфигурация</h3>\n\n<pre><code class=\"language-scala\">def runInEnvironment(env: String): Unit = {\n  // Определяем given в зависимости от окружения\n  given apiEndpoint: String = env match {\n    case \"prod\" =&gt; \"https://api.production.com\"\n    case \"staging\" =&gt; \"https://api.staging.com\"\n    case \"dev\" =&gt; \"http://localhost:8080\"\n    case _ =&gt; \"http://localhost:3000\"\n  }\n  \n  given timeout: Int = env match {\n    case \"prod\" =&gt; 10\n    case _ =&gt; 30\n  }\n  \n  def callApi(path: String)(using endpoint: String, timeout: Int): String = {\n    s\"Вызов $endpoint$path с таймаутом ${timeout}с\"\n  }\n  \n  println(callApi(\"/users\"))\n}\n\nrunInEnvironment(\"prod\")\n// Вызов https://api.production.com/users с таймаутом 10с\n\nrunInEnvironment(\"dev\")\n// Вызов http://localhost:8080/users с таймаутом 30с\n</code></pre>\n\n<h2 style=\"text-align:center;\">Передача контекста через цепочку вызовов</h2>\n\n<p>Одно из главных преимуществ контекстных параметров — автоматическая передача через несколько уровней вызовов.</p>\n\n<h3>Пример: Цепочка логирования</h3>\n\n<pre><code class=\"language-scala\">// Определяем уровень логирования\ngiven logLevel: String = \"INFO\"\n\ndef log(message: String)(using level: String): Unit = {\n  println(s\"[$level] $message\")\n}\n\ndef saveData(data: String)(using level: String): Unit = {\n  log(s\"Начало сохранения данных: $data\")\n  // ... сохранение ...\n  log(\"Данные успешно сохранены\")\n}\n\ndef processRequest(request: String)(using level: String): Unit = {\n  log(s\"Получен запрос: $request\")\n  saveData(request)\n  log(\"Запрос обработан\")\n}\n\ndef handleApi(endpoint: String)(using level: String): Unit = {\n  log(s\"API вызов: $endpoint\")\n  processRequest(endpoint)\n  log(\"API ответ отправлен\")\n}\n\n// Один given передаётся через всю цепочку\nhandleApi(\"/api/users\")\n</code></pre>\n\n<p>Вывод:</p>\n\n<pre><code>[INFO] API вызов: /api/users\n[INFO] Получен запрос: /api/users\n[INFO] Начало сохранения данных: /api/users\n[INFO] Данные успешно сохранены\n[INFO] Запрос обработан\n[INFO] API ответ отправлен\n</code></pre>\n\n<p>Без контекстных параметров пришлось бы явно передавать <code>logLevel</code> через каждую функцию!</p>\n\n<h2 style=\"text-align:center;\">Контекстные параметры и рекурсия</h2>\n\n<p>Контекстные параметры отлично работают с рекурсивными функциями:</p>\n\n<pre><code class=\"language-scala\">given indent: Int = 2\n\ndef printTree(node: String, level: Int)(using indentSize: Int): Unit = {\n  println(\" \" * (level * indentSize) + node)\n}\n\ndef generateHierarchy(name: String, level: Int, maxLevel: Int)\n                     (using indentSize: Int): Unit = {\n  if (level &lt;= maxLevel) {\n    printTree(s\"$name-$level\", level)\n    generateHierarchy(name, level + 1, maxLevel)\n  }\n}\n\ngenerateHierarchy(\"Node\", 0, 3)\n</code></pre>\n\n<p>Вывод:</p>\n\n<pre><code>Node-0\n  Node-1\n    Node-2\n      Node-3\n</code></pre>\n\n<h2 style=\"text-align:center;\">Захват контекстных значений</h2>\n\n<p>Можно получить текущее контекстное значение в любом месте кода с помощью <strong><code>summon</code></strong></p>\n\n<pre><code class=\"language-scala\">given debug: Boolean = true\n\ndef performAction(action: String): Unit = {\n  val debugMode = summon[Boolean]  // Захват контекстного значения\n  \n  if (debugMode) {\n    println(s\"[DEBUG] Выполняется: $action\")\n  }\n  println(s\"Действие '$action' выполнено\")\n}\n\nperformAction(\"сохранение данных\")\n</code></pre>",
    "video" : null,
    "options" : {
      
    },
    "subtitle_files" : [
    ],
    "is_deprecated" : false
  },
  "name" : "text",
  "course_id" : 195883,
  "course_name" : "Функциональная Scala 3 для начинающих",
  "exported_at" : "2025-12-20T22:21:18.6944172"
}