{
  "step_id" : 8665541,
  "lesson_id" : 2041279,
  "position" : 1,
  "type" : "unknown",
  "block" : {
    "name" : "text",
    "text" : "<h1 style=\"text-align:center;\">Контекстные параметры функции</h1>\n\n<p><strong>Контекстные значения</strong> — это именованные или анонимные определения любых <strong>значений</strong>, созданные с ключевым словом <code>given</code>(вместо val), которые формируют <strong>контекстную</strong> (особую)<strong> область видимости</strong> (context scope).</p>\n\n<p><strong>Контекстные параметры</strong> — это параметры функции, для которых компилятор сам находит и подставляет подходящие аргументы в текущей области видимости <strong>контекстных значений</strong>. Такие параметры выделяются в отдельную секцию параметров функции.</p>\n\n<p>Также контекстные значения и параметры можно назвать <strong>неявными</strong>, так как их смысл проникать в функцию неявным образом, то есть, нет необходимости указывать их явно при вызове функции. Термин <strong>контекст -</strong> указывает на архитектурную цель использования таких параметров, то есть передача контекста окружения функции.</p>\n\n<p>Контекстные параметры решают несколько задач:</p>\n\n<ol>\n\t<li><strong>Уменьшение повторяющегося кода</strong> — не нужно явно передавать одни и те же параметры через множество уровней вызовов функций</li>\n\t<li><strong>Моделирование окружения</strong> — можно описать \"контекст выполнения\" (например, конфигурацию, настройки логирования)</li>\n\t<li><strong>Улучшение читаемости</strong> — фокус на важной бизнес-логике, а не на технических деталях передачи параметров</li>\n</ol>\n\n<h2 style=\"text-align:center;\">Синтаксис: ключевые слова <code>using и given</code></h2>\n\n<p>Для определения <strong>контекстных параметров</strong> используется ключевое слово <code>using</code>в отдельной секции параметров функции.</p>\n\n<p>Для определения <strong>контекстных значений</strong> используется ключевое слово <code>given</code> (вместо val). Несмотря на отдельную область видимости контекстных значений, их имена не должны повторять имена обычных значений.</p>\n\n<p>Компилятор производит поиск доступного контекстного значения в соответствии <strong>с типом</strong> контекстного параметра<strong>.</strong></p>\n\n<p>Функция может иметь как обычные, так и контекстные параметры.</p>\n\n<h3>Пример 1: Простейший контекстный параметр</h3>\n\n<pre><code class=\"language-scala\">// Функция с контекстным параметром\ndef greet(name: String)(using language: String): String = \n  language match {\n    case \"ru\" =&gt; s\"Привет, $name!\"\n    case \"en\" =&gt; s\"Hello, $name!\"\n    case \"es\" =&gt; s\"¡Hola, $name!\"\n    case _ =&gt; s\"Hi, $name!\"\n  }\n\n// Определяем контекстное значение\ngiven defaultLanguage: String = \"ru\"\n\n// Вызов функции без явной передачи языка\nval greeting1 = greet(\"Иван\")  // \"Привет, Иван!\"\n\n// Можно явно указать другое значение\nval greeting2 = greet(\"John\")(using \"en\")  // \"Hello, John!\"\n</code></pre>\n\n<p>В этом примере:</p>\n\n<ul>\n\t<li>Параметр <code>language</code> объявлен с ключевым словом <code>using</code></li>\n\t<li>Мы определили <code>given defaultLanguage</code> — контекстное значение типа String</li>\n\t<li>При вызове <code>greet(\"Иван\")</code> компилятор автоматически находит и подставляет <code>defaultLanguage</code></li>\n\t<li>При необходимости можно явно передать значение с помощью <code>using</code></li>\n</ul>\n\n<h2 style=\"text-align:center;\"> Именованные и анонимные given</h2>\n\n<p>Так как при неявной передаче аргумента имя такого значения не важно, то вы можете не давать имена своим <code>given</code> определениям:</p>\n\n<h3>Пример 2: Анонимное given</h3>\n\n<pre><code class=\"language-scala\">// Анонимное given - только неявное использование\ngiven Int = 443\n\ndef connectSecure(host: String)(using port: Int): String = \n  s\"Безопасное подключение к $host:$port\"\n\nprintln(connectSecure(\"example.com\"))  // Безопасное подключение к example.com:443\n\n\n// Именованное given - можно использовать явно\ngiven standardPort: Int = 8080\n\ndef connectToServer(host: String)(using port: Int): String = \n  s\"Подключение к $host:$port\"\n\n// Можно использовать неявно\nprintln(connectToServer(\"localhost\"))  // Подключение к localhost:8080\n\n// Или явно по имени\nprintln(connectToServer(\"localhost\")(using standardPort))</code></pre>\n\n<h3>Пример 3: Контекстные параметры и вычисления</h3>\n\n<pre><code class=\"language-scala\">// Налоговая ставка как контекстный параметр\ndef calculatePrice(basePrice: Double)(using taxRate: Double): Double = \n  basePrice * (1.0 + taxRate)\n\n// Определяем разные налоговые ставки для разных контекстов\ndef calculateInMoscow(): Double = {\n  given Double = 0.20  // НДС 20%\n  calculatePrice(1000.0)\n}\n\ndef calculateInDelaware(): Double = {\n  given Double = 0.0  // Нет налога с продаж\n  calculatePrice(1000.0)\n}\n\nprintln(calculateInMoscow())     // 1200.0\nprintln(calculateInDelaware())   // 1000.0\n</code></pre>\n\n<p>Здесь контекстный параметр <code>taxRate</code> позволяет вычислять цену с учётом разных налоговых ставок в зависимости от контекста.</p>\n\n<h3>Пример 4: Точность вычислений</h3>\n\n<pre><code class=\"language-scala\">// Функция сравнения чисел с плавающей точкой\ndef areEqual(a: Double, b: Double)(using epsilon: Double): Boolean = \n  Math.abs(a - b) &lt; epsilon\n\n// Контекст высокой точности\ndef highPrecisionCalculation(): Unit = {\n  given Double = 0.0001\n  \n  val result1 = 1.0 / 3.0 * 3.0\n  val result2 = 1.0\n  \n  println(areEqual(result1, result2))  // true\n  println(s\"Разница: ${Math.abs(result1 - result2)}\")\n}\n\n// Контекст низкой точности\ndef lowPrecisionCalculation(): Unit = {\n  given Double = 0.01\n  \n  val result1 = 1.005\n  val result2 = 1.008\n  \n  println(areEqual(result1, result2))  // true, разница 0.003 &lt; 0.01\n}\n\nhighPrecisionCalculation()\nlowPrecisionCalculation()\n</code></pre>\n\n<h3>Пример 5: Given с вычисляемым значением</h3>\n\n<pre><code class=\"language-scala\">// Given с вычисляемым значением\ngiven String = {\n  val hour = java.time.LocalTime.now().getHour\n  if (hour &lt; 12) \"Доброе утро\"\n  else if (hour &lt; 18) \"Добрый день\"\n  else \"Добрый вечер\"\n}\n\ndef printGreeting(using greeting: String): Unit =\n  println(greeting)\n\nprintGreeting</code></pre>\n\n<h2 style=\"text-align:center;\">Множественные контекстные параметры</h2>\n\n<p>Функция может иметь несколько контекстных параметров. Все они указываются в одном блоке <code>using</code>.</p>\n\n<h3>Пример 6: Несколько контекстных параметров</h3>\n\n<pre><code class=\"language-scala\">// Функция форматирования числа с учётом локали\ndef formatCurrency(amount: Double)(using \n  currencySymbol: String,\n  decimalPlaces: Int\n): String = {\n  val rounded = BigDecimal(amount).setScale(decimalPlaces, BigDecimal.RoundingMode.HALF_UP)\n  s\"$currencySymbol${rounded.toString}\"\n}\n\n// Русская локаль\ndef formatForRussia(): Unit = {\n  given String = \"₽\"\n  given Int = 2\n  println(formatCurrency(1234.567))  // ₽1234.57\n}\n\n// Американская локаль\ndef formatForUSA(): Unit = {\n  given String = \"$\"\n  given Int = 2\n  println(formatCurrency(1234.567))  // $1234.57\n}\n\n// Научная точность\ndef formatScientific(): Unit = {\n  given String = \"$\"\n  given Int = 6\n  println(formatCurrency(1234.567))  // $1234.567000\n}\n\nformatForRussia()\nformatForUSA()\nformatScientific()</code></pre>\n\n<h3 style=\"text-align:center;\">Проблема множественных контекстных параметров одного типа</h3>\n\n<p>Если мы имеем несколько контекстных параметров одного типа, то компилятор не сможет подобрать какой аргумент к какому параметру подходит, так как он подбирает контекстное значение по типу, и выдаст ошибку компиляции. Однозначно, в списке контекстных параметров не должно быть одинаковых типов!</p>\n\n<p>Решение проблемы это группировка параметров в сложную структуру или создание непрозрачных типов (opaque types - вне рамок данного урока).</p>\n\n<h3>Пример 7: Группировка контекстных параметров</h3>\n\n<pre><code class=\"language-scala\">// Используем Tuple для группировки параметров одного типа\ndef formatCurrency(amount: Double)(using format: (String, String)): String = {\n  val (currencySymbol, decimalSeparator) = format\n  val wholePart = amount.toInt\n  val fractionalPart = ((amount - wholePart) * 100).toInt\n  s\"$currencySymbol$wholePart$decimalSeparator${fractionalPart.toString.padTo(2, '0')}\"\n}\n\n// Русская локаль\ndef formatForRussia(): Unit = {\n  given (String, String) = (\"₽\", \",\")\n  println(formatCurrency(1234.56))  // ₽1234,56\n}\n\n// Американская локаль\ndef formatForUSA(): Unit = {\n  given (String, String) = (\"$\", \".\")\n  println(formatCurrency(1234.56))  // $1234.56\n}\n\nformatForRussia()\nformatForUSA()</code></pre>\n\n<h2 style=\"text-align:center;\">Вызов функций с контекстными параметрами</h2>\n\n<p>Существует три способа вызова функций с контекстными параметрами:</p>\n\n<h3>1. Неявная передача (рекомендуется)</h3>\n\n<pre><code class=\"language-scala\">def process(value: Int)(using multiplier: Int): Int = value * multiplier\n\ngiven Int = 10\nprintln(process(5))  // 50\n</code></pre>\n\n<h3>2. Явная передача с <code>using</code></h3>\n\n<pre><code class=\"language-scala\">println(process(5)(using 20))  // 100\n</code></pre>\n\n<h3>3. Явная именованная передача</h3>\n\n<pre><code class=\"language-scala\">println(process(5)(using multiplier = 15))  // 75\n</code></pre>",
    "video" : null,
    "options" : {
      
    },
    "subtitle_files" : [
    ],
    "is_deprecated" : false
  },
  "name" : "text",
  "course_id" : 195883,
  "course_name" : "Функциональная Scala 3 для начинающих",
  "exported_at" : "2026-01-10T10:17:16.8072709"
}