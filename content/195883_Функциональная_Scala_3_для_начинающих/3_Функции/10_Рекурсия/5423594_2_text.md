# Материал (Шаг 2)

## Информация о шаге

- **ID шага**: 5423594
- **Позиция**: 2
- **Тип**: text
- **Курс**: Функциональная Scala 3 для начинающих
- **Экспортирован**: 2025-12-20T22:21:12.7046609

## Содержание

# Прямая рекурсия

Рекурсия - это **алгоритмический прием**, поэтому опишем её алгоритмической диаграммой.

Минимальная **прямая** (линейная) рекурсия выглядит следующим образом.

![Изображение](https://ucarecdn.com/6d35900b-5a94-423d-b7c1-9da61e6bead0/)

В теле функции обязательно должны быть минимум **две ветки** вычислений. Одна из веток должна быть обязательно **без вызова** рекурсивной функции. Другая ветка должна иметь **единственный** вызов рекурсивной функции.

Кроме того, для выполнения преобразовании данных в функции до вызова и/или после вызова, должны присутствовать **выражения**.

Выражение, **до входа** на следующий уровень рекурсии (выражение 1), называется **на прямом ходу рекурсии** , а выражение, по возврату с более глубокого уровня к текущему (выражение 2), – **на обратном ходу рекурсии**.

**Логическое условие** должно обеспечивать условие завершения рекурсии.

Таким образом, сначала происходит вычисление всех выражений 1 и вход во все рекурсивные функции в прямой последовательности, далее на каком-то этапе срабатывает ветка выхода, и в обратной последовательности вычисляются выражения 2, вплоть до первичной функции, выход из которой будет означать окончание рекурсивного вычисления.

Пример прямой рекурсии, возведение в степень целого числа с использованием умножения:

def power(base: Int, exponent: Int): Int = {
if exponent == 0 then
// Базовый случай: любое число в степени 0 равно 1
1
else
// Рекурсивный случай: base_в_степени_exponent = base * base в степени (exponent-1)
val nextExponent = exponent - 1 // выражение на прямом ходу рекурсии
val res = power(base, nextExponent) // рекурсивный вызов функции
base * res // выражение на обратном ходу рекурсии
}

Последовательность действий будет следующей. Для начала рекурсии вызывается функция `power`, в которой устанавливаются требуемые аргументы. Если экспонента не ноль, вызывается та же функция `power`, при этом аргумент экспоненты уменьшается на единицу. В этот момент вычисляется выражение (exponent - 1) на прямом ходу рекурсии . Так происходит до тех пор, пока значение экспоненты в следующей функции не достигнет нуля, и все вызванные функции не начнут выдавать свои значения. Перед выдачей значения, функции вычисляют выражением (base * power) на обратном ходу рекурсии. В конечно счете последнее итоговое значение выдаст функция, которая вызвалась первой.

Последовательность шагов с промежуточными значениями:

power(2, 3)
exponent - 1 = 2
power(2, 2)
exponent - 1 = 1
power(2, 1)
exponent - 1 = 0
power(2, 0)
выход из функции со значением 1
2 * 1
выход из функции со значением 2
2 * 2
выход из функции со значением 4
2 * 4
выход из функции со значением 8
результат 8



Другой пример. Вычисление факториала числа.

def factorial(n: Int): Int = {
if n == 0 then
1
else
n * factorial(n - 1)
}

Если `n` равно 0, функция возвращает 1. В противном случае, функция использует прямую рекурсию, вызывая саму себя с аргументом `n - 1` и умножая на обратном ходу результат на `n`.



Более полная алгоритмическая диаграмма прямая рекурсия имеет следующую структуру.

![Изображение](https://ucarecdn.com/42c6cb75-f4e9-4517-a5c8-bcf15191b8b0/)

Мы можем иметь несколько рекурсивных веток, и в каждой ветке по одному рекурсивному вызову. Это будет все еще прямая рекурсия, только с разными выражениями в каждой рекурсивной ветке.

Пример прямой рекурсии, возведение в степень целого числа с логарифмическим временем выполнения:

def powerLogarithmic(base: Int, exponent: Int): Int = {
if exponent == 0 then
// Базовый случай: любое число в степени 0 равно 1
1
else if exponent % 2 == 0 then
// Если степень чётная, вычисляем base в степени (exponent/2) и возводим в квадрат
val halfPower = powerLogarithmic(base, exponent / 2)
halfPower * halfPower
else
// Иначе, если степень нечётная, вычисляем base в степени ((exponent-1)/2) и возводим в квадрат,
// затем умножаем на base
val halfPower = powerLogarithmic(base, (exponent - 1) / 2)
base * halfPower * halfPower
}

В данном примере чуть сложнее математика, и рекурсия разложена по двум веткам. Принцип работы такой рекурсии аналогичен другим прямым рекурсиям.

---

### Полные данные JSON

<details>
<summary>Показать JSON данные</summary>

```json
{
  "name" : "text",
  "text" : "<h1 style=\"text-align:center;\">Прямая рекурсия</h1>\n\n<p>Рекурсия - это <strong>алгоритмический прием</strong>, поэтому опишем её алгоритмической диаграммой.</p>\n\n<p>Минимальная <strong>прямая</strong> (линейная) рекурсия выглядит следующим образом.</p>\n\n<p style=\"text-align:center;\"><img alt=\"\" height=\"242\" name=\"Диаграмма без названия.drawio(5).png\" src=\"https://ucarecdn.com/6d35900b-5a94-423d-b7c1-9da61e6bead0/\" width=\"717\"></p>\n\n<p>В теле функции обязательно должны быть минимум <strong>две ветки</strong> вычислений. Одна из веток должна быть обязательно <strong>без&nbsp; вызова</strong> рекурсивной функции. Другая ветка должна иметь <strong>единственный</strong> вызов рекурсивной функции.</p>\n\n<p>Кроме того, для выполнения преобразовании данных в функции до вызова и/или после вызова, должны присутствовать <strong>выражения</strong>.</p>\n\n<p>Выражение, <strong>до входа</strong> на следующий уровень рекурсии (выражение 1), называется <strong>на прямом ходу рекурсии</strong> , а выражение, по возврату с более глубокого уровня к текущему (выражение 2), – <strong>на обратном ходу рекурсии</strong>.</p>\n\n<p><strong>Логическое условие</strong> должно обеспечивать условие завершения рекурсии.</p>\n\n<p>Таким образом, сначала происходит вычисление всех выражений 1 и вход во все рекурсивные функции в прямой последовательности, далее на каком-то этапе срабатывает ветка выхода, и в обратной последовательности вычисляются выражения 2, вплоть до первичной функции, выход из которой будет означать окончание рекурсивного вычисления.</p>\n\n<p>Пример прямой рекурсии, возведение в степень целого числа с использованием умножения:</p>\n\n<pre><code class=\"language-scala\">def power(base: Int, exponent: Int): Int = {\n  if exponent == 0 then \n  // Базовый случай: любое число в степени 0 равно 1\n    1\n  else\n  // Рекурсивный случай: base_в_степени_exponent = base * base в степени (exponent-1)\n    val nextExponent = exponent - 1 // выражение на прямом ходу рекурсии\n    val res = power(base, nextExponent) // рекурсивный вызов функции\n    base * res // выражение на обратном ходу рекурсии\n}</code></pre>\n\n<p>Последовательность действий будет следующей. Для начала рекурсии вызывается функция <code>power</code>, в которой устанавливаются требуемые аргументы. Если экспонента не ноль, вызывается та же функция <code>power</code>, при этом аргумент экспоненты уменьшается на единицу. В этот момент вычисляется выражение (exponent - 1) на прямом ходу рекурсии .&nbsp; Так происходит до тех пор, пока значение экспоненты в следующей функции не достигнет нуля, и все вызванные функции не начнут выдавать свои значения. Перед выдачей значения, функции вычисляют выражением (base * power) на обратном ходу рекурсии. В конечно счете последнее итоговое значение выдаст функция, которая вызвалась первой.</p>\n\n<p>Последовательность шагов с промежуточными значениями:</p>\n\n<pre><code class=\"language-no-highlight\">power(2, 3)\n  exponent - 1 = 2\n  power(2, 2)\n    exponent - 1 = 1\n    power(2, 1)\n      exponent - 1 = 0\n      power(2, 0)\n        выход из функции со значением 1\n      2 * 1\n      выход из функции со значением 2\n    2 * 2\n    выход из функции со значением 4\n  2 * 4\n  выход из функции со значением 8\nрезультат 8</code></pre>\n\n<p>&nbsp;</p>\n\n<p>Другой пример. Вычисление факториала числа.</p>\n\n<pre><code class=\"language-scala\">def factorial(n: Int): Int = {\n  if n == 0 then \n    1\n  else \n    n * factorial(n - 1)\n}</code></pre>\n\n<p><span style=\"background-color:#ffffff; color:#0d0d0d; font-size:16px; text-align:start;\">Если </span><code style=\"background-color:#ffffff; border:0px solid #e3e3e3; color:#0d0d0d; font-size:0.875em; text-align:start;\">n</code><span style=\"background-color:#ffffff; color:#0d0d0d; font-size:16px; text-align:start;\"> равно 0, функция возвращает 1. В противном случае, функция использует прямую рекурсию, вызывая саму себя с аргументом </span><code style=\"background-color:#ffffff; border:0px solid #e3e3e3; color:#0d0d0d; font-size:0.875em; text-align:start;\">n - 1</code><span style=\"background-color:#ffffff; color:#0d0d0d; font-size:16px; text-align:start;\"> и умножая на обратном ходу результат на </span><code style=\"background-color:#ffffff; border:0px solid #e3e3e3; color:#0d0d0d; font-size:0.875em; text-align:start;\">n</code><span style=\"background-color:#ffffff; color:#0d0d0d; font-size:16px; text-align:start;\">.</span></p>\n\n<p>&nbsp;</p>\n\n<p>Более полная алгоритмическая диаграмма прямая рекурсия имеет следующую структуру.</p>\n\n<p style=\"text-align:center;\"><img alt=\"\" height=\"332\" name=\"Диаграмма без названия.drawio(6).png\" src=\"https://ucarecdn.com/42c6cb75-f4e9-4517-a5c8-bcf15191b8b0/\" width=\"717\"></p>\n\n<p>Мы можем иметь несколько рекурсивных веток, и в каждой ветке по одному рекурсивному вызову. Это будет все еще прямая рекурсия, только с разными выражениями в каждой рекурсивной ветке.</p>\n\n<p>Пример прямой рекурсии, возведение в степень целого числа с логарифмическим временем выполнения:</p>\n\n<pre><code class=\"language-scala\">def powerLogarithmic(base: Int, exponent: Int): Int = {\n  if exponent == 0 then\n    // Базовый случай: любое число в степени 0 равно 1\n    1\n  else if exponent % 2 == 0 then\n    // Если степень чётная, вычисляем base в степени (exponent/2) и возводим в квадрат\n    val halfPower = powerLogarithmic(base, exponent / 2)\n    halfPower * halfPower\n  else\n    // Иначе, если степень нечётная, вычисляем base в степени ((exponent-1)/2) и возводим в квадрат,\n    // затем умножаем на base\n    val halfPower = powerLogarithmic(base, (exponent - 1) / 2)\n    base * halfPower * halfPower\n}</code></pre>\n\n<p>В данном примере чуть сложнее математика, и рекурсия разложена по двум веткам. Принцип работы такой рекурсии аналогичен другим прямым рекурсиям.</p>",
  "video" : null,
  "options" : {
    
  },
  "subtitle_files" : [
  ],
  "is_deprecated" : false
}
```

</details>
