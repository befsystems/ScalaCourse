{
  "step_id" : 5423593,
  "lesson_id" : 1228711,
  "position" : 6,
  "type" : "unknown",
  "block" : {
    "name" : "text",
    "text" : "<h1 style=\"text-align:center;\">Хвостовая рекурсия</h1>\n\n<p>Минимальная хвостовая рекурсия выглядит следующим образом:</p>\n\n<p style=\"text-align:center;\"><img alt=\"\" height=\"252\" name=\"Диаграмма без названия.drawio(8).png\" src=\"https://ucarecdn.com/cda4bf5e-ffe7-4351-a5de-5060765ff572/\" width=\"627\"></p>\n\n<p>Хвостовой она названа потому, что рекурсивный вызов всегда выполняется в <strong>самом конце</strong> функции. Выражение на обратном ходу рекурсии <strong>отсутствует</strong>.</p>\n\n<p>Пример хвостовой рекурсии для нахождения минимального символа в строке по отношению к заданному:</p>\n\n<pre><code class=\"language-scala\">def findMinChar(str: String, minChar: Char): Char = {\n  if str.isEmpty then \n    minChar // Базовый случай: если строка пустая, возвращаем минимальный символ\n  else\n    val newMinChar = if str.head &lt; minChar then // Сравниваем текущий символ с минимальным\n      str.head \n    else \n      minChar \n    findMinChar(str.tail, newMinChar) // Рекурсивный случай: продолжаем сравнивать со следующим символом\n}</code></pre>\n\n<p>&nbsp;</p>\n\n<p>Хотя диаграмма хвостовой рекурсии выглядит проще из за отсутствия второго выражения, на деле сам алгоритм функции может усложниться&nbsp;и быть менее понятным. Могут появиться&nbsp;вспомогательные параметры функции.</p>\n\n<p>Пример вычисления факториала хвостовой рекурсией, нужен дополнительный параметр для промежуточного аккумулятора (сравните с реализацией прямой рекурсией):</p>\n\n<pre><code class=\"language-scala\">def tailFactorial(n: Int, acc: Int): Int = {\n  if n &lt;= 1 then {\n    acc // Базовый случай: если n достигло 1 или меньше, возвращаем аккумулятор\n  else\n    tailFactorial(n - 1, n * acc) // Рекурсивный вызов с обновлением аккумулятора\n}\n\nval res = tailFactorial(n, 1) // Инициализация аккумулятора и вызов функции</code></pre>\n\n<p>&nbsp;</p>\n\n<p>Пример рекурсивного вычисление числа Pi <span style=\"background-color:#ffffff; color:#0d0d0d; font-size:16px; text-align:start;\">по формуле Лейбница:</span></p>\n\n<p><img alt=\"\" height=\"44\" name=\"изображение.png\" src=\"https://ucarecdn.com/73f98cb4-a9e2-4a6d-be22-ef5a22e68362/\" width=\"320\"></p>\n\n<pre><code class=\"language-scala\">def calculatePi(iterations: Int, count: Int, accumulator: Double): Double = {\n  if count &gt;= iterations then\n    accumulator * 4\n  else\n    val nextTerm = 1.0 / (2 * count + 3) * (if count % 2 == 0 then -1 else 1)\n    calculatePi(iterations, count + 1, accumulator + nextTerm)\n}\n\nval pi = calculatePi(1000000, 0, 1.0)\n\n</code></pre>\n\n<p>здесь параметр iterations задает глубину рекурсии, что определяет точность числа Pi. Параметр count является промежуточным счетчиком, а accumulator является промежуточным хранилищем числа Pi, и при запуске в него устанавливается значение первого элемента последовательности.</p>\n\n<p>&nbsp;</p>\n\n<p>Более полная алгоритмическая диаграмма хвостовой рекурсия имеет следующую структуру:</p>\n\n<p style=\"text-align:center;\"><img alt=\"\" height=\"409\" name=\"Диаграмма без названия.drawio(9).png\" src=\"https://ucarecdn.com/b0cc6cab-f28e-478a-9f0c-80a4cbb3d5cf/\" width=\"627\"></p>\n\n<p>&nbsp;</p>\n\n<p>Пример реализации алгоритма Евклида.</p>\n\n<p>Один из первых алгоритмов в истории известен как алгоритм Евклида, названный в честь древнегреческого математика Евклида, который описал его в своих «Началах» (прибл. 300 год до н. э.). Его цель – найти наибольший общий делитель (greatest common divisor, gcd) , или сокращённо НОД, двух неотрицательных ненулевых целых чисел m и n,<br>\nто есть наибольшее положительное целое число k, на которое делятся без остатка и m, и n (очевидно, m/k и n/k – целые числа). Например, НОД(20, 24) = 4.<br style=\"font-variant:normal; text-align:-webkit-auto;\">\n&nbsp;</p>\n\n<pre><code class=\"language-scala\">def gcd(m: Int, n: Int): Int = {\n  if m == 0 then\n    n\n  else if m &gt; n then\n    gcd(n, m)    // первая рекурсивная ветка\n  else\n    gcd(m, n - m)// вторая рекурсивная ветка\n}</code></pre>\n\n<p>&nbsp;</p>\n\n<p>Хвостовые рекурсии легко <strong>оптимизируются </strong>компилятором в <strong>цикл</strong>, что позволяет не использовать стек памяти в вычислениях, и не бороться с глубиной рекурсии.</p>\n\n<p>Теоретически любую рекурсию можно преобразовать в хвостовую, но после преобразования алгоритм такой рекурсии сильно <strong>усложняется</strong>, что негативно сказывается на сопровождении такой функции.</p>",
    "video" : null,
    "options" : {
      
    },
    "subtitle_files" : [
    ],
    "is_deprecated" : false
  },
  "name" : "text",
  "course_id" : 195883,
  "course_name" : "Функциональная Scala 3 для начинающих",
  "exported_at" : "2025-12-20T22:21:12.709125"
}