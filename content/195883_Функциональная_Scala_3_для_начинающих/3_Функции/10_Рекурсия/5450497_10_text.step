{
  "step_id" : 5450497,
  "lesson_id" : 1228711,
  "position" : 10,
  "type" : "unknown",
  "block" : {
    "name" : "text",
    "text" : "<h1 style=\"text-align: center;\">Взаимная рекурсия</h1>\n\n<p>Функция, явно вызывающий сама себя, рекурсивна. Однако рекурсивная функция не обязательно вызывает себя явно. Она может быть вызвана в другой функции, которая, в свою очередь, была вызвана первоначальной функцией. Рекурсивный вызов производиться через цепочку вызовов разных функций. Такой тип рекурсии называют взаимной, или косвенной, рекурсией.</p>\n\n<p>Диаграмма некого алгоритма, построенного на взаимной рекурсии функций.<br style=\"font-variant: normal; text-align: -webkit-auto;\">\n&nbsp;</p>\n\n<p style=\"text-align: center;\"><img alt=\"\" height=\"196\" name=\"изображение.png\" src=\"https://ucarecdn.com/f8e99020-363e-4a61-9a3a-6121efc714de/\" width=\"245\"></p>\n\n<p>Как можно заметить, такой алгоритм может быть похож на сложно обнаруживаемую ошибку закольцовывания вызова функций. Такие алгоритмы обычно масштабны и распределены, поэтому при реализации требуют хорошего пояснения и документирования кода.</p>\n\n<p>Пример взаимной рекурсии для определения четности числа:</p>\n\n<pre><code class=\"language-scala\">def is_even(n: Int): Boolean =\n  if n == 0 then\n    true\n  else\n    is_odd(n - 1)\n\ndef is_odd(n: Int): Boolean =\n  if n == 0 then\n    false\n  else\n    is_even(n - 1)</code></pre>",
    "video" : null,
    "options" : {
      
    },
    "subtitle_files" : [
    ],
    "is_deprecated" : false
  },
  "name" : "text",
  "course_id" : 195883,
  "course_name" : "Функциональная Scala 3 для начинающих",
  "exported_at" : "2026-01-10T10:17:13.7887645"
}