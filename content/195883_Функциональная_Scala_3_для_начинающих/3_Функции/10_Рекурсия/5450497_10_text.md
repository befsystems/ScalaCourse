# Материал (Шаг 10)

## Информация о шаге

- **ID шага**: 5450497
- **Позиция**: 10
- **Тип**: text
- **Курс**: Функциональная Scala 3 для начинающих
- **Экспортирован**: 2026-01-10T10:17:13.7897563

## Содержание

# Взаимная рекурсия

Функция, явно вызывающий сама себя, рекурсивна. Однако рекурсивная функция не обязательно вызывает себя явно. Она может быть вызвана в другой функции, которая, в свою очередь, была вызвана первоначальной функцией. Рекурсивный вызов производиться через цепочку вызовов разных функций. Такой тип рекурсии называют взаимной, или косвенной, рекурсией.

Диаграмма некого алгоритма, построенного на взаимной рекурсии функций.


![Изображение](https://ucarecdn.com/f8e99020-363e-4a61-9a3a-6121efc714de/)

Как можно заметить, такой алгоритм может быть похож на сложно обнаруживаемую ошибку закольцовывания вызова функций. Такие алгоритмы обычно масштабны и распределены, поэтому при реализации требуют хорошего пояснения и документирования кода.

Пример взаимной рекурсии для определения четности числа:

def is_even(n: Int): Boolean =
if n == 0 then
true
else
is_odd(n - 1)

def is_odd(n: Int): Boolean =
if n == 0 then
false
else
is_even(n - 1)

---

### Полные данные JSON

<details>
<summary>Показать JSON данные</summary>

```json
{
  "name" : "text",
  "text" : "<h1 style=\"text-align: center;\">Взаимная рекурсия</h1>\n\n<p>Функция, явно вызывающий сама себя, рекурсивна. Однако рекурсивная функция не обязательно вызывает себя явно. Она может быть вызвана в другой функции, которая, в свою очередь, была вызвана первоначальной функцией. Рекурсивный вызов производиться через цепочку вызовов разных функций. Такой тип рекурсии называют взаимной, или косвенной, рекурсией.</p>\n\n<p>Диаграмма некого алгоритма, построенного на взаимной рекурсии функций.<br style=\"font-variant: normal; text-align: -webkit-auto;\">\n&nbsp;</p>\n\n<p style=\"text-align: center;\"><img alt=\"\" height=\"196\" name=\"изображение.png\" src=\"https://ucarecdn.com/f8e99020-363e-4a61-9a3a-6121efc714de/\" width=\"245\"></p>\n\n<p>Как можно заметить, такой алгоритм может быть похож на сложно обнаруживаемую ошибку закольцовывания вызова функций. Такие алгоритмы обычно масштабны и распределены, поэтому при реализации требуют хорошего пояснения и документирования кода.</p>\n\n<p>Пример взаимной рекурсии для определения четности числа:</p>\n\n<pre><code class=\"language-scala\">def is_even(n: Int): Boolean =\n  if n == 0 then\n    true\n  else\n    is_odd(n - 1)\n\ndef is_odd(n: Int): Boolean =\n  if n == 0 then\n    false\n  else\n    is_even(n - 1)</code></pre>",
  "video" : null,
  "options" : {
    
  },
  "subtitle_files" : [
  ],
  "is_deprecated" : false
}
```

</details>
