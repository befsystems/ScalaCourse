{
  "step_id" : 5423594,
  "lesson_id" : 1228711,
  "position" : 2,
  "type" : "unknown",
  "block" : {
    "name" : "text",
    "text" : "<h1 style=\"text-align:center;\">Прямая рекурсия</h1>\n\n<p>Рекурсия - это <strong>алгоритмический прием</strong>, поэтому опишем её алгоритмической диаграммой.</p>\n\n<p>Минимальная <strong>прямая</strong> (линейная) рекурсия выглядит следующим образом.</p>\n\n<p style=\"text-align:center;\"><img alt=\"\" height=\"242\" name=\"Диаграмма без названия.drawio(5).png\" src=\"https://ucarecdn.com/6d35900b-5a94-423d-b7c1-9da61e6bead0/\" width=\"717\"></p>\n\n<p>В теле функции обязательно должны быть минимум <strong>две ветки</strong> вычислений. Одна из веток должна быть обязательно <strong>без&nbsp; вызова</strong> рекурсивной функции. Другая ветка должна иметь <strong>единственный</strong> вызов рекурсивной функции.</p>\n\n<p>Кроме того, для выполнения преобразовании данных в функции до вызова и/или после вызова, должны присутствовать <strong>выражения</strong>.</p>\n\n<p>Выражение, <strong>до входа</strong> на следующий уровень рекурсии (выражение 1), называется <strong>на прямом ходу рекурсии</strong> , а выражение, по возврату с более глубокого уровня к текущему (выражение 2), – <strong>на обратном ходу рекурсии</strong>.</p>\n\n<p><strong>Логическое условие</strong> должно обеспечивать условие завершения рекурсии.</p>\n\n<p>Таким образом, сначала происходит вычисление всех выражений 1 и вход во все рекурсивные функции в прямой последовательности, далее на каком-то этапе срабатывает ветка выхода, и в обратной последовательности вычисляются выражения 2, вплоть до первичной функции, выход из которой будет означать окончание рекурсивного вычисления.</p>\n\n<p>Пример прямой рекурсии, возведение в степень целого числа с использованием умножения:</p>\n\n<pre><code class=\"language-scala\">def power(base: Int, exponent: Int): Int = {\n  if exponent == 0 then \n  // Базовый случай: любое число в степени 0 равно 1\n    1\n  else\n  // Рекурсивный случай: base_в_степени_exponent = base * base в степени (exponent-1)\n    val nextExponent = exponent - 1 // выражение на прямом ходу рекурсии\n    val res = power(base, nextExponent) // рекурсивный вызов функции\n    base * res // выражение на обратном ходу рекурсии\n}</code></pre>\n\n<p>Последовательность действий будет следующей. Для начала рекурсии вызывается функция <code>power</code>, в которой устанавливаются требуемые аргументы. Если экспонента не ноль, вызывается та же функция <code>power</code>, при этом аргумент экспоненты уменьшается на единицу. В этот момент вычисляется выражение (exponent - 1) на прямом ходу рекурсии .&nbsp; Так происходит до тех пор, пока значение экспоненты в следующей функции не достигнет нуля, и все вызванные функции не начнут выдавать свои значения. Перед выдачей значения, функции вычисляют выражением (base * power) на обратном ходу рекурсии. В конечно счете последнее итоговое значение выдаст функция, которая вызвалась первой.</p>\n\n<p>Последовательность шагов с промежуточными значениями:</p>\n\n<pre><code class=\"language-no-highlight\">power(2, 3)\n  exponent - 1 = 2\n  power(2, 2)\n    exponent - 1 = 1\n    power(2, 1)\n      exponent - 1 = 0\n      power(2, 0)\n        выход из функции со значением 1\n      2 * 1\n      выход из функции со значением 2\n    2 * 2\n    выход из функции со значением 4\n  2 * 4\n  выход из функции со значением 8\nрезультат 8</code></pre>\n\n<p>&nbsp;</p>\n\n<p>Другой пример. Вычисление факториала числа.</p>\n\n<pre><code class=\"language-scala\">def factorial(n: Int): Int = {\n  if n == 0 then \n    1\n  else \n    n * factorial(n - 1)\n}</code></pre>\n\n<p><span style=\"background-color:#ffffff; color:#0d0d0d; font-size:16px; text-align:start;\">Если </span><code style=\"background-color:#ffffff; border:0px solid #e3e3e3; color:#0d0d0d; font-size:0.875em; text-align:start;\">n</code><span style=\"background-color:#ffffff; color:#0d0d0d; font-size:16px; text-align:start;\"> равно 0, функция возвращает 1. В противном случае, функция использует прямую рекурсию, вызывая саму себя с аргументом </span><code style=\"background-color:#ffffff; border:0px solid #e3e3e3; color:#0d0d0d; font-size:0.875em; text-align:start;\">n - 1</code><span style=\"background-color:#ffffff; color:#0d0d0d; font-size:16px; text-align:start;\"> и умножая на обратном ходу результат на </span><code style=\"background-color:#ffffff; border:0px solid #e3e3e3; color:#0d0d0d; font-size:0.875em; text-align:start;\">n</code><span style=\"background-color:#ffffff; color:#0d0d0d; font-size:16px; text-align:start;\">.</span></p>\n\n<p>&nbsp;</p>\n\n<p>Более полная алгоритмическая диаграмма прямая рекурсия имеет следующую структуру.</p>\n\n<p style=\"text-align:center;\"><img alt=\"\" height=\"332\" name=\"Диаграмма без названия.drawio(6).png\" src=\"https://ucarecdn.com/42c6cb75-f4e9-4517-a5c8-bcf15191b8b0/\" width=\"717\"></p>\n\n<p>Мы можем иметь несколько рекурсивных веток, и в каждой ветке по одному рекурсивному вызову. Это будет все еще прямая рекурсия, только с разными выражениями в каждой рекурсивной ветке.</p>\n\n<p>Пример прямой рекурсии, возведение в степень целого числа с логарифмическим временем выполнения:</p>\n\n<pre><code class=\"language-scala\">def powerLogarithmic(base: Int, exponent: Int): Int = {\n  if exponent == 0 then\n    // Базовый случай: любое число в степени 0 равно 1\n    1\n  else if exponent % 2 == 0 then\n    // Если степень чётная, вычисляем base в степени (exponent/2) и возводим в квадрат\n    val halfPower = powerLogarithmic(base, exponent / 2)\n    halfPower * halfPower\n  else\n    // Иначе, если степень нечётная, вычисляем base в степени ((exponent-1)/2) и возводим в квадрат,\n    // затем умножаем на base\n    val halfPower = powerLogarithmic(base, (exponent - 1) / 2)\n    base * halfPower * halfPower\n}</code></pre>\n\n<p>В данном примере чуть сложнее математика, и рекурсия разложена по двум веткам. Принцип работы такой рекурсии аналогичен другим прямым рекурсиям.</p>",
    "video" : null,
    "options" : {
      
    },
    "subtitle_files" : [
    ],
    "is_deprecated" : false
  },
  "name" : "text",
  "course_id" : 195883,
  "course_name" : "Функциональная Scala 3 для начинающих",
  "exported_at" : "2026-01-10T10:17:13.7644619"
}