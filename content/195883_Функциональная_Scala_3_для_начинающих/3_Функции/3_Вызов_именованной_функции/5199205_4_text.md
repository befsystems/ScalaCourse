# Материал (Шаг 4)

## Информация о шаге

- **ID шага**: 5199205
- **Позиция**: 4
- **Тип**: text
- **Курс**: Функциональная Scala 3 для начинающих
- **Экспортирован**: 2026-01-10T10:17:19.8096068

## Содержание

# Согласование типов параметров и аргументов функции

При вызове функций необходимо, чтобы типы параметров функции **совпадали** с типом подставляемых аргументов.

Пример:

def add(x: Int, y: Double): Double = x + y

val arg1: Int = 1
val arg2: Double = 1.0
val res = add(arg1, arg2) // тип аргументов и параметров совпадает

Если аргументы имеют типы **отличающиеся** от типов параметров функции, то это указывает то, что возможно была выбрана** неподходящая **функция для выполнения вычисления.

Однако, если более подходящей функции нет, то придется изменить тип аргументов при их подстановке в функцию. Такое действие называется **приведение типа**.

Пример:

def add(x: Int, y: Double): Double = x + y

val arg1: Double = 1.0
val arg2: Int = 1
val res = add(arg1.toInt, arg2.toDouble) // тип аргументов и параметров приведены в соответствие

где операции **toInt** и **toDouble** - это операции приведения типа.

Названия всех операций приведения типа начинаются с приставки **to**.

Операции приведения типа могут быть **опасными** и **безопасными**.

## Безопасные операции приведения типов

**Безопасные** операции приведения типа подразумевают преобразование типа, которое всегда выполняется успешно, **вне зависимости от значения**.

Пример:

val int: Int = 1 // любое значение типа Int
val doub: Double = int.toDouble // безопасное преобразование

В данном примере, каким бы ни было значение **int**, операция **toDouble** всегда вернет значение типа **Double**, так как все значения типа **Int**, являются подмножеством типа **Double**.

Безопасность приведения типа для простых типов и типа `String` можно определить по диаграмме, где стрелками показаны безопасные преобразования:

Byte -> Short -> Int -> Long -> Float -> Double -> String
Char -> Int -> Char -> String

Все типы левее можно безопасно преобразовать во все типы правее. Например: `Byte -> Double`- это безопасно.

Все безопасные приведения можно **не указывать** явно.

Пример:

val int: Int = 1 // любое значение типа Int
val doub: Double = int // безопасное преобразование. Можно не указывать toDouble

## Опасные операции приведения типов

**Опасные** операции приведения типа могут закончится **ошибкой** или **изменением** значения.

Пример:

val doub: Double = 1.9 // опасность зависит от значения
val int: Int = doub.toInt // опасное преобразование

В данном примере значение **int** будет **1**, а не 1.9, так как 1.9 не может быть представлено целым числом. Тип **Double** не является подмножеством типа **Int**. Значение изменено при приведении типа.

Другой пример:

val doub: Double = Double.NaN // опасность зависит от значения
val int: Int = doub.toInt // опасное преобразование

В данном примере значение **int** будет **0**, а не NaN (не число), так как NaN не может быть представлено целым числом. Значение изменено при приведении типа.

Еще пример:

val str: String = "a12" // опасность зависит от значения
val int: Int = str.toInt // опасное преобразование

В данном примере произойдет **ошибка** преобразования, так как "a12" не может быть представлено целым числом.

Таким образом, при использовании опасных преобразований вы должны или **согласится с возможностью изменения значения** в ходе преобразования, или заранее обеспечить **только подходящие значения** для преобразования.

---

### Полные данные JSON

<details>
<summary>Показать JSON данные</summary>

```json
{
  "name" : "text",
  "text" : "<h1 style=\"text-align:center;\">Согласование типов параметров и аргументов функции</h1>\n\n<p>При вызове функций необходимо, чтобы типы параметров функции <strong>совпадали</strong> с типом подставляемых аргументов.</p>\n\n<p>Пример:</p>\n\n<pre><code class=\"language-scala\">def add(x: Int, y: Double): Double = x + y\n\nval arg1: Int = 1\nval arg2: Double = 1.0\nval res = add(arg1, arg2) // тип аргументов и параметров совпадает</code></pre>\n\n<p>Если аргументы имеют типы <strong>отличающиеся</strong> от типов параметров функции, то это указывает то, что возможно была выбрана<strong> неподходящая </strong>функция для выполнения вычисления.</p>\n\n<p>Однако, если более подходящей функции нет, то придется изменить тип аргументов при их подстановке в функцию. Такое действие называется <strong>приведение типа</strong>.</p>\n\n<p>Пример:</p>\n\n<pre><code class=\"language-scala\">def add(x: Int, y: Double): Double = x + y\n\nval arg1: Double = 1.0\nval arg2: Int = 1\nval res = add(arg1.toInt, arg2.toDouble) // тип аргументов и параметров приведены в соответствие</code></pre>\n\n<p>где операции <strong>toInt</strong> и <strong>toDouble</strong> - это операции приведения типа.</p>\n\n<p>Названия всех операций приведения типа начинаются с приставки <strong>to</strong>.</p>\n\n<p>Операции приведения типа могут быть <strong>опасными</strong> и <strong>безопасными</strong>.</p>\n\n<h2 style=\"text-align:center;\">Безопасные операции приведения типов</h2>\n\n<p><strong>Безопасные</strong> операции приведения типа подразумевают преобразование типа, которое всегда выполняется успешно, <strong>вне зависимости от значения</strong>.</p>\n\n<p>Пример:</p>\n\n<pre><code class=\"language-scala\">val int: Int = 1 // любое значение типа Int\nval doub: Double = int.toDouble  // безопасное преобразование</code></pre>\n\n<p>В данном примере, каким бы ни было значение <strong>int</strong>, операция <strong>toDouble</strong> всегда вернет значение типа <strong>Double</strong>, так как все значения типа <strong>Int</strong>, являются подмножеством типа <strong>Double</strong>.</p>\n\n<p>Безопасность приведения типа для простых типов и типа <code>String</code> можно определить по диаграмме, где стрелками показаны безопасные преобразования:</p>\n\n<pre><code class=\"language-scala\">Byte -&gt; Short -&gt; Int -&gt; Long -&gt; Float -&gt; Double -&gt; String\n         Char -&gt; Int -&gt; Char -&gt; String</code></pre>\n\n<p>Все типы левее можно безопасно преобразовать во все типы правее. Например: <code>Byte -&gt; Double</code>- это безопасно.</p>\n\n<p>Все безопасные приведения можно <strong>не указывать</strong> явно.</p>\n\n<p>Пример:</p>\n\n<pre><code class=\"language-scala\">val int: Int = 1 // любое значение типа Int\nval doub: Double = int // безопасное преобразование. Можно не указывать toDouble</code></pre>\n\n<h2 style=\"text-align:center;\">Опасные операции приведения типов</h2>\n\n<p><strong>Опасные</strong> операции приведения типа могут закончится <strong>ошибкой</strong> или <strong>изменением</strong> значения.</p>\n\n<p>Пример:</p>\n\n<pre><code class=\"language-scala\">val doub: Double = 1.9 // опасность зависит от значения\nval int: Int = doub.toInt // опасное преобразование</code></pre>\n\n<p>В данном примере значение <strong>int</strong> будет <strong>1</strong>, а не 1.9, так как 1.9 не может быть представлено целым числом. Тип <strong>Double</strong> не является подмножеством типа <strong>Int</strong>. Значение изменено при приведении типа.</p>\n\n<p>Другой пример:</p>\n\n<pre><code class=\"language-scala\">val doub: Double = Double.NaN // опасность зависит от значения\nval int: Int = doub.toInt // опасное преобразование</code></pre>\n\n<p>В данном примере значение <strong>int</strong> будет <strong>0</strong>, а не NaN (не число), так как NaN не может быть представлено целым числом. Значение изменено при приведении типа.&nbsp;</p>\n\n<p>Еще пример:</p>\n\n<pre><code class=\"language-scala\">val str: String = \"a12\" // опасность зависит от значения\nval int: Int = str.toInt // опасное преобразование</code></pre>\n\n<p>В данном примере произойдет <strong>ошибка</strong> преобразования, так как \"a12\" не может быть представлено целым числом.</p>\n\n<p>Таким образом, при использовании опасных преобразований вы должны или <strong>согласится с возможностью изменения значения</strong> в ходе преобразования, или заранее обеспечить <strong>только подходящие значения</strong> для преобразования.</p>",
  "video" : null,
  "options" : {
    
  },
  "subtitle_files" : [
  ],
  "is_deprecated" : false
}
```

</details>
