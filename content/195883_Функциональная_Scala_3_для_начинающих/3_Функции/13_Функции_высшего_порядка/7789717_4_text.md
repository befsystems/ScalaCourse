# Материал (Шаг 4)

## Информация о шаге

- **ID шага**: 7789717
- **Позиция**: 4
- **Тип**: text
- **Курс**: Функциональная Scala 3 для начинающих
- **Экспортирован**: 2025-12-20T22:21:31.1480434

## Содержание

# Прочие функции высшего порядка для типа String

## Функция **count**

Функция **count** возвращает количество символов строки, удовлетворяющих предикатной функции.

Тип предикатной функции: `Char => Boolean`

Пример:

val check: Char => Boolean =
(c: Char) => c.isUpper

"abC".count(check) // результат 1

Сокращённая запись:

"abC".count(_.isUpper)

## Функция **distinctBy**

Функция **distinctBy** сначала преобразует символы строки функцией преобразования, а затем отбрасывает дубликаты **по результатам этого преобразования**. Оставляются только первые вхождения.

Тип функции преобразования: `Char => A`, где `A` — тип данных, по которому производится сравнение.

Пример:

val toUpper: Char => Char =
(c: Char) => c.toUpper

"abcABC".distinctBy(toUpper) // результат "abc"

Сокращённая форма:

"abcABC".distinctBy(_.toUpper)



Другой пример с преобразованием символов в коды Unicode и смещением кода:

val toCode: Char => Int =
(c: Char) => c.toInt + 1

"abcABC".distinctBy(toCode) // Результат: "abcABC"

Здесь каждый символ преобразуется в своё числовое значение по таблице Unicode и сдвигается в большую сторону на единицу. Поскольку все символы в итоге имеют уникальный код, результат остаётся таким же, как и исходная строка — `"abcABC"`.



Другой пример с функцией предикатом:

Нужно оставить только первую гласную и первую согласную буквы.

val isVowel: Char => Boolean =
(c: Char) => "aeiouAEIOU".contains(c)

"appleBEE".distinctBy(isVowel) // Результат: "ap"




`'a'` → `true` (первая гласная)




`'p'` → `false` (первая согласная)




Остальные либо гласные (`true`), либо согласные (`false`) — уже были


## Функция **dropWhile**

Функция **dropWhile** удаляет **начальные символы** строки, которые удовлетворяют предикатной функции, и возвращает остаток строки, начиная с первого символа, не прошедшего проверку.

Тип предикатной функции: `Char => Boolean`

Пример:

val check: Char => Boolean =
(c: Char) => c.isUpper

"ABCd".dropWhile(check) // "d"

Сокращённая форма:

"ABCdd".dropWhile(_.isUpper) // "dd"

## Функция **exists**

Функция **exists** проверяет, удовлетворяет ли **хотя бы один** символ строки заданному предикату. Возвращает `true`, если условие выполняется хотя бы один раз.

Тип предикатной функции: `Char => Boolean`

Пример:

val check: Char => Boolean =
(c: Char) => c.isUpper

"abC".exists(check) // true

Сокращённая запись:

"abC".exists(_.isLower) // true

## Функция **filterNot**

Функция **filterNot **формирует новую строку, исключая символы, удовлетворяющие предикатной функции.

Тип предикатной функции: `Char => Boolean`

Пример:

val checkNumber: Char => Boolean =
(c: Char) => c.isDigit

"123a".filterNot(checkNumber) // "a"

Сокращённая запись:

"123a".filterNot(_.isDigit) // "a"

## Функция **forall**

Функция **forall** проверяет, удовлетворяют ли **все** символы строки заданному предикату. Возвращает `true`, если условие выполняется для всех символов, иначе `false`.

Тип предикатной функции: `Char => Boolean`

Пример:

val checkABC: Char => Boolean =
(c: Char) => c.isLetter

"abc".forall(checkABC) // true

## Функция **foreach**

Функция **foreach** выполняет над каждым элементом строки переданную функцию с побочным эффектом. Функция возвращает значение типа `Unit`.

Тип переданной функции: `Char => Unit`

Пример:

val santaGo: Char => Unit =
(c: Char) => println(s"$c ho-ho")

"abc".foreach(santaGo)

Результат:

a ho-ho
b ho-ho
c ho-ho

## Функция **indexWhere**

Функция **indexWhere** возвращает **индекс первого** символа, удовлетворяющего предикату. Если ни один символ не удовлетворяет условию, возвращается `-1`.

Тип предикатной функции: `Char => Boolean`

Пример:

val checkNumber: Char => Boolean =
(c: Char) => c.isDigit

"abc123".indexWhere(checkNumber) // 3

Сокращённая форма:

"abc123".indexWhere(_.isDigit) // 3

## Функция **reduce**

Функция **reduce** сворачивает строку в одно значение, используя функцию слияния.

Функция **reduce **применима только **к непустым** строкам.

Тип функции слияния: `(Char, Char) => Char`

Пример:

val maxChar: (Char, Char) => Char =
(a: Char, b: Char) => a.max(b)

"abcz".reduce(maxChar) // 'z'

Сокращённая форма:

"abcz".reduce(_ max _) // 'z'

## Функция **scanLeft**

Функция **scanLeft** похожа на `foldLeft`, но возвращает **все промежуточные значения аккумулятора**, включая начальное.

Тип функции преобразования: `(A, Char) => A`, где A - тип данных в выходном списке значений.

Пример:

val maxChar: (Char, Char) => Char =
(acc: Char, el: Char) => acc.max(el)

"cdf".scanLeft('a')(maxChar) // результат Vector('a', 'c', 'd', 'f')

## Функция **segmentLength**

Функция **segmentLength** возвращает длину начального сегмента строки, в котором все символы удовлетворяют предикату.

Тип предикатной функции: `Char => Boolean`

Пример:

val checkABC: Char => Boolean =
(c: Char) => c.isLetter

"abc1abcd".segmentLength(checkABC) // 3

Сокращённая форма:

"abc1abcd".segmentLength(_.isLetter) // 3

## Функция **takeWhile**

Функция **takeWhile** выбирает **начальные символы** строки, которые удовлетворяют предикату, и возвращает новую строку из этих символов.

Тип предикатной функции: `Char => Boolean`

Пример:

val check: Char => Boolean =
(c: Char) => c.isUpper

"ABCd".takeWhile(check) // "ABC"

Сокращённая форма:

"ABCd".takeWhile(_.isUpper) // "ABC"

---

### Полные данные JSON

<details>
<summary>Показать JSON данные</summary>

```json
{
  "name" : "text",
  "text" : "<h1 style=\"text-align:center;\">Прочие функции высшего порядка для типа String</h1>\n\n<h2 style=\"text-align:center;\">Функция <strong>count</strong></h2>\n\n<p>Функция <strong>count</strong> возвращает количество символов строки, удовлетворяющих предикатной функции.</p>\n\n<p>Тип предикатной функции: <code>Char =&gt; Boolean</code></p>\n\n<p>Пример:</p>\n\n<pre><code class=\"language-scala\">val check: Char =&gt; Boolean =\n  (c: Char) =&gt; c.isUpper\n\n\"abC\".count(check)  // результат 1\n</code></pre>\n\n<p>Сокращённая запись:</p>\n\n<pre><code class=\"language-scala\">\"abC\".count(_.isUpper) \n</code></pre>\n\n<h2 style=\"text-align:center;\">Функция <strong>distinctBy</strong></h2>\n\n<p>Функция <strong>distinctBy</strong> сначала преобразует символы строки функцией преобразования, а затем отбрасывает дубликаты <strong>по результатам этого преобразования</strong>. Оставляются только первые вхождения.</p>\n\n<p>Тип функции преобразования: <code>Char =&gt; A</code>, где <code>A</code> — тип данных, по которому производится сравнение.</p>\n\n<p>Пример:</p>\n\n<pre><code class=\"language-scala\">val toUpper: Char =&gt; Char =\n  (c: Char) =&gt; c.toUpper\n\n\"abcABC\".distinctBy(toUpper)  // результат \"abc\"\n</code></pre>\n\n<p>Сокращённая форма:</p>\n\n<pre><code class=\"language-scala\">\"abcABC\".distinctBy(_.toUpper)  \n</code></pre>\n\n<p>&nbsp;</p>\n\n<p>Другой пример&nbsp;с преобразованием символов в коды Unicode и смещением кода:</p>\n\n<pre><code class=\"language-scala\">val toCode: Char =&gt; Int = \n  (c: Char) =&gt; c.toInt + 1\n\n\"abcABC\".distinctBy(toCode) // Результат: \"abcABC\"\n</code></pre>\n\n<p>Здесь каждый символ преобразуется в своё числовое значение по таблице Unicode и сдвигается в большую сторону на единицу. Поскольку все символы в итоге имеют уникальный код, результат остаётся таким же, как и исходная строка — <code>\"abcABC\"</code>.</p>\n\n<p>&nbsp;</p>\n\n<p>Другой пример с функцией предикатом:</p>\n\n<p>Нужно оставить только первую гласную и первую согласную буквы.</p>\n\n<pre><code class=\"language-scala\">val isVowel: Char =&gt; Boolean = \n  (c: Char) =&gt; \"aeiouAEIOU\".contains(c) \n\n\"appleBEE\".distinctBy(isVowel) // Результат: \"ap\"\n</code></pre>\n\n<ul>\n\t<li>\n\t<p><code>'a'</code> → <code>true</code> (первая гласная)</p>\n\t</li>\n\t<li>\n\t<p><code>'p'</code> → <code>false</code> (первая согласная)</p>\n\t</li>\n\t<li>\n\t<p>Остальные либо гласные (<code>true</code>), либо согласные (<code>false</code>) — уже были</p>\n\t</li>\n</ul>\n\n<h2 style=\"text-align:center;\">Функция <strong>dropWhile</strong></h2>\n\n<p>Функция <strong>dropWhile</strong> удаляет <strong>начальные символы</strong> строки, которые удовлетворяют предикатной функции, и возвращает остаток строки, начиная с первого символа, не прошедшего проверку.</p>\n\n<p>Тип предикатной функции: <code>Char =&gt; Boolean</code></p>\n\n<p>Пример:</p>\n\n<pre><code class=\"language-scala\">val check: Char =&gt; Boolean =\n  (c: Char) =&gt; c.isUpper\n\n\"ABCd\".dropWhile(check)  // \"d\"\n</code></pre>\n\n<p>Сокращённая форма:</p>\n\n<pre><code class=\"language-scala\">\"ABCdd\".dropWhile(_.isUpper)  // \"dd\"\n</code></pre>\n\n<h2 style=\"text-align:center;\">Функция <strong>exists</strong></h2>\n\n<p>Функция <strong>exists</strong> проверяет, удовлетворяет ли <strong>хотя бы один</strong> символ строки заданному предикату. Возвращает <code>true</code>, если условие выполняется хотя бы один раз.</p>\n\n<p>Тип предикатной функции: <code>Char =&gt; Boolean</code></p>\n\n<p>Пример:</p>\n\n<pre><code class=\"language-scala\">val check: Char =&gt; Boolean =\n  (c: Char) =&gt; c.isUpper\n\n\"abC\".exists(check)  // true\n</code></pre>\n\n<p>Сокращённая запись:</p>\n\n<pre><code class=\"language-scala\">\"abC\".exists(_.isLower)  // true\n</code></pre>\n\n<h2 style=\"text-align:center;\">Функция <strong>filterNot</strong></h2>\n\n<p>Функция <strong>filterNot </strong>формирует новую строку, исключая символы, удовлетворяющие предикатной функции.</p>\n\n<p>Тип предикатной функции: <code>Char =&gt; Boolean</code></p>\n\n<p>Пример:</p>\n\n<pre><code class=\"language-scala\">val checkNumber: Char =&gt; Boolean =\n  (c: Char) =&gt; c.isDigit\n\n\"123a\".filterNot(checkNumber)  // \"a\"\n</code></pre>\n\n<p>Сокращённая запись:</p>\n\n<pre><code class=\"language-scala\">\"123a\".filterNot(_.isDigit)  // \"a\"\n</code></pre>\n\n<h2 style=\"text-align:center;\">Функция <strong>forall</strong></h2>\n\n<p>Функция <strong>forall</strong> проверяет, удовлетворяют ли <strong>все</strong> символы строки заданному предикату. Возвращает <code>true</code>, если условие выполняется для всех символов, иначе <code>false</code>.</p>\n\n<p>Тип предикатной функции: <code>Char =&gt; Boolean</code></p>\n\n<p>Пример:</p>\n\n<pre><code class=\"language-scala\">val checkABC: Char =&gt; Boolean =\n  (c: Char) =&gt; c.isLetter\n\n\"abc\".forall(checkABC)  // true\n</code></pre>\n\n<h2 style=\"text-align:center;\">Функция <strong>foreach</strong></h2>\n\n<p>Функция <strong>foreach</strong>&nbsp;выполняет над каждым элементом строки переданную функцию с побочным эффектом. Функция возвращает значение типа <code>Unit</code>.</p>\n\n<p>Тип переданной функции: <code>Char =&gt; Unit</code></p>\n\n<p>Пример:</p>\n\n<pre><code class=\"language-scala\">val santaGo: Char =&gt; Unit =\n  (c: Char) =&gt; println(s\"$c ho-ho\")\n\n\"abc\".foreach(santaGo)\n</code></pre>\n\n<p>Результат:</p>\n\n<pre><code>a ho-ho\nb ho-ho\nc ho-ho\n</code></pre>\n\n<h2 style=\"text-align:center;\">Функция <strong>indexWhere</strong></h2>\n\n<p>Функция <strong>indexWhere</strong> возвращает <strong>индекс первого</strong> символа, удовлетворяющего предикату. Если ни один символ не удовлетворяет условию, возвращается <code>-1</code>.</p>\n\n<p>Тип предикатной функции: <code>Char =&gt; Boolean</code></p>\n\n<p>Пример:</p>\n\n<pre><code class=\"language-scala\">val checkNumber: Char =&gt; Boolean =\n  (c: Char) =&gt; c.isDigit\n\n\"abc123\".indexWhere(checkNumber)  // 3\n</code></pre>\n\n<p>Сокращённая форма:</p>\n\n<pre><code class=\"language-scala\">\"abc123\".indexWhere(_.isDigit)  // 3\n</code></pre>\n\n<h2 style=\"text-align:center;\">Функция <strong>reduce</strong></h2>\n\n<p>Функция <strong>reduce</strong> сворачивает строку в одно значение, используя функцию слияния.</p>\n\n<p>Функция <strong>reduce </strong>применима только <strong>к непустым</strong> строкам.</p>\n\n<p>Тип функции слияния: <code>(Char, Char) =&gt; Char</code></p>\n\n<p>Пример:</p>\n\n<pre><code class=\"language-scala\">val maxChar: (Char, Char) =&gt; Char =\n  (a: Char, b: Char) =&gt; a.max(b)\n\n\"abcz\".reduce(maxChar)  // 'z'\n</code></pre>\n\n<p>Сокращённая форма:</p>\n\n<pre><code class=\"language-scala\">\"abcz\".reduce(_ max _)  // 'z'\n</code></pre>\n\n<h2 style=\"text-align:center;\">Функция <strong>scanLeft</strong></h2>\n\n<p>Функция <strong>scanLeft</strong> похожа на <code>foldLeft</code>, но возвращает <strong>все промежуточные значения аккумулятора</strong>, включая начальное.</p>\n\n<p>Тип функции преобразования: <code>(A, Char) =&gt; A</code>, где A - тип данных в выходном списке значений.</p>\n\n<p>Пример:</p>\n\n<pre><code class=\"language-scala\">val maxChar: (Char, Char) =&gt; Char =\n  (acc: Char, el: Char) =&gt; acc.max(el)\n\n\"cdf\".scanLeft('a')(maxChar) // результат Vector('a', 'c', 'd', 'f')\n</code></pre>\n\n<h2 style=\"text-align:center;\">Функция <strong>segmentLength</strong></h2>\n\n<p>Функция <strong>segmentLength</strong> возвращает длину начального сегмента строки, в котором все символы удовлетворяют предикату.</p>\n\n<p>Тип предикатной функции: <code>Char =&gt; Boolean</code></p>\n\n<p>Пример:</p>\n\n<pre><code class=\"language-scala\">val checkABC: Char =&gt; Boolean =\n  (c: Char) =&gt; c.isLetter\n\n\"abc1abcd\".segmentLength(checkABC)  // 3\n</code></pre>\n\n<p>Сокращённая форма:</p>\n\n<pre><code class=\"language-scala\">\"abc1abcd\".segmentLength(_.isLetter)  // 3\n</code></pre>\n\n<h2 style=\"text-align:center;\">Функция <strong>takeWhile</strong></h2>\n\n<p>Функция <strong>takeWhile</strong> выбирает <strong>начальные символы</strong> строки, которые удовлетворяют предикату, и возвращает новую строку из этих символов.</p>\n\n<p>Тип предикатной функции: <code>Char =&gt; Boolean</code></p>\n\n<p>Пример:</p>\n\n<pre><code class=\"language-scala\">val check: Char =&gt; Boolean =\n  (c: Char) =&gt; c.isUpper\n\n\"ABCd\".takeWhile(check)  // \"ABC\"\n</code></pre>\n\n<p>Сокращённая форма:</p>\n\n<pre><code class=\"language-scala\">\"ABCd\".takeWhile(_.isUpper)  // \"ABC\"\n</code></pre>",
  "video" : null,
  "options" : {
    
  },
  "subtitle_files" : [
  ],
  "is_deprecated" : false
}
```

</details>
