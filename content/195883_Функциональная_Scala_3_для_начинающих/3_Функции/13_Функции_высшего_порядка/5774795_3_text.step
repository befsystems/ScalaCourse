{
  "step_id" : 5774795,
  "lesson_id" : 1228705,
  "position" : 3,
  "type" : "unknown",
  "block" : {
    "name" : "text",
    "text" : "<h1 style=\"text-align:center;\">Основные функции высшего порядка для типа String</h1>\n\n<p>Стандартная библиотека Scala в своем составе уже имеет реализованные функции высшего порядка для многих типов данных. Некоторые из этих функций очень важны и часто используются, так как имеют глубокие математические основания. В последующих уроках мы подробно изучим такие функции и их теоретическую&nbsp;основу.</p>\n\n<p>Сейчас же поверхностно рассмотрим некоторые из таких функций, применяемых для типа String, чтобы уметь ими пользоваться. Аналогичные функции имеются и в других типах данных.</p>\n\n<p>Следует обратить внимание, что здесь функциями типа String, мы называем на самом деле операции типа String. В таком виде они реализованы в стандартной библиотеке. Хотя операции и функции немного отличаются по синтаксису, в языке Scala они почти тождественны по смыслу и использованию.</p>\n\n<h2 style=\"text-align:center;\">Функция map</h2>\n\n<p>Функция <strong><code>map</code></strong> выполняет преобразование каждого символа строки (элемента коллекции).</p>\n\n<p>Функция <strong><code>map</code> </strong>принимает в качестве аргумента <strong>функцию преобразования</strong> и применяет её к <strong>каждому </strong>символу строки.</p>\n\n<p><strong>Функция преобразования</strong> — это анонимная функция, которая принимает аргументом элемент коллекции и возвращает <strong>преобразованный</strong> элемент для выходной коллекции<strong> </strong>.</p>\n\n<p>Тип функции преобразования выглядит следующим образом: <strong><code>Char =&gt; Char</code></strong>, если функция просто преобразует один символ в другой символ. В результате возвращается <strong>новая </strong>строка.</p>\n\n<p>Пример:</p>\n\n<pre><code class=\"language-scala\">//Функция преобразования\nval up: Char =&gt; Char = \n  (c: Char) =&gt; c.toUpper\n\n//Функция высшего порядка получает аргументом функцию преобразования\nval result: String = \"abc\".map(up)\n\n//результат \"ABC\"</code></pre>\n\n<p>Функцию преобразования можно сразу встроить в функцию <code>map</code> при её вызове:</p>\n\n<p>Пример:</p>\n\n<pre><code class=\"language-scala\">//Функция высшего порядка получает аргументом функцию преобразования\nval result: String = \"abc\".map(_.toUpper)\n\n//результат \"ABC\"</code></pre>\n\n<p>Функция преобразования может <strong>изменять тип </strong>элементов. Тогда тип функции преобразования будет <code><strong>Char =&gt; A</strong>,</code>где <code>A</code> — некий тип элемента после преобразования, а выходным результатом будет коллекция типа A.</p>\n\n<p>Пример преобразования символов в числа:</p>\n\n<pre><code class=\"language-scala\">//Функция преобразования\nval getCode: Char =&gt; Int = \n  (c: Char) =&gt; c.toInt\n\n//Функция высшего порядка получает аргументом функцию преобразования\nval result = \"abc\".map(getCode)\n\n//результат - коллекция чисел 97, 98, 99 (не строка)</code></pre>\n\n<p>Функция <code>map</code> <strong>не изменяет</strong> исходную коллекцию, вместо этого создаётся <strong>новая коллекция</strong>, что соответствует концепции неизменяемости данных в функциональном программировании.</p>\n\n<p>Обработке подвергаются <strong>все </strong>элементы коллекции. <strong>Порядок </strong>расположения обработанных элементов в коллекции<strong> не меняется</strong>. <strong>Количество</strong> элементов в строке <strong>не меняется</strong>.</p>\n\n<h2 style=\"text-align:center;\">Функция filter</h2>\n\n<p>Функция <strong><code>filter</code></strong> отбирает некоторые элементы коллекции в новую коллекцию.</p>\n\n<p>Функция <strong><code>filter</code></strong> принимает в качестве аргумента <strong>предикатную функцию</strong> и использует её для отбора элементов коллекции, которые соответствуют критерию, задаваемому предикатной функцией.</p>\n\n<p><strong>Предикатная функция</strong> — это анонимная функция, которая принимает элемент коллекции и возвращает <strong>булево </strong>значение (<code>true</code> или <code>false</code>).</p>\n\n<p>Тип предикатной функции выглядит следующим образом: <strong><code>Char =&gt; Boolean</code></strong></p>\n\n<p>Функция <code>filter</code> проходит по каждому элементу коллекции и применяет к нему предикатную функцию. В новую коллекцию добавляются только те элементы, для которых предикатная функция вернула <strong><code>true</code></strong>. При этом исходная коллекция остается <strong>неизменной</strong>, так как функция <code>filter</code> создаёт новую коллекцию. Элементы коллекции не изменяются, но может измениться их <strong>количество</strong>.</p>\n\n<p>Пример:</p>\n\n<pre><code class=\"language-scala\">// Функция предикат\nval checkNumber: Char =&gt; Boolean =\n  (c: Char) =&gt; c.isDigit              \n  \n//Функция высшего порядка получает аргументом функцию предикат\nval result: String = \"123abc\".filter(checkNumber)\n\n//Результат \"123\"</code></pre>\n\n<p>Предикатную функцию можно сразу встроить в функцию filter при её вызове:</p>\n\n<pre><code class=\"language-scala\">//Функция высшего порядка получает аргументом функцию предикат\nval result: String = \"123cba\".filter(_.isDigit)\n\n//Результат \"123\"</code></pre>\n\n<h2 style=\"text-align:center;\">Функция flatMap</h2>\n\n<p>Функция <strong><code>flatMap </code></strong>выполняет сразу две операции, операцию <strong>преобразования </strong>каждого элемента коллекции в <strong>новую коллекцию</strong>, и затем операцию <strong>разворачивания </strong>полученной двухмерной коллекции в <strong>одномерную</strong>.</p>\n\n<p>Название функции показывает, что функция&nbsp;<strong><code>flatMap</code></strong> это композиция двух функций <code>map</code> и <code>flatten.</code></p>\n\n<p>Операция преобразования должна обязательно делать из элемента <strong>коллекцию</strong>, только тогда получится двухмерная коллекция, и её можно будет развернуть.</p>\n\n<p>Функция <strong><code>flatMap</code></strong>для типа String принимает в качестве аргумента <strong>функцию преобразования</strong>, которая из символа делает новую строку. Тип функции преобразования выглядит следующим образом: <strong><code>Char =&gt; String.</code></strong></p>\n\n<p>Функция преобразования применяется к каждому символу существующей строки, и из каждого символа получаем <strong>новую</strong> <strong>строку</strong>. После этапа преобразования, получаем <strong>коллекцию строк</strong> (напоминает таблицу или текст) . Это этап операции <code>map.</code></p>\n\n<p>Далее двухмерная строка <strong>разворачивается </strong>в одну большую одномерную строку, объединяя все полученные строки друг за другом. Итоговым результатом является <strong>одна новая строка</strong>. Это этап операции <code>flatten.</code></p>\n\n<p>Пример:</p>\n\n<pre><code class=\"language-scala\">// Функция преобразования создает строку из одинаковых трех символов на основе исходного символа\nval charRepeat: Char =&gt; String =\n  (c: Char) =&gt; c.toString.repeat(3)\n \n// Функция высшего порядка получает аргументом функцию преобразования \nval result: String = \"123abc\".flatMap(charRepeat)\n\n// Результат строка 111222333aaabbbccc</code></pre>\n\n<p>Функцию преобразования можно сразу встроить в функцию <code>flatMap</code> при&nbsp; её вызове:</p>\n\n<pre><code class=\"language-scala\">// Функция высшего порядка получает аргументом функцию преобразования \nval result: String = \"123abc\".flatMap(_.toString.repeat(3))\n\n// Результат строка 111222333aaabbbccc</code></pre>\n\n<p>Не смотря на кажущуюся экзотичность функции <strong><code>flatMap</code></strong> - это одна из самых востребованных функций в языке Scala. На неё стоит обратить особое внимание.</p>\n\n<h2 style=\"text-align:center;\">Функция foldLeft</h2>\n\n<p>Функция <strong><code>foldLeft</code> </strong>предназначена для свёртки (агрегирования) элементов коллекции с использованием получаемой аргументом <strong>функции</strong> <strong>соединения</strong> элементов.</p>\n\n<p><strong>Функция соединения</strong> - это анонимная функция, которая получает два элемента, возможно разных типов, и соединяет их в один элемент возможно другого типа.</p>\n\n<p><strong>Аккумулятор</strong> (или аккумуляционное значение) — это значение, которое показывает промежуточный результат свёртки по мере её выполнения.</p>\n\n<p>Функция соединения принимает<strong> два аргумента</strong>: текущее значение аккумулятора и элемент коллекции. Она возвращает новое значение аккумулятора, которое используется в следующем шаге.</p>\n\n<p>Тип функции соединения для строки выглядит следующим образом: <code><strong>(A, Char) =&gt; A</strong>,</code>где <code>A</code> — некий тип начального значения аккумулятора и выходного значения.</p>\n\n<p>Начальное значение аккумулятора задается первым параметром функции <code>foldLeft </code>в отдельной группе параметров.</p>\n\n<p>Функция&nbsp;<code>foldLeft</code> проходит по каждому элементу коллекции, применяя функцию соединения к текущему значению аккумулятора и текущему элементу коллекции.</p>\n\n<p>Аккумулятор на каждом шаге создаётся заново, что позволяет избежать побочных эффектов и сохраняет чистоту функций.</p>\n\n<p>После обработки всех элементов коллекции, последнее значение аккумулятора становится результатом вызова функции <code>foldLeft</code>.</p>\n\n<p>Последовательность обработки элементов производится от начала коллекции к её концу (слева направо).</p>\n\n<p>Пример свертки всех символов в строке используя их код:</p>\n\n<pre><code class=\"language-scala\">// Функция соединения символов по их кодам\nval summator: (Int, Char) =&gt; Int =\n  (acc: Int, el: Char) =&gt; acc + el.toInt\n\n//Функция высшего порядка получает аргументом функцию соединения  \n//Начальное значение аккумулятора 0 задается в первой группе параметров   \nval result: Int = \"abc\".foldLeft(0)(summator) \n\n// Результат - число 294</code></pre>\n\n<p>Функцию соединения можно встроить в функцию <code>foldLeft</code> при её вызове:</p>\n\n<pre><code class=\"language-scala\">//Функция высшего порядка получает аргументом функцию соединения    \n\"abc\".foldLeft(0){ (acc: Int, el: Char) =&gt; \n  acc + el.toInt\n}</code></pre>\n\n<p>Функция <strong><code>foldLeft </code></strong>является очень мощной и универсальной функцией. На ней можно реализовать все другие функции коллекций. А под операцией свертки можно понимать любую операцию преобразования.</p>\n\n<p>Например реализуем работу функции <code>map</code> вместе с&nbsp; функцией преобразования:</p>\n\n<pre><code class=\"language-scala\">// Начальное значение аккумулятора пустая строка\nval result = \"abc\".foldLeft(\"\") { (acc: String, el: Char) =&gt;\n  acc :+ el.toUpper  // добавляем обработанный элемент в строку-аккумулятор\n}\n\n//результат \"ABC\"</code></pre>\n\n<p>Реализуем работу функции filter вместе с предикатной функцией:</p>\n\n<pre><code class=\"language-scala\">// Начальное значение аккумулятора пустая строка\nval result = \"123abc\".foldLeft(\"\") { (acc: String, el: Char) =&gt;\n  if el.isDigit then\n    acc :+ el  // добавляем элемент в строку-аккумулятор\n  else\n    acc        // не добавляем элемент в строку-аккумулятор\n}\n\n//результат \"123\"</code></pre>",
    "video" : null,
    "options" : {
      
    },
    "subtitle_files" : [
    ],
    "is_deprecated" : false
  },
  "name" : "text",
  "course_id" : 195883,
  "course_name" : "Функциональная Scala 3 для начинающих",
  "exported_at" : "2026-01-10T10:17:27.8160038"
}