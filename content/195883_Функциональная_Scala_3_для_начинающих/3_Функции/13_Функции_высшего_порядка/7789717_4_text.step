{
  "step_id" : 7789717,
  "lesson_id" : 1228705,
  "position" : 4,
  "type" : "unknown",
  "block" : {
    "name" : "text",
    "text" : "<h1 style=\"text-align:center;\">Прочие функции высшего порядка для типа String</h1>\n\n<h2 style=\"text-align:center;\">Функция <strong>count</strong></h2>\n\n<p>Функция <strong>count</strong> возвращает количество символов строки, удовлетворяющих предикатной функции.</p>\n\n<p>Тип предикатной функции: <code>Char =&gt; Boolean</code></p>\n\n<p>Пример:</p>\n\n<pre><code class=\"language-scala\">val check: Char =&gt; Boolean =\n  (c: Char) =&gt; c.isUpper\n\n\"abC\".count(check)  // результат 1\n</code></pre>\n\n<p>Сокращённая запись:</p>\n\n<pre><code class=\"language-scala\">\"abC\".count(_.isUpper) \n</code></pre>\n\n<h2 style=\"text-align:center;\">Функция <strong>distinctBy</strong></h2>\n\n<p>Функция <strong>distinctBy</strong> сначала преобразует символы строки функцией преобразования, а затем отбрасывает дубликаты <strong>по результатам этого преобразования</strong>. Оставляются только первые вхождения.</p>\n\n<p>Тип функции преобразования: <code>Char =&gt; A</code>, где <code>A</code> — тип данных, по которому производится сравнение.</p>\n\n<p>Пример:</p>\n\n<pre><code class=\"language-scala\">val toUpper: Char =&gt; Char =\n  (c: Char) =&gt; c.toUpper\n\n\"abcABC\".distinctBy(toUpper)  // результат \"abc\"\n</code></pre>\n\n<p>Сокращённая форма:</p>\n\n<pre><code class=\"language-scala\">\"abcABC\".distinctBy(_.toUpper)  \n</code></pre>\n\n<p>&nbsp;</p>\n\n<p>Другой пример&nbsp;с преобразованием символов в коды Unicode и смещением кода:</p>\n\n<pre><code class=\"language-scala\">val toCode: Char =&gt; Int = \n  (c: Char) =&gt; c.toInt + 1\n\n\"abcABC\".distinctBy(toCode) // Результат: \"abcABC\"\n</code></pre>\n\n<p>Здесь каждый символ преобразуется в своё числовое значение по таблице Unicode и сдвигается в большую сторону на единицу. Поскольку все символы в итоге имеют уникальный код, результат остаётся таким же, как и исходная строка — <code>\"abcABC\"</code>.</p>\n\n<p>&nbsp;</p>\n\n<p>Другой пример с функцией предикатом:</p>\n\n<p>Нужно оставить только первую гласную и первую согласную буквы.</p>\n\n<pre><code class=\"language-scala\">val isVowel: Char =&gt; Boolean = \n  (c: Char) =&gt; \"aeiouAEIOU\".contains(c) \n\n\"appleBEE\".distinctBy(isVowel) // Результат: \"ap\"\n</code></pre>\n\n<ul>\n\t<li>\n\t<p><code>'a'</code> → <code>true</code> (первая гласная)</p>\n\t</li>\n\t<li>\n\t<p><code>'p'</code> → <code>false</code> (первая согласная)</p>\n\t</li>\n\t<li>\n\t<p>Остальные либо гласные (<code>true</code>), либо согласные (<code>false</code>) — уже были</p>\n\t</li>\n</ul>\n\n<h2 style=\"text-align:center;\">Функция <strong>dropWhile</strong></h2>\n\n<p>Функция <strong>dropWhile</strong> удаляет <strong>начальные символы</strong> строки, которые удовлетворяют предикатной функции, и возвращает остаток строки, начиная с первого символа, не прошедшего проверку.</p>\n\n<p>Тип предикатной функции: <code>Char =&gt; Boolean</code></p>\n\n<p>Пример:</p>\n\n<pre><code class=\"language-scala\">val check: Char =&gt; Boolean =\n  (c: Char) =&gt; c.isUpper\n\n\"ABCd\".dropWhile(check)  // \"d\"\n</code></pre>\n\n<p>Сокращённая форма:</p>\n\n<pre><code class=\"language-scala\">\"ABCdd\".dropWhile(_.isUpper)  // \"dd\"\n</code></pre>\n\n<h2 style=\"text-align:center;\">Функция <strong>exists</strong></h2>\n\n<p>Функция <strong>exists</strong> проверяет, удовлетворяет ли <strong>хотя бы один</strong> символ строки заданному предикату. Возвращает <code>true</code>, если условие выполняется хотя бы один раз.</p>\n\n<p>Тип предикатной функции: <code>Char =&gt; Boolean</code></p>\n\n<p>Пример:</p>\n\n<pre><code class=\"language-scala\">val check: Char =&gt; Boolean =\n  (c: Char) =&gt; c.isUpper\n\n\"abC\".exists(check)  // true\n</code></pre>\n\n<p>Сокращённая запись:</p>\n\n<pre><code class=\"language-scala\">\"abC\".exists(_.isLower)  // true\n</code></pre>\n\n<h2 style=\"text-align:center;\">Функция <strong>filterNot</strong></h2>\n\n<p>Функция <strong>filterNot </strong>формирует новую строку, исключая символы, удовлетворяющие предикатной функции.</p>\n\n<p>Тип предикатной функции: <code>Char =&gt; Boolean</code></p>\n\n<p>Пример:</p>\n\n<pre><code class=\"language-scala\">val checkNumber: Char =&gt; Boolean =\n  (c: Char) =&gt; c.isDigit\n\n\"123a\".filterNot(checkNumber)  // \"a\"\n</code></pre>\n\n<p>Сокращённая запись:</p>\n\n<pre><code class=\"language-scala\">\"123a\".filterNot(_.isDigit)  // \"a\"\n</code></pre>\n\n<h2 style=\"text-align:center;\">Функция <strong>forall</strong></h2>\n\n<p>Функция <strong>forall</strong> проверяет, удовлетворяют ли <strong>все</strong> символы строки заданному предикату. Возвращает <code>true</code>, если условие выполняется для всех символов, иначе <code>false</code>.</p>\n\n<p>Тип предикатной функции: <code>Char =&gt; Boolean</code></p>\n\n<p>Пример:</p>\n\n<pre><code class=\"language-scala\">val checkABC: Char =&gt; Boolean =\n  (c: Char) =&gt; c.isLetter\n\n\"abc\".forall(checkABC)  // true\n</code></pre>\n\n<h2 style=\"text-align:center;\">Функция <strong>foreach</strong></h2>\n\n<p>Функция <strong>foreach</strong>&nbsp;выполняет над каждым элементом строки переданную функцию с побочным эффектом. Функция возвращает значение типа <code>Unit</code>.</p>\n\n<p>Тип переданной функции: <code>Char =&gt; Unit</code></p>\n\n<p>Пример:</p>\n\n<pre><code class=\"language-scala\">val santaGo: Char =&gt; Unit =\n  (c: Char) =&gt; println(s\"$c ho-ho\")\n\n\"abc\".foreach(santaGo)\n</code></pre>\n\n<p>Результат:</p>\n\n<pre><code>a ho-ho\nb ho-ho\nc ho-ho\n</code></pre>\n\n<h2 style=\"text-align:center;\">Функция <strong>indexWhere</strong></h2>\n\n<p>Функция <strong>indexWhere</strong> возвращает <strong>индекс первого</strong> символа, удовлетворяющего предикату. Если ни один символ не удовлетворяет условию, возвращается <code>-1</code>.</p>\n\n<p>Тип предикатной функции: <code>Char =&gt; Boolean</code></p>\n\n<p>Пример:</p>\n\n<pre><code class=\"language-scala\">val checkNumber: Char =&gt; Boolean =\n  (c: Char) =&gt; c.isDigit\n\n\"abc123\".indexWhere(checkNumber)  // 3\n</code></pre>\n\n<p>Сокращённая форма:</p>\n\n<pre><code class=\"language-scala\">\"abc123\".indexWhere(_.isDigit)  // 3\n</code></pre>\n\n<h2 style=\"text-align:center;\">Функция <strong>reduce</strong></h2>\n\n<p>Функция <strong>reduce</strong> сворачивает строку в одно значение, используя функцию слияния.</p>\n\n<p>Функция <strong>reduce </strong>применима только <strong>к непустым</strong> строкам.</p>\n\n<p>Тип функции слияния: <code>(Char, Char) =&gt; Char</code></p>\n\n<p>Пример:</p>\n\n<pre><code class=\"language-scala\">val maxChar: (Char, Char) =&gt; Char =\n  (a: Char, b: Char) =&gt; a.max(b)\n\n\"abcz\".reduce(maxChar)  // 'z'\n</code></pre>\n\n<p>Сокращённая форма:</p>\n\n<pre><code class=\"language-scala\">\"abcz\".reduce(_ max _)  // 'z'\n</code></pre>\n\n<h2 style=\"text-align:center;\">Функция <strong>scanLeft</strong></h2>\n\n<p>Функция <strong>scanLeft</strong> похожа на <code>foldLeft</code>, но возвращает <strong>все промежуточные значения аккумулятора</strong>, включая начальное.</p>\n\n<p>Тип функции преобразования: <code>(A, Char) =&gt; A</code>, где A - тип данных в выходном списке значений.</p>\n\n<p>Пример:</p>\n\n<pre><code class=\"language-scala\">val maxChar: (Char, Char) =&gt; Char =\n  (acc: Char, el: Char) =&gt; acc.max(el)\n\n\"cdf\".scanLeft('a')(maxChar) // результат Vector('a', 'c', 'd', 'f')\n</code></pre>\n\n<h2 style=\"text-align:center;\">Функция <strong>segmentLength</strong></h2>\n\n<p>Функция <strong>segmentLength</strong> возвращает длину начального сегмента строки, в котором все символы удовлетворяют предикату.</p>\n\n<p>Тип предикатной функции: <code>Char =&gt; Boolean</code></p>\n\n<p>Пример:</p>\n\n<pre><code class=\"language-scala\">val checkABC: Char =&gt; Boolean =\n  (c: Char) =&gt; c.isLetter\n\n\"abc1abcd\".segmentLength(checkABC)  // 3\n</code></pre>\n\n<p>Сокращённая форма:</p>\n\n<pre><code class=\"language-scala\">\"abc1abcd\".segmentLength(_.isLetter)  // 3\n</code></pre>\n\n<h2 style=\"text-align:center;\">Функция <strong>takeWhile</strong></h2>\n\n<p>Функция <strong>takeWhile</strong> выбирает <strong>начальные символы</strong> строки, которые удовлетворяют предикату, и возвращает новую строку из этих символов.</p>\n\n<p>Тип предикатной функции: <code>Char =&gt; Boolean</code></p>\n\n<p>Пример:</p>\n\n<pre><code class=\"language-scala\">val check: Char =&gt; Boolean =\n  (c: Char) =&gt; c.isUpper\n\n\"ABCd\".takeWhile(check)  // \"ABC\"\n</code></pre>\n\n<p>Сокращённая форма:</p>\n\n<pre><code class=\"language-scala\">\"ABCd\".takeWhile(_.isUpper)  // \"ABC\"\n</code></pre>",
    "video" : null,
    "options" : {
      
    },
    "subtitle_files" : [
    ],
    "is_deprecated" : false
  },
  "name" : "text",
  "course_id" : 195883,
  "course_name" : "Функциональная Scala 3 для начинающих",
  "exported_at" : "2026-01-10T10:17:27.8184839"
}