# Материал (Шаг 1)

## Информация о шаге

- **ID шага**: 5208698
- **Позиция**: 1
- **Тип**: text
- **Курс**: Функциональная Scala 3 для начинающих
- **Экспортирован**: 2025-12-20T22:21:14.084335

## Содержание

## Виды параметров функции

Существуют два вида параметров функции по способу получения значения из них:

- **Параметр-значение** (by-­value parameter) - параметр представляет само значение

- **Параметр-запрос** (by­-name parameter) - параметр представляет запрос для получения значения

Основное их отличие заключается в моменте и кратности использования аргумента для параметра.

## Параметр-значение

**Параметр-значение** можно назвать **обычным** видом параметров функции. До сих пор, мы рассматривали именно такой вид параметров.

Значение **параметра-значения** функции будет вычислено **перед передачей** в функцию. Далее, в теле функции, этот параметр будет использоваться как **фиксированное значение** во всех выражениях.

Для примера нам нужно будет воспользоваться функциями **random** и **println** из стандартной библиотеки. Функция **random** при каждом вызове выдает новое случайное число типа Double. Функция **println** выводит в консоль значение переданного ей аргумента.

Пример:

// функция с параметром-значением
def doublePrintByValue(param: Double): Unit = { // param: Double - определение параметра-значения
println("start") // печатаем в консоле слово start
println(param) // печатаем значение param
println(param) // еще раз печатаем значение param
}

// вызов функции с параметром-значением
doublePrintByValue { // используем блок выражений как аргумент
println("get argument") // печатаем get argument
random() // генерируем случайное число
}

Вывод на консоль:

get argument

start

0.6190790564618847

0.6190790564618847

При вызове функции **doublePrintByValue**, сначала был вычислен блок выражений, при этом была напечатана фраза *get argument* и создано случайное значение*.* Значение параметра было передано в тело функции. Далее начало вычисляться тело функции, и значение параметра использовано два раза для печати в консоль.

Заметим, что блок выражений вычислялся один раз (видим одно и тоже значение в консоле), хотя значение параметра использовалось два раза.

Такова **последовательность** выполнения операций при вызове функции с **параметром-значением**.

## Параметр-запрос

Значение **параметра-запроса** функции **не будет** вычислено перед передачей в функцию. При каждом обращении к этому параметру внутри тела функции, его значение будет вычисляться заново. Если обращений к параметру не произойдет, то вычисления значения также не будет.

**Параметр-запрос** по своим свойствам напоминает функцию без параметров, но не является таковой.

Для **определения** параметра-запроса необходимо указать знак `**=>**` перед типом параметра.

Пример:

// функция с параметром-запросом
def doublePrintByName(param: => Double): Unit = { // param: => Double - определение параметра-запроса
println("start") // печатаем в консоле слово start
println(param) // печатаем значение param
println(param) // еще раз печатаем значение param
}

// вызов функции с параметром-запросом
doublePrintByName { // используем блок выражений как аргумент
println("get argument") // печатаем get argument
random() // генерируем случайное число
}

Вывод на консоль:

start

get argument

0.47819516218984637

get argument

0.15863441851214566

При вызове функции **doublePrintByName** значение параметра **не было** вычислено заранее. Тело функции вычислиться, и было напечатано слово *start*. Далее в теле функции было использован параметр в первый раз, и при этом вычислено значение параметра, была напечатана фраза *get argument* и случайное число*.* Далее в теле функции было использован параметр во второй раз, и при этом также вычислено значение параметра, и была напечатана фраза *get argument* и случайное число во второй раз*.*

Такова **последовательность** выполнения операций при вызове функции с **параметром-запросом**.

Параметр-запрос можно назвать **ленивым** (более точно - нестрогим) параметром. Это означает, что параметр не вычисляться до тех пор пока он не будет действительно использован в цепочке вычислений. Это позволяет ему вычисляется по мере необходимости, что снижает объем вычислений при вызове функции. Возможно он вообще **не будет вычислен никогда**, если цепочка вычислений пойдет по пути, где этот параметр не используется. С другой стороны, при использовании его несколько раз, он будет вычислен так же **несколько раз**.

Использование параметра-запроса - это **императивный стиль** программирования, который уделяет внимание **последовательности** выполнения операций. Тем не менее, в некоторых случаях, для оптимизации работы с внешними ресурсами бывает удобно использовать эту возможность.

## Несколько разных видов параметров в одной функции

**Допускается **использовать **несколько** видов параметров в одной функции. При этом, поведение параметров полностью **независимо** друг от друга.

Пример:

// определение функции с разными видами параметров
def doublePrint(param1: Double, param2: => Double): Unit = ???

---

### Полные данные JSON

<details>
<summary>Показать JSON данные</summary>

```json
{
  "name" : "text",
  "text" : "<h2 style=\"text-align: center;\">Виды параметров функции</h2>\n\n<p>Существуют два вида параметров функции по способу получения значения из них:</p>\n\n<ol>\n\t<li><strong>Параметр-значение</strong> (by-­value parameter) - параметр представляет само значение</li>\n\t<li><strong>Параметр-запрос</strong> (by­-name parameter) - параметр представляет запрос для получения значения</li>\n</ol>\n\n<p>Основное их отличие заключается в моменте и кратности использования аргумента для параметра.</p>\n\n<h2 style=\"text-align: center;\">Параметр-значение</h2>\n\n<p><strong>Параметр-значение</strong> можно назвать <strong>обычным</strong> видом параметров функции. До сих пор, мы рассматривали именно такой вид параметров.</p>\n\n<p>Значение <strong>параметра-значения</strong> функции будет вычислено <strong>перед передачей</strong> в функцию. Далее, в теле функции, этот параметр&nbsp;&nbsp; будет использоваться как <strong>фиксированное значение</strong> во всех выражениях.</p>\n\n<p>Для примера нам нужно будет воспользоваться функциями <strong>random</strong> и <strong>println</strong> из стандартной библиотеки. Функция <strong>random</strong> при каждом вызове выдает новое случайное число типа Double. Функция <strong>println</strong> выводит в консоль значение переданного ей аргумента.</p>\n\n<p>Пример:</p>\n\n<pre><code class=\"language-scala\">// функция с параметром-значением\ndef doublePrintByValue(param: Double): Unit = {  // param: Double - определение параметра-значения\n  println(\"start\") // печатаем в консоле слово start\n  println(param)   // печатаем значение param\n  println(param)   // еще раз печатаем значение param\n}\n\n// вызов функции с параметром-значением\ndoublePrintByValue { // используем блок выражений как аргумент\n  println(\"get argument\") // печатаем get argument\n  random()                // генерируем случайное число\n}</code></pre>\n\n<p>Вывод на консоль:</p>\n\n<p><em>get argument&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>\nstart<br>\n0.6190790564618847<br>\n0.6190790564618847</em></p>\n\n<p>При вызове функции <strong>doublePrintByValue</strong>, сначала был вычислен блок выражений, при этом была напечатана фраза <em>get argument</em> и создано случайное значение<em>.</em> Значение параметра было передано в тело функции. Далее начало вычисляться тело функции, и значение параметра использовано два раза для печати в консоль.</p>\n\n<p>Заметим, что блок выражений вычислялся один раз (видим одно и тоже значение в консоле), хотя значение параметра использовалось два раза.</p>\n\n<p>Такова <strong>последовательность</strong> выполнения операций при вызове функции с <strong>параметром-значением</strong>.</p>\n\n<h2 style=\"text-align: center;\">Параметр-запрос</h2>\n\n<p>Значение <strong>параметра-запроса</strong> функции <strong>не будет</strong> вычислено перед передачей в функцию. При каждом обращении к этому параметру внутри тела функции, его значение будет вычисляться заново. Если обращений к параметру не произойдет, то вычисления значения также не будет.</p>\n\n<p><strong>Параметр-запрос</strong> по своим свойствам напоминает функцию без параметров, но не является таковой.&nbsp;</p>\n\n<p>Для <strong>определения</strong> параметра-запроса необходимо указать знак <code><strong>=&gt;</strong></code> перед типом параметра.</p>\n\n<p>Пример:</p>\n\n<pre><code class=\"language-scala\">// функция с параметром-запросом\ndef doublePrintByName(param: =&gt; Double): Unit = {  // param: =&gt; Double - определение параметра-запроса\n  println(\"start\") // печатаем в консоле слово start\n  println(param)   // печатаем значение param\n  println(param)   // еще раз печатаем значение param\n}\n\n// вызов функции с параметром-запросом\ndoublePrintByName { // используем блок выражений как аргумент\n  println(\"get argument\") // печатаем get argument\n  random()                // генерируем случайное число\n}</code></pre>\n\n<p>Вывод на консоль:</p>\n\n<p><em>start<br>\nget argument<br>\n0.47819516218984637<br>\nget argument<br>\n0.15863441851214566</em></p>\n\n<p>При вызове функции <strong>doublePrintByName</strong> значение параметра <strong>не было</strong> вычислено заранее. Тело функции вычислиться, и было напечатано слово <em>start</em>. Далее в теле функции было использован параметр в первый раз, и при этом вычислено значение параметра, была напечатана фраза <em>get argument</em> и случайное число<em>.</em> Далее в теле функции было использован параметр во второй раз, и при этом также вычислено значение параметра, и была напечатана фраза <em>get argument</em> и случайное число во второй раз<em>.</em></p>\n\n<p>Такова <strong>последовательность</strong> выполнения операций при вызове функции с <strong>параметром-запросом</strong>.</p>\n\n<p>Параметр-запрос можно назвать <strong>ленивым</strong> (более точно - нестрогим) параметром. Это означает, что параметр не вычисляться до тех пор пока он не будет действительно использован в цепочке вычислений. Это позволяет ему вычисляется по мере необходимости, что снижает объем вычислений при вызове функции. Возможно он вообще <strong>не будет вычислен никогда</strong>, если цепочка вычислений пойдет по пути, где этот параметр не используется. С другой стороны, при использовании его несколько раз, он будет вычислен так же <strong>несколько раз</strong>.</p>\n\n<p>Использование параметра-запроса - это <strong>императивный стиль</strong> программирования, который уделяет внимание <strong>последовательности</strong> выполнения операций. Тем не менее, в некоторых случаях, для оптимизации работы с внешними ресурсами бывает удобно использовать эту возможность.</p>\n\n<h2 style=\"text-align: center;\">Несколько разных видов параметров в одной функции</h2>\n\n<p><strong>Допускается </strong>использовать <strong>несколько</strong> видов параметров в одной функции. При этом, поведение параметров полностью <strong>независимо</strong> друг от друга.</p>\n\n<p>Пример:</p>\n\n<pre><code class=\"language-scala\">// определение функции с разными видами параметров\ndef doublePrint(param1: Double, param2: =&gt; Double): Unit = ???</code></pre>",
  "video" : null,
  "options" : {
    
  },
  "subtitle_files" : [
  ],
  "is_deprecated" : false
}
```

</details>
