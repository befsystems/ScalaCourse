# Материал (Шаг 3)

## Информация о шаге

- **ID шага**: 5462169
- **Позиция**: 3
- **Тип**: text
- **Курс**: Функциональная Scala 3 для начинающих
- **Экспортирован**: 2025-12-20T22:21:11.369414

## Содержание

# Каррирование

**Каррирование** (currying) — это преобразование функции с несколькими аргументами в последовательность функций, принимающих **только один** аргумент. Каждая функция возвращает другую функцию, которая принимает следующий аргумент.

### Преобразование обычной функции в каррированную

def add(x: Int, y: Int): Int = x + y // обычная функция с двумя параметрами
val addFunction: (Int, Int) => Int = add // функциональный тип этой функции
val curriedAdd: Int => Int => Int = addFunction.curried // каррирование функции

Операция `curried` выполняет преобразование функции:

- Изначальный тип: `(Int, Int) => Int` — функция с двумя параметрами

- Каррированный тип: `Int => Int => Int` — цепочка функций с одним параметром

### Использование каррированной функции

val addFive: Int => Int = curriedAdd(5) // фиксируем первый аргумент, получаем функцию с одним параметром
val result: Int = addFive(3) // применяем второй аргумент, результат: 8

// Или можно применить сразу оба аргумента
val directResult: Int = curriedAdd(5)(3) // результат: 8

### Изначально каррированные функции

В Scala можно определять функции сразу в каррированном виде, с помощью групп параметров:

def multiply(x: Int)(y: Int): Int = x * y
val multiplyFunction: Int => Int => Int = multiply

// Использование
val double: Int => Int = multiply(2) // функция удваивания
val doubled = double(4) // результат: 8

### **Историческая справка**

Термин **каррирование** (currying) создан в честь Хаскелла Карри (1900-1982), американского математика и логика, внёсшего значительный вклад в развитие комбинаторной логики и λ-исчисления.

## Практические применения

### 1. Частичное применение аргументов

Фиксировать часть аргументов и создавать новые, более специализированные функции. Аргументы могут передаваться поэтапно, что полезно для отложенных операций или асинхронных сценариев (**ленивые вычисления**).

def log(level: String)(message: String): Unit =
println(s"[$level] $message")

val error = log("ERROR") // частично применённая функция
val info = log("INFO")

error("Database connection failed") // [ERROR] Database connection failed
info("Application started") // [INFO] Application started

Обычное частичное применение аргументов (без каррирования) позволяет добиться аналогичного результата, но с каррированием это более математически правильно и наглядней.

### 2. Конфигурирование функций

Создание шаблонных функций для повторного использования в разных контекстах.

def calculate(operation: String)(x: Double)(y: Double): Double = operation match {
case "add" => x + y
case "multiply" => x * y
case "subtract" => x - y
case _ => throw new IllegalArgumentException("Unknown operation")
}

val adder = calculate("add")
val multiplier = calculate("multiply")

val sum = adder(10)(5) // 15.0
val product = multiplier(3)(4) // 12.0

### 3. Композиция функций с несколькими параметрами

Для композиции функций требуется, чтобы функции были с одним параметром. Каррирование позволяет решить эту проблему, делая все функции с одним параметром:

// Каррированные функции для обработки данных
def add(x: Int)(y: Int): Int = x + y
def multiply(x: Int)(y: Int): Int = x * y
def power(base: Int)(exponent: Int): Int = math.pow(base, exponent).toInt

// Создаём специализированные функции
val addTen = add(10)
val double = multiply(2)
val square = power(_)(2) // возводим в квадрат

// Используем композицию функций
val pipeline: Int => Int = addTen andThen square andThen double
val sameResult = pipeline(5) // 450

### 4. Абстрактные библиотеки и функторы

Каррирование помогает создавать функциональные библиотеки, которые работают единообразно с любыми абстрактными типами данных (функторы, монады, контейнеры). Многие операции над контейнерами (как `map`, `flatMap`, `filter`) естественным образом каррированы, и часто принимают лямбда-функцию как** **свой** последний** параметр, что естественно подходит для каррирования.

## Каррирование vs Частичное применение

Важно различать каррирование и частичное применение:

// Каррирование - преобразование структуры функции
def uncurried(x: Int, y: Int, z: Int): Int = x + y + z
val curried: Int => Int => Int => Int = uncurried.curried

// Частичное применение - фиксация некоторых аргументов
val partiallyApplied = uncurried(1, _, _) // фиксируем первый аргумент

## Рекомендации по использованию

**Используйте каррирование когда**:

- Часто применяете функцию с одними и теми же начальными аргументами

- Создаёте DSL (Domain Specific Language)

- Работаете с функциями высшего порядка

- Нужно улучшить композицию функций

Каррирование — мощный инструмент функционального программирования в Scala 3, который делает код более **гибким** и **декларативным**. Однако важно использовать его разумно и обоснованно, чтобы не снижать читаемость кода.

---

### Полные данные JSON

<details>
<summary>Показать JSON данные</summary>

```json
{
  "name" : "text",
  "text" : "<h1 style=\"text-align:center;\">Каррирование</h1>\n\n<p><strong>Каррирование</strong> (currying) — это преобразование функции с несколькими аргументами в последовательность функций, принимающих <strong>только один</strong> аргумент. Каждая функция возвращает другую функцию, которая принимает следующий аргумент.</p>\n\n<h3>Преобразование обычной функции в каррированную</h3>\n\n<pre><code class=\"language-scala\">def add(x: Int, y: Int): Int = x + y        // обычная функция с двумя параметрами\nval addFunction: (Int, Int) =&gt; Int = add    // функциональный тип этой функции \nval curriedAdd: Int =&gt; Int =&gt; Int = addFunction.curried  // каррирование функции</code></pre>\n\n<p>Операция <code>curried</code> выполняет преобразование функции:</p>\n\n<ul>\n\t<li>Изначальный тип: <code>(Int, Int) =&gt; Int</code> — функция с двумя параметрами</li>\n\t<li>Каррированный тип: <code>Int =&gt; Int =&gt; Int</code> — цепочка функций с одним параметром</li>\n</ul>\n\n<h3>Использование каррированной функции</h3>\n\n<pre><code class=\"language-scala\">val addFive: Int =&gt; Int = curriedAdd(5)  // фиксируем первый аргумент, получаем функцию с одним параметром\nval result: Int = addFive(3)             // применяем второй аргумент, результат: 8\n\n// Или можно применить сразу оба аргумента\nval directResult: Int = curriedAdd(5)(3) // результат: 8</code></pre>\n\n<h3>Изначально каррированные функции</h3>\n\n<p>В Scala можно определять функции сразу в каррированном виде, с помощью групп параметров:</p>\n\n<pre><code class=\"language-scala\">def multiply(x: Int)(y: Int): Int = x * y\nval multiplyFunction: Int =&gt; Int =&gt; Int = multiply\n\n// Использование\nval double: Int =&gt; Int = multiply(2)  // функция удваивания\nval doubled = double(4)               // результат: 8</code></pre>\n\n<h3><strong>Историческая справка</strong></h3>\n\n<p>Термин <strong>каррирование</strong> (currying) создан в честь Хаскелла Карри (1900-1982), американского математика и логика, внёсшего значительный вклад в развитие комбинаторной логики и λ-исчисления.</p>\n\n<h2 style=\"text-align:center;\">Практические применения</h2>\n\n<h3>1. Частичное применение аргументов</h3>\n\n<p>Фиксировать часть аргументов и создавать новые, более специализированные функции. Аргументы могут передаваться поэтапно, что полезно для отложенных операций или асинхронных сценариев (<strong>ленивые вычисления</strong>).</p>\n\n<pre><code class=\"language-scala\">def log(level: String)(message: String): Unit = \n  println(s\"[$level] $message\")\n\nval error = log(\"ERROR\")    // частично применённая функция\nval info = log(\"INFO\")\n\nerror(\"Database connection failed\")  // [ERROR] Database connection failed\ninfo(\"Application started\")          // [INFO] Application started</code></pre>\n\n<p>Обычное частичное применение аргументов (без каррирования) позволяет добиться аналогичного результата, но с каррированием это более математически правильно и наглядней.</p>\n\n<h3>2. Конфигурирование функций</h3>\n\n<p>Создание шаблонных функций для повторного использования в разных контекстах.</p>\n\n<pre><code class=\"language-scala\">def calculate(operation: String)(x: Double)(y: Double): Double = operation match {\n  case \"add\" =&gt; x + y\n  case \"multiply\" =&gt; x * y\n  case \"subtract\" =&gt; x - y\n  case _ =&gt; throw new IllegalArgumentException(\"Unknown operation\")\n}\n\nval adder = calculate(\"add\")\nval multiplier = calculate(\"multiply\")\n\nval sum = adder(10)(5)      // 15.0\nval product = multiplier(3)(4)  // 12.0</code></pre>\n\n<h3>3. Композиция функций с несколькими параметрами</h3>\n\n<p>Для композиции функций требуется, чтобы функции были с одним параметром. Каррирование позволяет решить эту проблему, делая все функции с одним параметром:</p>\n\n<pre><code class=\"language-scala\">// Каррированные функции для обработки данных\ndef add(x: Int)(y: Int): Int = x + y\ndef multiply(x: Int)(y: Int): Int = x * y\ndef power(base: Int)(exponent: Int): Int = math.pow(base, exponent).toInt\n\n// Создаём специализированные функции\nval addTen = add(10)\nval double = multiply(2)\nval square = power(_)(2)  // возводим в квадрат\n\n// Используем композицию функций\nval pipeline: Int =&gt; Int = addTen andThen square andThen double\nval sameResult = pipeline(5) // 450</code></pre>\n\n<h3>4. Абстрактные библиотеки и функторы</h3>\n\n<p>Каррирование помогает создавать функциональные библиотеки, которые работают единообразно с любыми абстрактными типами данных (функторы, монады, контейнеры). Многие операции над контейнерами (как <code>map</code>, <code>flatMap</code>, <code>filter</code>) естественным образом каррированы, и часто принимают лямбда-функцию как<strong> </strong>свой<strong> последний</strong> параметр, что естественно подходит для каррирования.</p>\n\n<h2 style=\"text-align:center;\">Каррирование vs Частичное применение</h2>\n\n<p>Важно различать каррирование и частичное применение:</p>\n\n<pre><code class=\"language-scala\">// Каррирование - преобразование структуры функции\ndef uncurried(x: Int, y: Int, z: Int): Int = x + y + z\nval curried: Int =&gt; Int =&gt; Int =&gt; Int = uncurried.curried\n\n// Частичное применение - фиксация некоторых аргументов\nval partiallyApplied = uncurried(1, _, _)  // фиксируем первый аргумент</code></pre>\n\n<h2 style=\"text-align:center;\">Рекомендации по использованию</h2>\n\n<p><strong>Используйте каррирование когда</strong>:</p>\n\n<ul>\n\t<li>Часто применяете функцию с одними и теми же начальными аргументами</li>\n\t<li>Создаёте DSL (Domain Specific Language)</li>\n\t<li>Работаете с функциями высшего порядка</li>\n\t<li>Нужно улучшить композицию функций</li>\n</ul>\n\n<p>Каррирование — мощный инструмент функционального программирования в Scala 3, который делает код более <strong>гибким</strong> и <strong>декларативным</strong>. Однако важно использовать его разумно и обоснованно, чтобы не снижать читаемость кода.</p>",
  "video" : null,
  "options" : {
    
  },
  "subtitle_files" : [
  ],
  "is_deprecated" : false
}
```

</details>
