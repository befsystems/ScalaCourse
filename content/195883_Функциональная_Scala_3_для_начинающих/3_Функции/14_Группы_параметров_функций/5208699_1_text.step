{
  "step_id" : 5208699,
  "lesson_id" : 1255297,
  "position" : 1,
  "type" : "unknown",
  "block" : {
    "name" : "text",
    "text" : "<h1 style=\"text-align:center;\">Группы параметров функций</h1>\n\n<p>Функции могут определяться с <strong>несколькими</strong> списками параметров (группы параметров). Каждый список параметров обозначается<strong> </strong>отдельными <strong>круглыми скобками</strong>.</p>\n\n<p>Пример:</p>\n\n<pre><code class=\"language-scala\">def multiAdd(param1: Int, param2: Int)(param3: Int, param4: Int): Int = (param1 + param2) * (param3 + param4)</code></pre>\n\n<p>где:</p>\n\n<ul>\n\t<li><strong>(param1: Int, param2: Int)</strong> - первый список параметров</li>\n\t<li><strong>(param3: Int, param4: Int)</strong> - второй список параметров</li>\n</ul>\n\n<p>Количество списков параметров и количество параметров в списке - <strong>без ограничений</strong>. В теле функции все параметры используются по их именам, <strong>без уточнения</strong>, из какой они группы.<strong> </strong></p>\n\n<p>На самом деле, у математической функции может быть только одна группа параметров. Но функцию с несколькими группами параметров можно рассматривать как последовательное преобразование функций с первой группой параметров, в функцию со второй группой параметров, и так до последней группы. Об этом нам говорит функциональный тип:</p>\n\n<pre><code class=\"language-scala\">val fun: (Int, Int) =&gt; (Int, Int) =&gt; Int = multiAdd</code></pre>\n\n<p>Преобразования из функции в функцию (создание новой функции) происходят при вызове функции с заполненной группой параметров.</p>\n\n<h2 style=\"text-align:center;\">Преобразование одной группы параметров функции в несколько групп</h2>\n\n<p>Предположим, что определена функция с одной группой параметров. Но может возникнуть потребность разбиение параметров на группы, не меняя  исходное определение функции. Тогда необходимо определить новую функцию, используя исходную:</p>\n\n<pre><code class=\"language-scala\">// определение функции с одной группой параметров\ndef sum(param1: Int, param2: Int, param3: Int): Int = \n  param1 + param2 + param3 \n\n// определение функции с двумя группами параметров используя исходную функцию\ndef sumGroup(param1: Int, param2: Int)(param3: Int): Int = \n  sum(param1, param2, param3)\n\n\n// посмотрим на функциональные типы исходной и новой функций \nval sumFun: (Int, Int, Int) =&gt; Int = sum\nval sumGroupFun: (Int, Int) =&gt; Int =&gt; Int = sumGroup</code></pre>\n\n<p>Функциональные типы отличаются, но в итоге, количество параметров совпадает.</p>\n\n<h2 style=\"text-align:center;\">Использование групп параметров</h2>\n\n<p>Использование групп параметров разнообразно, но основных назначений два первых:</p>\n\n<h3 style=\"text-align:center;\">Специальный синтаксис указания аргумента функций</h3>\n\n<p>Если выделить параметр функционального типа или параметр-запрос в отдельную группу, то можно использовать специальный синтаксис указания аргумента функции с <strong>фигурными скобками</strong>. Такой синтаксис позволяет удобно указывать большие выражения как аргументы функции при её вызове.</p>\n\n<p>Пример с функциональным выражением в качестве параметра:</p>\n\n<pre><code class=\"language-scala\">// Определение функции с двумя группами параметров\ndef add(param1: Int, param2: Int)(param3: Int =&gt; Int): Int = \n  param3(param1) + param2\n\n// Вызов метода add с указанием функционального выражения для параметра param3\nval res = add(1, 2){ param =&gt;\n  param * 2 \n}</code></pre>\n\n<p>Пример с параметром-запросом:</p>\n\n<pre><code class=\"language-scala\">// Определение функции с двумя группами параметров\ndef add(param1: Int, param2: Int)(param3: =&gt; Double): Double =\n  param3 + param2 + param1 + param3\n\n// Вызов метода add с указанием выражения для параметра param3\nval res = add(1, 2){\n  val arg = random()\n  println(arg)\n  arg\n}</code></pre>\n\n<p>Выражений как аргументов может быть несколько, и для каждого нужна отдельная группа.</p>\n\n<p>Пример с двумя функциональными параметрами:</p>\n\n<pre><code class=\"language-scala\">// Определение функции с тремя группами параметров\ndef add(param1: Int)(param2: Int =&gt; Int)(param3: Int =&gt; Double): Double = \n  param3(param1) + param2(param1)\n\n// Вызов метода add с указанием функционального выражения для параметров param2 и param3\nval res = add(1){ param =&gt;\n  param * 2 \n} { param =&gt;\n  param * 3\n}</code></pre>\n\n<p>При отсутствии отдельных групп в функции, её также можно было бы вызвать с аргументами-выражениями, но это бы было более многословно.</p>\n\n<h3 style=\"text-align:center;\">Разделение параметров разных видов</h3>\n\n<p>Параметры разных видов можно определять только в разных группах параметров.</p>\n\n<p>Пример с явными и контекстными параметрами:</p>\n\n<pre><code class=\"language-scala\">def go(x: Int)(using y: Int) = ???</code></pre>\n\n<p><strong>Контекстные</strong> параметры - это параметры особого вида (из контекстной области видимости), который обязательно должен быть выделен в отдельную группу параметров. Контекстные параметры будут изучаться позже.</p>\n\n<h3 style=\"text-align:center;\">Вычисление значения параметра по умолчанию</h3>\n\n<pre><code class=\"language-scala\">def g(x: Int)(y: Int = x * 2) = x + y</code></pre>\n\n<p>Только в разных группах должны быть параметры x и y, чтобы можно было бы вычислить значение по умолчанию.</p>\n\n<h3 style=\"text-align:center;\">Нужны несколько параметров переменной длины</h3>\n\n<p>Вообще это запрещено, но в разных группах можно:</p>\n\n<pre><code class=\"language-scala\">def foo(as: Int*)(bs: Int*)(cs: Int*) = as.sum * bs.sum * cs.sum</code></pre>\n\n<h3 style=\"text-align:center;\">Явное указание на особенность параметра</h3>\n\n<p>Если выделить параметр в отдельную группу, то этим можно подчеркнуть его исключительность по отношению к другим параметрам, и заставить обратить на это внимание.</p>\n\n<p>Например, можно догадаться, что это функция должна использоваться для создания другой функции:</p>\n\n<pre><code class=\"language-scala\">def add(a: Int)(b: Int): Int = a + b  // Функция с двумя группами, намек на предназначение функции создавать другие функции  \nval fun: Int =&gt; Int = add(1) // Создание функции\nval res = fun(2)             // Вызов функции</code></pre>\n\n<pre> </pre>\n\n<div class=\"notranslate\" style=\"\"> </div>",
    "video" : null,
    "options" : {
      
    },
    "subtitle_files" : [
    ],
    "is_deprecated" : false
  },
  "name" : "text",
  "course_id" : 195883,
  "course_name" : "Функциональная Scala 3 для начинающих",
  "exported_at" : "2025-12-20T22:21:11.3614773"
}