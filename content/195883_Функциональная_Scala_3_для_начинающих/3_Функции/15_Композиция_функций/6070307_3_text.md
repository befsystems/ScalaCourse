# Материал (Шаг 3)

## Информация о шаге

- **ID шага**: 6070307
- **Позиция**: 3
- **Тип**: text
- **Курс**: Функциональная Scala 3 для начинающих
- **Экспортирован**: 2025-12-20T22:21:23.9791026

## Содержание

# Применение композиций

### Композиция с тождественной функцией

Композиция с тождественной функцией не изменяет поведение основной функции. Это свойство важно в математике и функциональном программировании для создания более гибких и модульных программ, где тождественные функции могут служить "нулевым" элементом композиции — то есть композируемой функцией, которая не влияет на конечный результат.

def identity(x: Int): Int = x // тождественная функция
def addOne(x: Int): Int = x + 1 // прикладная функция
val composedFun = addOne compose identity // Композиция тождественной функции и функции addOne
println(composedFun(5)) // Результат: 6 // Пример вызова
val composedFun2 = identity compose addOne // Композиция в обратном порядке
println(composedFun2(5)) // Результат: 6 // Пример вызова

В обоих случаях результат будет 6, так как тождественная функция не изменяет значения

[(тождественная функция - см. урок 3.1](https://stepik.org/edit-lesson/1247175/step/2))

### Композиция с обратной функцией

В Scala можно реализовать обратные функции и использовать их в композиции.

val f = (x: Int) => x + 1 // прямая функция
val inverseF = (y: Int) => y - 1 // обратная функция

val identity = f.andThen(inverseF) // функция дает гарантировано исходный результат, для любого аргумента
println(identity(5)) // Результат: 5, так как f и inverseF взаимно обратны

[(обратная функция - см. урок 3.1](https://stepik.org/edit-lesson/1247175/step/3))

### Цепочка композиций

**Цепочка композиций** — это выстраивание композиций в длинную цепочку. Это позволяет наглядно видеть последовательность композиций.

def addOne(x: Int): Int = x + 1
def multiplyByTwo(x: Int): Int = x * 2
def subtractThree(x: Int): Int = x - 3
def identity(x: Int): Int = x

// Создаем цепочку композиций функций
val composedFunction: Int => Int = addOne andThen multiplyByTwo andThen subtractThree andThen identity

// Пример вызова композиции функций
println(composedFunction(5)) // Результат: 5 + 1 = 6 -> 6 * 2 = 12 -> 12 - 3 = 9 -> 9

### Конструктор композиции

Создадим конструктор композиции для большого набора функций. В качестве набора функций выступит кортеж функций. В результате композиции всех функций из набора получим итоговую функцию, которая объединяет все операции исходных функций. Композировать функции будем рекурсивно.

// Исходный набор функций
val tuple: (Int => Int, Int => Int, Int => Int, Int => Int, Int => Int, Int => Int) =
(
(x: Int) => x + 1,
(x: Int) => x + 2,
(x: Int) => x + 3,
(x: Int) => x + 4,
(x: Int) => x + 5,
(x: Int) => x + 6,
)

// Тождественная функция нужна как начальный элемент
def identity(x: Int): Int = x

// Рекурсивный конструктор функций
def constructFun(
tuple: (Int => Int, Int => Int, Int => Int, Int => Int, Int => Int, Int => Int),
index: Int,
accFun: Int => Int
): Int => Int = {
if tuple.productArity <= index then
accFun // выход из рекурсии
else
// получение очередной функции из кортежа
// операция asInstanceOf[Int => Int] нужна для коррекции функционального типа после операции productElement
// (это особенность извлечения элемента из кортежа)
val fun: Int => Int = tuple.productElement(index).asInstanceOf[Int => Int]
// Композиция функции-аккумулятора рекурсии и текущей функции
val newAcc = accFun andThen fun
// Рекурсивный вызов себя (конструктора функций)
constructFun(tuple, index + 1, newAcc)
// Конструктор возвращает итоговую функцию рекурсии
}

// Запуск конструктора, получаем итоговую функцию
val chainedFun: Int => Int = constructFun(tuple, 0, identity)

//Запуск итоговой функции с аргументом 0
println(chainedFun(0)) //результат 21

---

### Полные данные JSON

<details>
<summary>Показать JSON данные</summary>

```json
{
  "name" : "text",
  "text" : "<h1 style=\"text-align:center;\">Применение композиций</h1>\n\n<h3 style=\"text-align:center;\">Композиция с тождественной функцией</h3>\n\n<p>Композиция с тождественной функцией не изменяет поведение основной функции. Это свойство важно в математике и функциональном программировании для создания более гибких и модульных программ, где тождественные функции могут служить \"нулевым\" элементом композиции — то есть композируемой функцией, которая не влияет на конечный результат.</p>\n\n<pre><code class=\"language-scala\">def identity(x: Int): Int = x  // тождественная функция\ndef addOne(x: Int): Int = x + 1 // прикладная функция\nval composedFun = addOne compose identity // Композиция тождественной функции и функции addOne\nprintln(composedFun(5))  // Результат: 6 // Пример вызова\nval composedFun2 = identity compose addOne // Композиция в обратном порядке\nprintln(composedFun2(5))  // Результат: 6 // Пример вызова</code></pre>\n\n<p>В обоих случаях результат будет 6, так как тождественная функция не изменяет значения</p>\n\n<p><a href=\"https://stepik.org/edit-lesson/1247175/step/2\" rel=\"noopener noreferrer nofollow\">(тождественная функция - см. урок 3.1</a>)</p>\n\n<h3 style=\"text-align:center;\">Композиция с обратной функцией</h3>\n\n<p>В Scala можно реализовать обратные функции и использовать их в композиции.</p>\n\n<pre><code class=\"language-scala\">val f = (x: Int) =&gt; x + 1         // прямая функция  \nval inverseF = (y: Int) =&gt; y - 1  // обратная функция\n\nval identity = f.andThen(inverseF)  // функция дает гарантировано исходный результат, для любого аргумента\nprintln(identity(5))  // Результат: 5, так как f и inverseF взаимно обратны</code></pre>\n\n<p><a href=\"https://stepik.org/edit-lesson/1247175/step/3\" rel=\"noopener noreferrer nofollow\">(обратная функция&nbsp; - см. урок 3.1</a>)</p>\n\n<h3 style=\"text-align:center;\">Цепочка композиций</h3>\n\n<p><strong>Цепочка композиций</strong> — это выстраивание композиций в длинную цепочку. Это позволяет наглядно видеть последовательность композиций.</p>\n\n<pre><code class=\"language-scala\">def addOne(x: Int): Int = x + 1\ndef multiplyByTwo(x: Int): Int = x * 2\ndef subtractThree(x: Int): Int = x - 3\ndef identity(x: Int): Int = x  \n\n// Создаем цепочку композиций функций\nval composedFunction: Int =&gt; Int = addOne andThen multiplyByTwo andThen subtractThree andThen identity\n\n// Пример вызова композиции функций\nprintln(composedFunction(5)) // Результат: 5 + 1 = 6 -&gt; 6 * 2 = 12 -&gt; 12 - 3 = 9 -&gt; 9</code></pre>\n\n<h3 style=\"text-align:center;\">Конструктор композиции</h3>\n\n<p>Создадим конструктор композиции для большого набора функций. В качестве набора функций выступит кортеж функций. В результате композиции всех функций из набора получим итоговую функцию, которая объединяет все операции исходных функций. Композировать функции будем рекурсивно.</p>\n\n<pre><code class=\"language-scala\">// Исходный набор функций\nval tuple: (Int =&gt; Int, Int =&gt; Int, Int =&gt; Int, Int =&gt; Int, Int =&gt; Int, Int =&gt; Int) = \n  (\n    (x: Int) =&gt; x + 1,\n    (x: Int) =&gt; x + 2,\n    (x: Int) =&gt; x + 3,\n    (x: Int) =&gt; x + 4,\n    (x: Int) =&gt; x + 5,\n    (x: Int) =&gt; x + 6,\n  )\n\n// Тождественная функция нужна как начальный элемент\ndef identity(x: Int): Int = x  \n\n// Рекурсивный конструктор функций\ndef constructFun(\n                 tuple: (Int =&gt; Int, Int =&gt; Int, Int =&gt; Int, Int =&gt; Int, Int =&gt; Int, Int =&gt; Int),\n                 index: Int,\n                 accFun: Int =&gt; Int\n                ): Int =&gt; Int = {\n  if tuple.productArity &lt;= index then\n    accFun  // выход из рекурсии\n  else\n    // получение очередной функции из кортежа\n    // операция asInstanceOf[Int =&gt; Int] нужна для коррекции функционального типа после операции productElement\n    // (это особенность извлечения элемента из кортежа) \n    val fun: Int =&gt; Int = tuple.productElement(index).asInstanceOf[Int =&gt; Int]\n    // Композиция функции-аккумулятора рекурсии и текущей функции\n    val newAcc = accFun andThen fun\n    // Рекурсивный вызов себя (конструктора функций)\n    constructFun(tuple, index + 1, newAcc)\n    // Конструктор возвращает итоговую функцию рекурсии\n}\n\n// Запуск конструктора, получаем итоговую функцию\nval chainedFun: Int =&gt; Int = constructFun(tuple, 0, identity)\n\n//Запуск итоговой функции с аргументом 0\nprintln(chainedFun(0))  //результат 21</code></pre>",
  "video" : null,
  "options" : {
    
  },
  "subtitle_files" : [
  ],
  "is_deprecated" : false
}
```

</details>
