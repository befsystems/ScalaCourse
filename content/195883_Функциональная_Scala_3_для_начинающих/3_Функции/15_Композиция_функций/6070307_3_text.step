{
  "step_id" : 6070307,
  "lesson_id" : 1458232,
  "position" : 3,
  "type" : "unknown",
  "block" : {
    "name" : "text",
    "text" : "<h1 style=\"text-align:center;\">Применение композиций</h1>\n\n<h3 style=\"text-align:center;\">Композиция с тождественной функцией</h3>\n\n<p>Композиция с тождественной функцией не изменяет поведение основной функции. Это свойство важно в математике и функциональном программировании для создания более гибких и модульных программ, где тождественные функции могут служить \"нулевым\" элементом композиции — то есть композируемой функцией, которая не влияет на конечный результат.</p>\n\n<pre><code class=\"language-scala\">def identity(x: Int): Int = x  // тождественная функция\ndef addOne(x: Int): Int = x + 1 // прикладная функция\nval composedFun = addOne compose identity // Композиция тождественной функции и функции addOne\nprintln(composedFun(5))  // Результат: 6 // Пример вызова\nval composedFun2 = identity compose addOne // Композиция в обратном порядке\nprintln(composedFun2(5))  // Результат: 6 // Пример вызова</code></pre>\n\n<p>В обоих случаях результат будет 6, так как тождественная функция не изменяет значения</p>\n\n<p><a href=\"https://stepik.org/edit-lesson/1247175/step/2\" rel=\"noopener noreferrer nofollow\">(тождественная функция - см. урок 3.1</a>)</p>\n\n<h3 style=\"text-align:center;\">Композиция с обратной функцией</h3>\n\n<p>В Scala можно реализовать обратные функции и использовать их в композиции.</p>\n\n<pre><code class=\"language-scala\">val f = (x: Int) =&gt; x + 1         // прямая функция  \nval inverseF = (y: Int) =&gt; y - 1  // обратная функция\n\nval identity = f.andThen(inverseF)  // функция дает гарантировано исходный результат, для любого аргумента\nprintln(identity(5))  // Результат: 5, так как f и inverseF взаимно обратны</code></pre>\n\n<p><a href=\"https://stepik.org/edit-lesson/1247175/step/3\" rel=\"noopener noreferrer nofollow\">(обратная функция&nbsp; - см. урок 3.1</a>)</p>\n\n<h3 style=\"text-align:center;\">Цепочка композиций</h3>\n\n<p><strong>Цепочка композиций</strong> — это выстраивание композиций в длинную цепочку. Это позволяет наглядно видеть последовательность композиций.</p>\n\n<pre><code class=\"language-scala\">def addOne(x: Int): Int = x + 1\ndef multiplyByTwo(x: Int): Int = x * 2\ndef subtractThree(x: Int): Int = x - 3\ndef identity(x: Int): Int = x  \n\n// Создаем цепочку композиций функций\nval composedFunction: Int =&gt; Int = addOne andThen multiplyByTwo andThen subtractThree andThen identity\n\n// Пример вызова композиции функций\nprintln(composedFunction(5)) // Результат: 5 + 1 = 6 -&gt; 6 * 2 = 12 -&gt; 12 - 3 = 9 -&gt; 9</code></pre>\n\n<h3 style=\"text-align:center;\">Конструктор композиции</h3>\n\n<p>Создадим конструктор композиции для большого набора функций. В качестве набора функций выступит кортеж функций. В результате композиции всех функций из набора получим итоговую функцию, которая объединяет все операции исходных функций. Композировать функции будем рекурсивно.</p>\n\n<pre><code class=\"language-scala\">// Исходный набор функций\nval tuple: (Int =&gt; Int, Int =&gt; Int, Int =&gt; Int, Int =&gt; Int, Int =&gt; Int, Int =&gt; Int) = \n  (\n    (x: Int) =&gt; x + 1,\n    (x: Int) =&gt; x + 2,\n    (x: Int) =&gt; x + 3,\n    (x: Int) =&gt; x + 4,\n    (x: Int) =&gt; x + 5,\n    (x: Int) =&gt; x + 6,\n  )\n\n// Тождественная функция нужна как начальный элемент\ndef identity(x: Int): Int = x  \n\n// Рекурсивный конструктор функций\ndef constructFun(\n                 tuple: (Int =&gt; Int, Int =&gt; Int, Int =&gt; Int, Int =&gt; Int, Int =&gt; Int, Int =&gt; Int),\n                 index: Int,\n                 accFun: Int =&gt; Int\n                ): Int =&gt; Int = {\n  if tuple.productArity &lt;= index then\n    accFun  // выход из рекурсии\n  else\n    // получение очередной функции из кортежа\n    // операция asInstanceOf[Int =&gt; Int] нужна для коррекции функционального типа после операции productElement\n    // (это особенность извлечения элемента из кортежа) \n    val fun: Int =&gt; Int = tuple.productElement(index).asInstanceOf[Int =&gt; Int]\n    // Композиция функции-аккумулятора рекурсии и текущей функции\n    val newAcc = accFun andThen fun\n    // Рекурсивный вызов себя (конструктора функций)\n    constructFun(tuple, index + 1, newAcc)\n    // Конструктор возвращает итоговую функцию рекурсии\n}\n\n// Запуск конструктора, получаем итоговую функцию\nval chainedFun: Int =&gt; Int = constructFun(tuple, 0, identity)\n\n//Запуск итоговой функции с аргументом 0\nprintln(chainedFun(0))  //результат 21</code></pre>",
    "video" : null,
    "options" : {
      
    },
    "subtitle_files" : [
    ],
    "is_deprecated" : false
  },
  "name" : "text",
  "course_id" : 195883,
  "course_name" : "Функциональная Scala 3 для начинающих",
  "exported_at" : "2026-01-10T10:17:20.8133597"
}