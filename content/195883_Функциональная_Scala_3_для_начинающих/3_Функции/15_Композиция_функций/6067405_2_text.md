# Материал (Шаг 2)

## Информация о шаге

- **ID шага**: 6067405
- **Позиция**: 2
- **Тип**: text
- **Курс**: Функциональная Scala 3 для начинающих
- **Экспортирован**: 2025-12-20T22:21:23.9781108

## Содержание

# Композиции функций в Scala

Композиция функций в Scala реализуется с помощью операций`compose` и `andThen`. Эти операции позволяют объединять две функции так, чтобы результат одной функции передавался в качестве аргумента другой. Операции определены только для  функций с одним параметром.

### Операция **compose**

Синтаксис**:   ` f compose g`**

Сначала вызывается функция `g`, затем результат передаётся в функцию `f`.

Пример:

val f = (x: Int) => x + 2
val g = (x: Int) => x * 2

val composed: Int => Int = f compose g // f(g(x))

println(composed(3)) // Результат: f(g(3)) = f(6) = 8

### Операция **andThen**

Синтаксис**:      `f andThen g`**

Сначала вызывается функция `f`, затем её результат передаётся в функцию `g`.

Пример:

val f = (x: Int) => x + 2
val g = (x: Int) => x * 2

val chained: Int => Int = f andThen g // g(f(x))

println(chained(3)) // Результат: g(f(3)) = g(5) = 10

### Одинаковые типы результата и параметра

Композиция возможна только если одинаковые типы результата первой функции и параметра следующей функции.

Например, одна функция выдает целые числа, а другая — вещественные числа. Тогда:

val f: Int => Int = x => x / 2
val g: Int => Double = x => sqrt(x)

val res = g andThen f // компилятор выдаст ошибку для неверного типа
val res2 = f andThen g // успешная композиция функций

println(res2(6)) // f(6) = 3, g(3) = 1.7320508075688772

### Использование каррирования для композиции

Когда функция имеет несколько параметров, часто используется **каррирование** — техника, при которой функция с несколькими параметрами превращается в цепочку функций, каждая из которых принимает один параметр. Это даёт возможность использовать для композиции функцию с несколькими параметрами.

def f1(x: Int): Int = x * 2
def f2(x: Int, y: Int): Int = x + y

val f3: Int => Int => Int = f2.curried // преобразование в каррированую функцию

val res2: Int => Int => Int = f1 andThen f3 // успешно композируем функции,
//результат первой функции используется как аргумент для первого параметра второй функции

println(res2(1)(3)) // результат 5 1 * 2 = 2 => 2 + 3 = 5

---

### Полные данные JSON

<details>
<summary>Показать JSON данные</summary>

```json
{
  "name" : "text",
  "text" : "<h1 style=\"text-align: center;\">Композиции функций в Scala</h1>\n\n<p>Композиция функций в Scala реализуется с помощью операций<code>compose</code> и <code>andThen</code>. Эти операции позволяют объединять две функции так, чтобы результат одной функции передавался в качестве аргумента другой. Операции определены только для  функций с одним параметром.</p>\n\n<h3 style=\"text-align: center;\">Операция <strong>compose</strong></h3>\n\n<p>Синтаксис<strong>:   <code> f compose g</code></strong></p>\n\n<p>Сначала вызывается функция <code>g</code>, затем результат передаётся в функцию <code>f</code>.</p>\n\n<p>Пример:</p>\n\n<pre><code class=\"language-scala\">val f = (x: Int) =&gt; x + 2\nval g = (x: Int) =&gt; x * 2\n\nval composed: Int =&gt; Int = f compose g  // f(g(x))\n\nprintln(composed(3))  // Результат: f(g(3)) = f(6) = 8</code></pre>\n\n<h3 style=\"text-align: center;\">Операция <strong>andThen</strong></h3>\n\n<p>Синтаксис<strong>:      <code>f andThen g</code></strong></p>\n\n<p>Сначала вызывается функция <code>f</code>, затем её результат передаётся в функцию <code>g</code>.</p>\n\n<p>Пример:</p>\n\n<pre><code class=\"language-scala\">val f = (x: Int) =&gt; x + 2\nval g = (x: Int) =&gt; x * 2\n\nval chained: Int =&gt; Int = f andThen g  // g(f(x))\n\nprintln(chained(3))  // Результат: g(f(3)) = g(5) = 10</code></pre>\n\n<h3 style=\"text-align: center;\">Одинаковые типы результата и параметра</h3>\n\n<p>Композиция возможна только если одинаковые типы результата первой функции и параметра следующей функции.</p>\n\n<p>Например, одна функция выдает целые числа, а другая — вещественные числа. Тогда:</p>\n\n<pre><code class=\"language-scala\">val f: Int =&gt; Int = x =&gt; x / 2\nval g: Int =&gt; Double = x =&gt; sqrt(x)\n\nval res = g andThen f // компилятор выдаст ошибку для неверного типа\nval res2 = f andThen g // успешная композиция функций\n \nprintln(res2(6))  // f(6) = 3, g(3) = 1.7320508075688772</code></pre>\n\n<h3 style=\"text-align: center;\">Использование каррирования для композиции</h3>\n\n<p>Когда функция имеет несколько параметров, часто используется <strong>каррирование</strong> — техника, при которой функция с несколькими параметрами превращается в цепочку функций, каждая из которых принимает один параметр. Это даёт возможность использовать для композиции функцию с несколькими параметрами.</p>\n\n<pre><code class=\"language-scala\">def f1(x: Int): Int = x * 2\ndef f2(x: Int, y: Int): Int = x + y\n\nval f3: Int =&gt; Int =&gt; Int = f2.curried // преобразование в каррированую функцию\n\nval res2: Int =&gt; Int =&gt; Int = f1 andThen f3  // успешно композируем функции, \n//результат первой функции используется как аргумент для первого параметра второй функции\n\nprintln(res2(1)(3)) // результат 5    1 * 2 = 2 =&gt; 2 + 3 = 5 </code></pre>",
  "video" : null,
  "options" : {
    
  },
  "subtitle_files" : [
  ],
  "is_deprecated" : false
}
```

</details>
