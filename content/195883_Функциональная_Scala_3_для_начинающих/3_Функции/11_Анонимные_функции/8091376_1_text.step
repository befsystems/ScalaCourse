{
  "step_id" : 8091376,
  "lesson_id" : 1228703,
  "position" : 1,
  "type" : "unknown",
  "block" : {
    "name" : "text",
    "text" : "<h1 style=\"text-align:center;\">Анонимные функции</h1>\n\n<p>В функциональном программировании <strong>анонимные функции</strong> представляют собой фундаментальную концепцию, позволяющую определять вычислительные процедуры без привязки к именованным идентификаторам. Данные конструкции реализуют принципы лямбда-исчисления Алонзо Черча и обеспечивают поддержку функций как объектов первого класса.</p>\n\n<p>Анонимные функции также могут называться <strong>функциональными выражениями</strong>, <strong>функциональными литералами, лямбда-выражениями</strong>, <strong>лямбда-функциями</strong>, в зависимости от контекста их применения. Они часто используются в качестве аргументов других функций или для создания кратких форм функций.</p>\n\n<h2 style=\"text-align:center;\">Определение анонимной функции</h2>\n\n<p>Анонимные функции создаются с использованием синтаксиса, который позволяет определять функции без явного указания имени. Синтаксическая структура анонимной функции определяется следующей грамматикой:</p>\n\n<pre><code class=\"language-scala\">(параметры: Типы) =&gt; выражение</code></pre>\n\n<p><strong>Пример определения анонимной функции:</strong></p>\n\n<pre><code class=\"language-scala\">(x: Int) =&gt; x + 1\n</code></pre>\n\n<p>где:</p>\n\n<ul>\n\t<li><code>(x: Int)</code> — входной параметр <strong>x</strong> типа <code>Int</code></li>\n\t<li><code>=&gt;</code> — знак преобразования входных значений в выходное значение</li>\n\t<li><code>x + 1</code> — тело функции (алгоритм преобразования входного значения). В выражении используем параметр <strong>x</strong> как абстрактное (пока неизвестное) значение для вычисления выражения</li>\n</ul>\n\n<p><strong>Обратите внимание!</strong> Тип выходного значения <strong>при определении</strong> анонимной функции <strong>не указывается</strong>. Он выводится <strong>автоматически</strong> из выражений тела функции. Это сделано для краткости определения функции, так как анонимные функции — это обычно встраиваемые, одноразовые конструкции.</p>\n\n<h2 style=\"text-align:center;\">Функциональные типы</h2>\n\n<p><strong>Функциональные типы</strong> записываются в нотации <code>A =&gt; B</code>, где:</p>\n\n<ul>\n\t<li><code>A</code> — тип входного параметра (домен функции)</li>\n\t<li><code>B</code> — тип возвращаемого значения (кодомен функции)</li>\n</ul>\n\n<p>Функция из ранее приведенного примера имеет тип: <code>Int =&gt; Int</code></p>\n\n<p><strong>Пример функция преобразования символов:</strong></p>\n\n<pre><code class=\"language-scala\">(h: Char) =&gt; h.toUpper\n</code></pre>\n\n<p><strong>Тип</strong> данной функции: <code>Char =&gt; Char</code></p>\n\n<h2 style=\"text-align:center;\">Функции с несколькими параметрами</h2>\n\n<p>Входных параметров у функции может быть <strong>несколько</strong>. Это функции <strong>высшей арности.</strong></p>\n\n<p>Пример:</p>\n\n<pre><code class=\"language-scala\">(x: Int, y: Double) =&gt; x + y\n</code></pre>\n\n<p>где <code>(x: Int, y: Double)</code> — два входных параметра с типами <code>Int</code> и <code>Double</code>.</p>\n\n<p><strong>Тип</strong> этой функции будет:</p>\n\n<pre><code class=\"language-scala\">(Int, Double) =&gt; Double\n</code></pre>\n\n<h2 style=\"text-align:center;\">Функции без параметров</h2>\n\n<p>Входные параметры могут <strong>отсутствовать</strong>. Это <strong>нульарные</strong> или <strong>константные</strong> функции.</p>\n\n<p>Пример:</p>\n\n<pre><code class=\"language-scala\">() =&gt; \"Константное значение\"\n</code></pre>\n\n<p><strong>Тип</strong> этой функции будет:</p>\n\n<pre><code class=\"language-scala\">() =&gt; String\n</code></pre>\n\n<h2 style=\"text-align:center;\">Блоки выражений в теле функции</h2>\n\n<p>Если тело функции состоит из <strong>нескольких</strong> выражений, то образуется блок выражений. Блок выражений обозначается фигурными скобками.</p>\n\n<p>Пример:</p>\n\n<pre><code class=\"language-scala\">(x: Int) =&gt; {\n  val res1 = x + 1\n  val res2 = res1 + 2\n  res2\n}\n</code></pre>\n\n<p>Можно <strong>не использовать</strong> фигурные скобки, если отступы каждого выражения блока от левого края одинаковые:</p>\n\n<pre><code class=\"language-scala\">(x: Int) =&gt; \n  val res1 = x + 1\n  val res2 = res1 + 2\n  res2\n</code></pre>\n\n<h2 style=\"text-align:center;\">Вызов функции</h2>\n\n<p>Вызов анонимной функции выполняется при указании в круглых скобках необходимых аргументов для функции.</p>\n\n<pre><code class=\"language-scala\">val res = ((x: Int) =&gt; x + 1)(2) // аргумент — значение 2, результат — значение 3\n</code></pre>\n\n<p>Определение функции указано вместе с её вызовом.</p>\n\n<p>Можно отделить определение функции и её вызов, если это будет удобнее:</p>\n\n<pre><code class=\"language-scala\">val fun = (x: Int) =&gt; x + 1  // fun — функциональное значение\nval res = fun(2)             // вызов функции, результат — значение 3\n</code></pre>\n\n<p>Можно для наглядности указать все типы значений:</p>\n\n<pre><code class=\"language-scala\">val fun: Int =&gt; Int = (x: Int) =&gt; x + 1\nval res: Int = fun(2)\n</code></pre>\n\n<p>Указание типов значений выполняет роль документирования кода.</p>\n\n<h2 style=\"text-align:center;\"> </h2>",
    "video" : null,
    "options" : {
      
    },
    "subtitle_files" : [
    ],
    "is_deprecated" : false
  },
  "name" : "text",
  "course_id" : 195883,
  "course_name" : "Функциональная Scala 3 для начинающих",
  "exported_at" : "2026-01-10T10:17:15.852998"
}