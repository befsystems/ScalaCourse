# Материал (Шаг 6)

## Информация о шаге

- **ID шага**: 5199557
- **Позиция**: 6
- **Тип**: text
- **Курс**: Функциональная Scala 3 для начинающих
- **Экспортирован**: 2026-01-10T10:17:15.8599208

## Содержание

# Преобразование функций

## Преобразование именованной функции в функциональное значение

Напомним, что именованная функция **не является** значением. Значит она лишена многих полезных свойств, которыми обладает функциональное значение (анонимная функция). Однако можно легко конвертировать уже определенную именованную функцию в функциональное значение.

**Конвертация** произойдет, когда название именованной функции будет **использовано как значение**.

Пример:

def add(a: Int, b: Int) = a + b // Определение именованой функции.

val fun = add // получили функциональное значение fun типа (Int, Int) => Int
val res = fun(1,2) // Вызов (исполнение) функционального значения fun, но фактически функции add

val tuple = (add, 1, 2, 3) // получили кортеж tuple типа ((Int, Int) => Int, Int, Int, Int)

Таким образом конвертация производится совершенно **незаметно**, и именованные функции можно использовать как функциональные значения.

## Преобразование в функцию с меньшим количеством параметров

### **(частично примененная функция)**

Функциональный подход подразумевает частое переиспользование одних и тех же функций в разных расчетах. Для этого функции должны быть достаточно универсальными, что обычно приводит к необходимости большого количества параметров  функции.

Чтобы не переписывать функцию для частных случаев, где некоторые параметры у функции не меняются, можно зафиксировать часть параметров в оригинальной функции и получить новую функцию только с тем набором параметров, которые необходимо менять.

Пример:

def add(a: Int, b: Int) = a + b // Определение функции с двумя параметрами

val inc: Int => Int = add(_, 1) // Преобразование в функцию, которая увеличивает значения на единицу.
val res = inc(8) // результат 9

Для преобразования функции с полным набором параметров в функцию с меньшим набором параметров необходимо вызвать оригинальную функцию и  указать аргументы только для тех параметров, которые необходимо зафиксировать. На месте же остальных параметров указать знак подчеркивания**` _`**. Таким образом функция превратится в функциональное значение только с тем набором  параметров,  для которых не было указано значение.

Аргументы и знаки подчеркивания в функции можно указывать по необходимости в любой комбинации. В любом случае будет получено новое функциональное значение. Последовательность оставленных в функции параметров сохраняется от оригинальной функции.

Еще примеры:

def addAndMul(a: Int, b: Int, c: Int) = a + b * c // Определение функции с тремя параметрами

val mulByTwoT: Int => Int = addAndMul(0, _, 2) // Преобразование в функциональное значение, которое умножает на два
val res1 = mulByTwoT(8) // результат 16

val add: (Int, Int) => Int = addAndMul(_, _, 1) // Преобразование в функциональное значение, которое выполняет сложение
val res2 = add(2, 2) // результат 4

val fun: (Int, Int, Int) => Int = addAndMul(_, _, _) // Преобразование в функциональное значение без уменьшения количества параметров

val res3: Int = addAndMul(1,2,3) // Преобразований функции нет. Она вызвана с полным набором аргументов. Результат 7

---

### Полные данные JSON

<details>
<summary>Показать JSON данные</summary>

```json
{
  "name" : "text",
  "text" : "<h1 style=\"text-align:center;\">Преобразование функций</h1>\n\n<h2 style=\"text-align:center;\">Преобразование именованной функции в функциональное значение</h2>\n\n<p>Напомним, что именованная функция <strong>не является</strong> значением. Значит она лишена многих полезных свойств, которыми обладает функциональное значение (анонимная функция). Однако можно легко конвертировать уже определенную именованную функцию в функциональное значение.</p>\n\n<p><strong>Конвертация</strong> произойдет, когда название именованной функции будет <strong>использовано как значение</strong>.</p>\n\n<p>Пример:</p>\n\n<pre><code class=\"language-scala\">def add(a: Int, b: Int) = a + b // Определение именованой функции.\n\nval fun = add // получили функциональное значение fun типа (Int, Int) =&gt; Int\nval res = fun(1,2)  // Вызов (исполнение) функционального значения fun, но фактически функции add\n\nval tuple = (add, 1, 2, 3) // получили кортеж tuple типа ((Int, Int) =&gt; Int, Int, Int, Int)</code></pre>\n\n<p>Таким образом конвертация производится совершенно <strong>незаметно</strong>, и именованные функции можно использовать как функциональные значения.</p>\n\n<h2 style=\"text-align:center;\">Преобразование в функцию с меньшим количеством параметров</h2>\n\n<h3 style=\"text-align:center;\"><strong>(частично примененная функция)</strong></h3>\n\n<p>Функциональный подход подразумевает частое переиспользование одних и тех же функций в разных расчетах. Для этого функции должны быть достаточно универсальными, что обычно приводит к необходимости большого количества параметров  функции.</p>\n\n<p>Чтобы не переписывать функцию для частных случаев, где некоторые параметры у функции не меняются, можно зафиксировать часть параметров в оригинальной функции и получить новую функцию только с тем набором параметров, которые необходимо менять.</p>\n\n<p>Пример:</p>\n\n<pre><code class=\"language-scala\">def add(a: Int, b: Int) = a + b // Определение функции с двумя параметрами\n\nval inc: Int =&gt; Int = add(_, 1)  // Преобразование в функцию, которая увеличивает значения на единицу. \nval res = inc(8) // результат 9</code></pre>\n\n<p>Для преобразования функции с полным набором параметров в функцию с меньшим набором параметров необходимо вызвать оригинальную функцию и  указать аргументы только для тех параметров, которые необходимо зафиксировать. На месте же остальных параметров указать знак подчеркивания<strong><code> _</code></strong>. Таким образом функция превратится в функциональное значение только с тем набором  параметров,  для которых не было указано значение.</p>\n\n<p>Аргументы и знаки подчеркивания в функции можно указывать по необходимости в любой комбинации. В любом случае будет получено новое функциональное значение. Последовательность оставленных в функции параметров сохраняется от оригинальной функции.</p>\n\n<p>Еще примеры:</p>\n\n<pre><code class=\"language-scala\">def addAndMul(a: Int, b: Int, c: Int) = a + b * c // Определение функции с тремя параметрами\n\nval mulByTwoT: Int =&gt; Int = addAndMul(0, _, 2)  // Преобразование в функциональное значение, которое умножает на два\nval res1 = mulByTwoT(8) // результат 16\n\nval add: (Int, Int) =&gt; Int = addAndMul(_, _, 1)  // Преобразование в функциональное значение, которое выполняет сложение\nval res2 = add(2, 2) // результат 4\n\nval fun: (Int, Int, Int) =&gt; Int = addAndMul(_, _, _) // Преобразование в функциональное значение без уменьшения количества параметров\n\nval res3: Int = addAndMul(1,2,3) // Преобразований функции нет. Она вызвана с полным набором аргументов. Результат 7</code></pre>",
  "video" : null,
  "options" : {
    
  },
  "subtitle_files" : [
  ],
  "is_deprecated" : false
}
```

</details>
