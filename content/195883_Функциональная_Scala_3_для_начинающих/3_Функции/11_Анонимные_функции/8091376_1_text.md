# Материал (Шаг 1)

## Информация о шаге

- **ID шага**: 8091376
- **Позиция**: 1
- **Тип**: text
- **Курс**: Функциональная Scala 3 для начинающих
- **Экспортирован**: 2025-12-20T22:21:16.715656

## Содержание

# Анонимные функции

В функциональном программировании **анонимные функции** представляют собой фундаментальную концепцию, позволяющую определять вычислительные процедуры без привязки к именованным идентификаторам. Данные конструкции реализуют принципы лямбда-исчисления Алонзо Черча и обеспечивают поддержку функций как объектов первого класса.

Анонимные функции также могут называться **функциональными выражениями**, **функциональными литералами, лямбда-выражениями**, **лямбда-функциями**, в зависимости от контекста их применения. Они часто используются в качестве аргументов других функций или для создания кратких форм функций.

## Определение анонимной функции

Анонимные функции создаются с использованием синтаксиса, который позволяет определять функции без явного указания имени. Синтаксическая структура анонимной функции определяется следующей грамматикой:

`(параметры: Типы) => выражение`

**Пример определения анонимной функции:**

(x: Int) => x + 1

где:

- `(x: Int)` — входной параметр **x** типа `Int`

- `=>` — знак преобразования входных значений в выходное значение

- `x + 1` — тело функции (алгоритм преобразования входного значения). В выражении используем параметр **x** как абстрактное (пока неизвестное) значение для вычисления выражения

**Обратите внимание!** Тип выходного значения **при определении** анонимной функции **не указывается**. Он выводится **автоматически** из выражений тела функции. Это сделано для краткости определения функции, так как анонимные функции — это обычно встраиваемые, одноразовые конструкции.

## Функциональные типы

**Функциональные типы** записываются в нотации `A => B`, где:

- `A` — тип входного параметра (домен функции)

- `B` — тип возвращаемого значения (кодомен функции)

Функция из ранее приведенного примера имеет тип: `Int => Int`

**Пример функция преобразования символов:**

(h: Char) => h.toUpper

**Тип** данной функции: `Char => Char`

## Функции с несколькими параметрами

Входных параметров у функции может быть **несколько**. Это функции **высшей арности.**

Пример:

(x: Int, y: Double) => x + y

где `(x: Int, y: Double)` — два входных параметра с типами `Int` и `Double`.

**Тип** этой функции будет:

(Int, Double) => Double

## Функции без параметров

Входные параметры могут **отсутствовать**. Это **нульарные** или **константные** функции.

Пример:

() => "Константное значение"

**Тип** этой функции будет:

() => String

## Блоки выражений в теле функции

Если тело функции состоит из **нескольких** выражений, то образуется блок выражений. Блок выражений обозначается фигурными скобками.

Пример:

(x: Int) => {
val res1 = x + 1
val res2 = res1 + 2
res2
}

Можно **не использовать** фигурные скобки, если отступы каждого выражения блока от левого края одинаковые:

(x: Int) =>
val res1 = x + 1
val res2 = res1 + 2
res2

## Вызов функции

Вызов анонимной функции выполняется при указании в круглых скобках необходимых аргументов для функции.

val res = ((x: Int) => x + 1)(2) // аргумент — значение 2, результат — значение 3

Определение функции указано вместе с её вызовом.

Можно отделить определение функции и её вызов, если это будет удобнее:

val fun = (x: Int) => x + 1 // fun — функциональное значение
val res = fun(2) // вызов функции, результат — значение 3

Можно для наглядности указать все типы значений:

val fun: Int => Int = (x: Int) => x + 1
val res: Int = fun(2)

Указание типов значений выполняет роль документирования кода.

##  

---

### Полные данные JSON

<details>
<summary>Показать JSON данные</summary>

```json
{
  "name" : "text",
  "text" : "<h1 style=\"text-align:center;\">Анонимные функции</h1>\n\n<p>В функциональном программировании <strong>анонимные функции</strong> представляют собой фундаментальную концепцию, позволяющую определять вычислительные процедуры без привязки к именованным идентификаторам. Данные конструкции реализуют принципы лямбда-исчисления Алонзо Черча и обеспечивают поддержку функций как объектов первого класса.</p>\n\n<p>Анонимные функции также могут называться <strong>функциональными выражениями</strong>, <strong>функциональными литералами, лямбда-выражениями</strong>, <strong>лямбда-функциями</strong>, в зависимости от контекста их применения. Они часто используются в качестве аргументов других функций или для создания кратких форм функций.</p>\n\n<h2 style=\"text-align:center;\">Определение анонимной функции</h2>\n\n<p>Анонимные функции создаются с использованием синтаксиса, который позволяет определять функции без явного указания имени. Синтаксическая структура анонимной функции определяется следующей грамматикой:</p>\n\n<pre><code class=\"language-scala\">(параметры: Типы) =&gt; выражение</code></pre>\n\n<p><strong>Пример определения анонимной функции:</strong></p>\n\n<pre><code class=\"language-scala\">(x: Int) =&gt; x + 1\n</code></pre>\n\n<p>где:</p>\n\n<ul>\n\t<li><code>(x: Int)</code> — входной параметр <strong>x</strong> типа <code>Int</code></li>\n\t<li><code>=&gt;</code> — знак преобразования входных значений в выходное значение</li>\n\t<li><code>x + 1</code> — тело функции (алгоритм преобразования входного значения). В выражении используем параметр <strong>x</strong> как абстрактное (пока неизвестное) значение для вычисления выражения</li>\n</ul>\n\n<p><strong>Обратите внимание!</strong> Тип выходного значения <strong>при определении</strong> анонимной функции <strong>не указывается</strong>. Он выводится <strong>автоматически</strong> из выражений тела функции. Это сделано для краткости определения функции, так как анонимные функции — это обычно встраиваемые, одноразовые конструкции.</p>\n\n<h2 style=\"text-align:center;\">Функциональные типы</h2>\n\n<p><strong>Функциональные типы</strong> записываются в нотации <code>A =&gt; B</code>, где:</p>\n\n<ul>\n\t<li><code>A</code> — тип входного параметра (домен функции)</li>\n\t<li><code>B</code> — тип возвращаемого значения (кодомен функции)</li>\n</ul>\n\n<p>Функция из ранее приведенного примера имеет тип: <code>Int =&gt; Int</code></p>\n\n<p><strong>Пример функция преобразования символов:</strong></p>\n\n<pre><code class=\"language-scala\">(h: Char) =&gt; h.toUpper\n</code></pre>\n\n<p><strong>Тип</strong> данной функции: <code>Char =&gt; Char</code></p>\n\n<h2 style=\"text-align:center;\">Функции с несколькими параметрами</h2>\n\n<p>Входных параметров у функции может быть <strong>несколько</strong>. Это функции <strong>высшей арности.</strong></p>\n\n<p>Пример:</p>\n\n<pre><code class=\"language-scala\">(x: Int, y: Double) =&gt; x + y\n</code></pre>\n\n<p>где <code>(x: Int, y: Double)</code> — два входных параметра с типами <code>Int</code> и <code>Double</code>.</p>\n\n<p><strong>Тип</strong> этой функции будет:</p>\n\n<pre><code class=\"language-scala\">(Int, Double) =&gt; Double\n</code></pre>\n\n<h2 style=\"text-align:center;\">Функции без параметров</h2>\n\n<p>Входные параметры могут <strong>отсутствовать</strong>. Это <strong>нульарные</strong> или <strong>константные</strong> функции.</p>\n\n<p>Пример:</p>\n\n<pre><code class=\"language-scala\">() =&gt; \"Константное значение\"\n</code></pre>\n\n<p><strong>Тип</strong> этой функции будет:</p>\n\n<pre><code class=\"language-scala\">() =&gt; String\n</code></pre>\n\n<h2 style=\"text-align:center;\">Блоки выражений в теле функции</h2>\n\n<p>Если тело функции состоит из <strong>нескольких</strong> выражений, то образуется блок выражений. Блок выражений обозначается фигурными скобками.</p>\n\n<p>Пример:</p>\n\n<pre><code class=\"language-scala\">(x: Int) =&gt; {\n  val res1 = x + 1\n  val res2 = res1 + 2\n  res2\n}\n</code></pre>\n\n<p>Можно <strong>не использовать</strong> фигурные скобки, если отступы каждого выражения блока от левого края одинаковые:</p>\n\n<pre><code class=\"language-scala\">(x: Int) =&gt; \n  val res1 = x + 1\n  val res2 = res1 + 2\n  res2\n</code></pre>\n\n<h2 style=\"text-align:center;\">Вызов функции</h2>\n\n<p>Вызов анонимной функции выполняется при указании в круглых скобках необходимых аргументов для функции.</p>\n\n<pre><code class=\"language-scala\">val res = ((x: Int) =&gt; x + 1)(2) // аргумент — значение 2, результат — значение 3\n</code></pre>\n\n<p>Определение функции указано вместе с её вызовом.</p>\n\n<p>Можно отделить определение функции и её вызов, если это будет удобнее:</p>\n\n<pre><code class=\"language-scala\">val fun = (x: Int) =&gt; x + 1  // fun — функциональное значение\nval res = fun(2)             // вызов функции, результат — значение 3\n</code></pre>\n\n<p>Можно для наглядности указать все типы значений:</p>\n\n<pre><code class=\"language-scala\">val fun: Int =&gt; Int = (x: Int) =&gt; x + 1\nval res: Int = fun(2)\n</code></pre>\n\n<p>Указание типов значений выполняет роль документирования кода.</p>\n\n<h2 style=\"text-align:center;\"> </h2>",
  "video" : null,
  "options" : {
    
  },
  "subtitle_files" : [
  ],
  "is_deprecated" : false
}
```

</details>
