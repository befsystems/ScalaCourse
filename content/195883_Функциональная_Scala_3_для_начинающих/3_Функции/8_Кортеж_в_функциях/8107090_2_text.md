# Материал (Шаг 2)

## Информация о шаге

- **ID шага**: 8107090
- **Позиция**: 2
- **Тип**: text
- **Курс**: Функциональная Scala 3 для начинающих
- **Экспортирован**: 2026-01-10T10:17:26.783831

## Содержание

#  Декомпозиция кортежа

**Декомпозиция кортежа** — это процесс разбиения кортежа на её элементы и **связывания их с именами** (name binding). Это позволяет "разобрать" составную структуру данных на её компоненты и использовать их по отдельности.

Пример:

// Создание кортежа
val coordinates = (10, 20)

// Декомпозиция - разбираем кортеж и связываем элементы с именами
val (x, y) = coordinates

println(x) // 10
println(y) // 20

Список имен извлекаемых значений нужно заключить в **круглые скобки**, количество имен должно строго **соответствовать** **количеству** элементов кортежа. Извлечение элементов кортежа в имена будет произведено **по порядку их расположения** в кортеже. Имена извлекаемых значений в списке могут быть произвольными, важен только их порядок.

При декомпозиции можно **указать типы** извлекаемых элементов, тогда будет дополнительно произведена проверка соответствия типов этих элементов:

val tuple4 = (1, "s", 2L, 'a') // Создание кортежа
val (a: Int, b: String, c: Long, d: Char) = tuple4 // Декомпозиция кортежа на составные элементы
val res = a / c / d + b // Использование извлеченных элементов кортежа. Результат - строка "0s"

## Частичная **декомпозиция **

Если при декомпозиции часть элементов не нужна, то вместо названия значения можно указать знак подстановки _ , но обязательно создать список для всех элементов, в порядке их нахождения в кортеже.

val tuple4 = (1, "s", 2L, 'a') // Создание кортежа
val (el1, _, el3, _) = tuple4 // Декомпозиция кортежа на составные элементы
val res = el1 / el3 // Использование извлеченных элементов кортежа. Результат - значение 0

Символ _ в перечне названий элементов указывает на то, что соответствующий элемент кортежа пропускается.

## **Декомпозиция ** в pattern matching

При декомпозиции кортежа в альтернативе нужно указать целевые имена значений для всех элементов кортежа в круглых скобках:

val data = ("Alice", 25)

// Полная декомпозиция
data match {
case (name, age) => println(s"Person: $name, Age: $age")
}

// Частичная декомпозиция
data match {
case (name, _) => println(s"Person: $name")
}

// С проверкой на типы элементов
data match {
case (name: String, age: Int) => println(s"Person: $name, Age: $age")
}

Если необходимы и элементы кортежа и сам кортеж, то  нужно дополнительно весь кортеж связать с именем, используя оператор `@`:

val point = (10, 20)

point match {
case tuple @ (x, y) =>
println(s"Coordinates: $x, $y")
println(s"Full tuple: $tuple")
}

---

### Полные данные JSON

<details>
<summary>Показать JSON данные</summary>

```json
{
  "name" : "text",
  "text" : "<h1 style=\"text-align:center;\"> Декомпозиция кортежа</h1>\n\n<p><strong>Декомпозиция кортежа</strong> — это процесс разбиения кортежа на её элементы и <strong>связывания их с именами</strong> (name binding). Это позволяет \"разобрать\" составную структуру данных на её компоненты и использовать их по отдельности.</p>\n\n<p>Пример:</p>\n\n<pre><code class=\"language-scala\">// Создание кортежа\nval coordinates = (10, 20)\n\n// Декомпозиция - разбираем кортеж и связываем элементы с именами\nval (x, y) = coordinates\n\nprintln(x) // 10\nprintln(y) // 20</code></pre>\n\n<p>Список имен извлекаемых значений нужно заключить в <strong>круглые скобки</strong>, количество имен должно строго <strong>соответствовать</strong> <strong>количеству</strong> элементов кортежа. Извлечение элементов кортежа в имена будет произведено <strong>по порядку их расположения</strong> в кортеже. Имена извлекаемых значений в списке могут быть произвольными, важен только их порядок.</p>\n\n<p>При декомпозиции можно <strong>указать типы</strong> извлекаемых элементов, тогда будет дополнительно произведена проверка соответствия типов этих элементов:</p>\n\n<pre><code class=\"language-scala\">val tuple4 = (1, \"s\", 2L, 'a')     // Создание кортежа\nval (a: Int, b: String, c: Long, d: Char) = tuple4 // Декомпозиция кортежа на составные элементы\nval res = a / c / d + b    // Использование извлеченных элементов кортежа. Результат - строка \"0s\"</code></pre>\n\n<h2 style=\"text-align:center;\">Частичная <strong>декомпозиция </strong></h2>\n\n<p>Если при декомпозиции часть элементов не нужна, то вместо названия значения можно указать знак подстановки _ , но обязательно создать список для всех элементов, в порядке их нахождения в кортеже.</p>\n\n<pre><code class=\"language-scala\">val tuple4 = (1, \"s\", 2L, 'a') // Создание кортежа\nval (el1, _, el3, _) = tuple4  // Декомпозиция кортежа на составные элементы\nval res = el1 / el3            // Использование извлеченных элементов кортежа. Результат - значение 0</code></pre>\n\n<p>Символ _ в перечне названий элементов указывает на то, что соответствующий элемент кортежа пропускается.</p>\n\n<h2 style=\"text-align:center;\"><strong>Декомпозиция </strong> в pattern matching</h2>\n\n<p>При декомпозиции кортежа в альтернативе нужно указать целевые имена значений для всех элементов кортежа в круглых скобках:</p>\n\n<pre><code class=\"language-scala\">val data = (\"Alice\", 25)\n\n// Полная декомпозиция\ndata match {\n  case (name, age) =&gt; println(s\"Person: $name, Age: $age\")\n}\n\n// Частичная декомпозиция\ndata match {\n  case (name, _) =&gt; println(s\"Person: $name\")\n}\n\n// С проверкой на типы элементов\ndata match {\n  case (name: String, age: Int) =&gt; println(s\"Person: $name, Age: $age\")\n}</code></pre>\n\n<p>Если необходимы и элементы кортежа и сам кортеж, то  нужно дополнительно весь кортеж связать с именем, используя оператор <code>@</code>:</p>\n\n<pre><code class=\"language-scala\">val point = (10, 20)\n\npoint match {\n  case tuple @ (x, y) =&gt; \n    println(s\"Coordinates: $x, $y\")\n    println(s\"Full tuple: $tuple\")\n}</code></pre>",
  "video" : null,
  "options" : {
    
  },
  "subtitle_files" : [
  ],
  "is_deprecated" : false
}
```

</details>
