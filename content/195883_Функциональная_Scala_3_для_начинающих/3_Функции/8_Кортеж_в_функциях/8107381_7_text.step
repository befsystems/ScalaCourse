{
  "step_id" : 8107381,
  "lesson_id" : 1941243,
  "position" : 7,
  "type" : "unknown",
  "block" : {
    "name" : "text",
    "text" : "<h1 style=\"text-align:center;\">Кортеж как результат функции</h1>\n\n<p>Функция должна возвращать только одно значение. Однако это значение может быть сколь угодно сложным или составным. Кортеж позволяет функции формально возвращать одно значение, которое семантически содержит несколько логически связанных значений.</p>\n\n<pre><code class=\"language-scala\">// Функция возвращает одно значение - кортеж из трёх элементов\ndef divideWithRemainder(dividend: Int, divisor: Int): (Int, Int, Boolean) = {\n  val quotient = dividend / divisor\n  val remainder = dividend % divisor\n  val isExact = remainder == 0\n  (quotient, remainder, isExact)\n}\n\nval result: (Int, Int, Boolean) = divideWithRemainder(10, 3) // (3, 1, false)\n</code></pre>\n\n<h2 style=\"text-align:center;\">Преимущества использования кортежей как результата</h2>\n\n<h3>1. Атомарность результата</h3>\n\n<p>Кортеж позволяет вернуть логически связанные данные как единое целое, что важно для поддержания целостности информации.</p>\n\n<pre><code class=\"language-scala\">// Плохо: отдельные функции могут рассинхронизироваться\ndef getX(point: String): Double = ??? \ndef getY(point: String): Double = ???\n\n// Хорошо: координаты всегда синхронны\ndef parseCoordinates(input: String): (Double, Double) = {\n  val parts = input.split(\",\")\n  (parts(0).toDouble, parts(1).toDouble)\n}\n\nval coords = parseCoordinates(\"3.14,2.71\") // (3.14, 2.71)\n</code></pre>\n\n<h3>2. Удобство деструктуризации</h3>\n\n<p>Scala предоставляет элегантный синтаксис для извлечения компонентов кортежа.</p>\n\n<pre><code class=\"language-scala\">def getMinMax(numbers: List[Int]): (Int, Int) = \n  (numbers.min, numbers.max)\n\n// Деструктуризация при присваивании\nval (min, max) = getMinMax(List(5, 2, 8, 1, 9))\nprintln(s\"Минимум: $min, Максимум: $max\") // Минимум: 1, Максимум: 9\n\n// Деструктуризация в pattern matching\ngetMinMax(List(1, 2, 3)) match {\n  case (min, max) if min == max =&gt; println(\"Все элементы одинаковые\")\n  case (min, max) =&gt; println(s\"Диапазон: $min - $max\")\n}\n</code></pre>\n\n<h3>3. Композиция функций</h3>\n\n<p>Функции, возвращающие кортежи, легко композируются с другими функциями.</p>\n\n<pre><code class=\"language-scala\">def parseName(fullName: String): (String, String) = {\n  val parts = fullName.split(\" \")\n  (parts(0), parts.lastOption.getOrElse(\"\"))\n}\n\ndef formatName(nameData: (String, String)): String = nameData match {\n  case (first, last) =&gt; s\"$last, $first\"\n}\n\n// Композиция функций\nval formatFullName = parseName _ andThen formatName\nval result = formatFullName(\"John Smith\") // \"Smith, John\"\n</code></pre>\n\n<blockquote>\n<p><strong>Примечание</strong>: Более подробно о композициях функций мы узнаем позже.</p>\n</blockquote>\n\n<h2 style=\"text-align:center;\">Проблемы и ограничения</h2>\n\n<h3>1. Отсутствие семантической ясности</h3>\n\n<p>Основная проблема кортежей как результата - неявность смысла каждого элемента.</p>\n\n<pre><code class=\"language-scala\">// Плохо: что означает каждый элемент?\ndef analyzeText(text: String): (Int, Int, Double) = {\n  val words = text.split(\"\\\\s+\")\n  val chars = text.length\n  val avgWordLength = if (words.nonEmpty) chars.toDouble / words.length else 0.0\n  (words.length, chars, avgWordLength)\n}\n\nval analysis = analyzeText(\"Hello world\") // (2, 11, 5.5) - что это значит?\n</code></pre>\n\n<p>В Scala 3 появилась возможность использовать именование элементов кортежа, что снижает проблему неявности.</p>\n\n<h3>2. Сложность поддержки и изменений</h3>\n\n<p>При изменении логики функции кортеж-результат может сломать существующий код.</p>\n\n<pre><code class=\"language-scala\">// Версия 1: возвращаем (имя, возраст)\ndef getUserInfo(id: Int): (String, Int) = (\"Alice\", 25)\n\n// Версия 2: добавили email - ломаем обратную совместимость\ndef getUserInfo(id: Int): (String, Int, String) = (\"Alice\", 25, \"alice@example.com\")\n\n// Существующий код сломается:\n// val (name, age) = getUserInfo(1) // Ошибка: несоответствие типов!\n</code></pre>\n\n<h2 style=\"text-align:center;\">Рекомендации по использованию</h2>\n\n<h3>Когда использовать кортежи</h3>\n\n<p><strong>1. Простые, очевидные пары значений:</strong></p>\n\n<pre><code class=\"language-scala\">def getRange(numbers: List[Int]): (Int, Int) = (numbers.min, numbers.max)\ndef getCoordinates(address: String): (Double, Double) = parseGPS(address)\n</code></pre>\n\n<p><strong>2. Временные промежуточные результаты:</strong></p>\n\n<pre><code class=\"language-scala\">// В рамках приватных функций или локальных вычислений\nprivate def splitFullName(name: String): (String, String) = {\n  val parts = name.split(\" \")\n  (parts.head, parts.last)\n}\n</code></pre>\n\n<p><strong>3. Результаты математических операций:</strong></p>\n\n<pre><code class=\"language-scala\">def polarToCartesian(radius: Double, angle: Double): (Double, Double) = \n  (radius * math.cos(angle), radius * math.sin(angle))\n</code></pre>\n\n<h3>Когда НЕ использовать кортежи</h3>\n\n<p><strong>1. Сложные бизнес-объекты:</strong></p>\n\n<pre><code class=\"language-scala\">// Плохо\ndef createUser(name: String, email: String): (Int, String, String, Boolean, Long) = ???\n\n// Хорошо\ncase class User(id: Int, name: String, email: String, isActive: Boolean, createdAt: Long)\ndef createUser(name: String, email: String): User = ???\n</code></pre>\n\n<p><strong>2. Публичные API:</strong></p>\n\n<pre><code class=\"language-scala\">// Плохо для публичного API\ndef getStatistics(): (Int, Double, Int, Boolean) = ???\n\n// Хорошо\ncase class Statistics(totalUsers: Int, averageAge: Double, activeCount: Int, isGrowing: Boolean)\ndef getStatistics(): Statistics = ???\n</code></pre>\n\n<p><strong>Обратите внимание!</strong> Не только кортеж позволяет функции возвращать составные значения, но и другие сложные типы данных применимы для этих целей. Кортеж является наиболее простой и быстро создаваемой формой такого значения.</p>",
    "video" : null,
    "options" : {
      
    },
    "subtitle_files" : [
    ],
    "is_deprecated" : false
  },
  "name" : "text",
  "course_id" : 195883,
  "course_name" : "Функциональная Scala 3 для начинающих",
  "exported_at" : "2026-01-10T10:17:26.8011892"
}