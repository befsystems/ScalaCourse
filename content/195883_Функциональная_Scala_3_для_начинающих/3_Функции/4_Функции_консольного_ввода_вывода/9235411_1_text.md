# Материал (Шаг 1)

## Информация о шаге

- **ID шага**: 9235411
- **Позиция**: 1
- **Тип**: text
- **Курс**: Функциональная Scala 3 для начинающих
- **Экспортирован**: 2026-01-10T10:17:28.8654347

## Содержание

# Терминалы и консоли

В 1960-х годах компьютеры были размером с комнату, стоили как небольшой город и работали совершенно не так, как мы привыкли. Программисты не сидели перед экранами — они пробивали дырки в картонных карточках, относили стопку этих карточек оператору, и через несколько часов (или дней!) получали распечатку. Чаще всего это было одно слово: "ERROR". Ошиблись в одной букве на карточке номер 247 из 500? Поздравляем, начинайте всё заново. Программирование тогда требовало терпения буддийского монаха.

Кто-то подумал: а что если подключить к компьютеру печатную машинку? Прямо сейчас, без всех этих карточек и ожиданий?

Так родились **телетайпы** — электромеханические монстры, которые стучали, грохотали и пахли машинным маслом. Но они творили чудо: программист набирал команду, нажимал Enter, и компьютер *тут же* отвечал! Правда, ответ печатался на бумаге под звуки, напоминающие пулемётную очередь. Офисы программистов тонули в горах использованной бумаги. Зато это было в реальном времени! Революция!

Эти устройства назвали **терминалами** — от латинского "terminus", конец линии. Один большой компьютер, десятки терминалов вокруг, километры проводов. Телетайпы породили ASCII — код, в котором были не только буквы, но и команда "BELL" — да-да, терминал мог *звонить*, как школьный звонок, если компьютер хотел привлечь внимание. Представьте: сидите вы, программируете, и вдруг — дзынь! — компьютер сообщает, что ваша программа упала. Романтика.

**Консоль** — это был VIP-терминал. Главный. Boss. Тот, что стоял рядом с самим компьютером, украшенный дополнительными кнопками, переключателями и мигающими лампочками (программисты 1960-х обожали мигающие лампочки). Через консоль системный оператор управлял всей машиной. Если все терминалы зависали, консоль оставалась последней надеждой. Это был трон администратора, и сидеть за ним было престижно.

Потом случилось волшебство: начало 1970-х, видеотерминалы!  **VT100** от компании DEC показывал зелёные буквы на чёрном фоне и выглядел так футуристично, что до сих пор все эмуляторы терминалов притворяются именно им. Серьёзно: когда современная программа рисует текст, она отправляет команды, придуманные для VT100 в 1978 году. Это как если бы Tesla управлялась педалями от Ford Model T.

Параллельно IBM создавала свою вселенную с терминалами **IBM 3270**. Они были умнее: пользователь заполнял форму целиком на экране, потом нажимал Enter, и всё разом улетало на мейнфрейм. Никакой посимвольной возни! IBM опередила веб-формы на тридцать лет, но об этом никто не помнит, потому что мир Unix оказался громче.

А в Unix, который создавали в Bell Labs, случилась философская революция. "Всё есть файл", — решили создатели. Клавиатура? Файл. Экран? Файл. Принтер? Файл. Другая программа? Тоже файл! Это звучало безумно, но работало гениально. Появились стандартные потоки: **stdin** (откуда читать), **stdout** (куда писать) и** stderr** (куда жаловаться на ошибки). Программе стало всё равно, с кем она разговаривает — с человеком, с файлом или с другой программой. Магия абстракции!

И тут Unix-программисты изобрели **pipes** — трубы. Можно взять выход одной программы и засунуть его во вход другой. И ещё одной. И ещё. Программы стали как вагоны поезда, только перевозят данные. Элегантно до слёз.

Наступили 1980-е. Появились персональные компьютеры с графическими окнами, иконками, мышками. "Всё, — сказали провидцы, — терминалы умрут. Кому нужна эта архаика с командами, когда можно щёлкать по иконкам?"

Не умерли. Более того, программисты стали скучать по терминалам так сильно, что написали... программы, притворяющиеся терминалами! **Эмуляторы терминалов** — софт, который имитирует железо 1970-х внутри современного компьютера. Это как если бы люди в 2025 году специально покупали приложение, имитирующее дисковый телефон. Абсурд? 

Terminal в macOS, сотни вариантов в Linux, cmd и PowerShell в Windows — все они одевают костюм VT100. Открываете терминал на MacBook за три тысячи долларов, а он ведёт себя как устройство за триста долларов из 1978-го. И всем нравится!

В Linux добавили **виртуальные консоли** — несколько текстовых экранов, встроенных в ядро. Ctrl+Alt+F1, F2, F3... переключаетесь между ними как между телеканалами. Древняя консоль размножилась и стала виртуальной.

**Тут началась терминологическая анархия.** Люди стали называть "консолью" всё подряд: и эмулятор терминала, и виртуальную консоль Linux, и вообще любое чёрное окошко с текстом. Windows официально объявила программы с текстовым вводом-выводом "консольными приложениями". Строгие определения растворились в народном языке. Терминал, консоль, командная строка, шелл — спросите у десяти программистов, получите одиннадцать ответов.

И вот вопрос: почему в 2025 году, в эпоху нейросетей и квантовых компьютеров, **Scala 3 всё ещё имеет println и stdin**?

Потому что это работает. Везде. Всегда.

**Универсальность**: текстовые потоки понимает любое устройство. От Raspberry Pi за тридцать долларов до суперкомпьютера за тридцать миллионов. Ваша программа заработает на сервере без монитора, в Docker-контейнере, через SSH с другого континента.

**Простота**: хотите понять, что делает код? Впихните туда println. Профессиональные отладчики прекрасны, но для быстрой проверки "а что тут происходит?" нет ничего проще вывода в консоль. Это изолента программирования.

**Комбинируемость**: Unix-философия "делай одно, делай хорошо" жива. Современный DevOps-инженер может написать однострочную команду из пяти программ, соединённых трубами, которая обработает гигабайты логов за секунды. Попробуйте такое в графическом интерфейсе.

**Совместимость**: миллионы строк кода, написанных за полвека, полагаются на stdin/stdout. Выбросить это — потерять экосистему инструментов размером с небольшую планету.

**Скорость**: опытный человек в терминале работает быстрее, чем кто угодно с мышкой. Руки на клавиатуре, мышление на уровне команд, никаких меню и подменю. 

Так что когда вы пишете в Scala 3 что-то вроде println, вы не используете устаревшую технологию. Вы подключаетесь к эпической саге, которая началась с грохочущих телетайпов, прошла через зелёные экраны VT100, пережила графические революции, освоила облака и продолжает жить.

Консольный ввод-вывод — это не баг, это фича. Не технический долг, а фундамент. Он пережил перфокарты, дискеты, CD-ROM, и переживёт всё остальное.

Потому что простые идеи бессмертны. А идея "текст течёт по трубам между программами" оказалась настолько простой и мощной, что человечество за пятьдесят лет не придумало ничего лучше.

---

### Полные данные JSON

<details>
<summary>Показать JSON данные</summary>

```json
{
  "name" : "text",
  "text" : "<h1 style=\"text-align:center;\">Терминалы и консоли</h1>\n\n<p>В 1960-х годах компьютеры были размером с комнату, стоили как небольшой город и работали совершенно не так, как мы привыкли. Программисты не сидели перед экранами — они пробивали дырки в картонных карточках, относили стопку этих карточек оператору, и через несколько часов (или дней!) получали распечатку. Чаще всего это было одно слово: \"ERROR\". Ошиблись в одной букве на карточке номер 247 из 500? Поздравляем, начинайте всё заново. Программирование тогда требовало терпения буддийского монаха.</p>\n\n<p>Кто-то подумал: а что если подключить к компьютеру печатную машинку? Прямо сейчас, без всех этих карточек и ожиданий?</p>\n\n<p>Так родились <strong>телетайпы</strong> — электромеханические монстры, которые стучали, грохотали и пахли машинным маслом. Но они творили чудо: программист набирал команду, нажимал Enter, и компьютер <em>тут же</em> отвечал! Правда, ответ печатался на бумаге под звуки, напоминающие пулемётную очередь. Офисы программистов тонули в горах использованной бумаги. Зато это было в реальном времени! Революция!</p>\n\n<p>Эти устройства назвали <strong>терминалами</strong> — от латинского \"terminus\", конец линии. Один большой компьютер, десятки терминалов вокруг, километры проводов. Телетайпы породили ASCII — код, в котором были не только буквы, но и команда \"BELL\" — да-да, терминал мог <em>звонить</em>, как школьный звонок, если компьютер хотел привлечь внимание. Представьте: сидите вы, программируете, и вдруг — дзынь! — компьютер сообщает, что ваша программа упала. Романтика.</p>\n\n<p><strong>Консоль</strong> — это был VIP-терминал. Главный. Boss. Тот, что стоял рядом с самим компьютером, украшенный дополнительными кнопками, переключателями и мигающими лампочками (программисты 1960-х обожали мигающие лампочки). Через консоль системный оператор управлял всей машиной. Если все терминалы зависали, консоль оставалась последней надеждой. Это был трон администратора, и сидеть за ним было престижно.</p>\n\n<p>Потом случилось волшебство: начало 1970-х, видеотерминалы!  <strong>VT100</strong> от компании DEC показывал зелёные буквы на чёрном фоне и выглядел так футуристично, что до сих пор все эмуляторы терминалов притворяются именно им. Серьёзно: когда современная программа рисует текст, она отправляет команды, придуманные для VT100 в 1978 году. Это как если бы Tesla управлялась педалями от Ford Model T.</p>\n\n<p>Параллельно IBM создавала свою вселенную с терминалами <strong>IBM 3270</strong>. Они были умнее: пользователь заполнял форму целиком на экране, потом нажимал Enter, и всё разом улетало на мейнфрейм. Никакой посимвольной возни! IBM опередила веб-формы на тридцать лет, но об этом никто не помнит, потому что мир Unix оказался громче.</p>\n\n<p>А в Unix, который создавали в Bell Labs, случилась философская революция. \"Всё есть файл\", — решили создатели. Клавиатура? Файл. Экран? Файл. Принтер? Файл. Другая программа? Тоже файл! Это звучало безумно, но работало гениально. Появились стандартные потоки: <strong>stdin</strong> (откуда читать), <strong>stdout</strong> (куда писать) и<strong> stderr</strong> (куда жаловаться на ошибки). Программе стало всё равно, с кем она разговаривает — с человеком, с файлом или с другой программой. Магия абстракции!</p>\n\n<p>И тут Unix-программисты изобрели <strong>pipes</strong> — трубы. Можно взять выход одной программы и засунуть его во вход другой. И ещё одной. И ещё. Программы стали как вагоны поезда, только перевозят данные. Элегантно до слёз.</p>\n\n<p>Наступили 1980-е. Появились персональные компьютеры с графическими окнами, иконками, мышками. \"Всё, — сказали провидцы, — терминалы умрут. Кому нужна эта архаика с командами, когда можно щёлкать по иконкам?\"</p>\n\n<p>Не умерли. Более того, программисты стали скучать по терминалам так сильно, что написали... программы, притворяющиеся терминалами! <strong>Эмуляторы терминалов</strong> — софт, который имитирует железо 1970-х внутри современного компьютера. Это как если бы люди в 2025 году специально покупали приложение, имитирующее дисковый телефон. Абсурд? </p>\n\n<p>Terminal в macOS, сотни вариантов в Linux, cmd и PowerShell в Windows — все они одевают костюм VT100. Открываете терминал на MacBook за три тысячи долларов, а он ведёт себя как устройство за триста долларов из 1978-го. И всем нравится!</p>\n\n<p>В Linux добавили <strong>виртуальные консоли</strong> — несколько текстовых экранов, встроенных в ядро. Ctrl+Alt+F1, F2, F3... переключаетесь между ними как между телеканалами. Древняя консоль размножилась и стала виртуальной.</p>\n\n<p><strong>Тут началась терминологическая анархия.</strong> Люди стали называть \"консолью\" всё подряд: и эмулятор терминала, и виртуальную консоль Linux, и вообще любое чёрное окошко с текстом. Windows официально объявила программы с текстовым вводом-выводом \"консольными приложениями\". Строгие определения растворились в народном языке. Терминал, консоль, командная строка, шелл — спросите у десяти программистов, получите одиннадцать ответов.</p>\n\n<p>И вот вопрос: почему в 2025 году, в эпоху нейросетей и квантовых компьютеров, <strong>Scala 3 всё ещё имеет println и stdin</strong>?</p>\n\n<p>Потому что это работает. Везде. Всегда.</p>\n\n<p><strong>Универсальность</strong>: текстовые потоки понимает любое устройство. От Raspberry Pi за тридцать долларов до суперкомпьютера за тридцать миллионов. Ваша программа заработает на сервере без монитора, в Docker-контейнере, через SSH с другого континента.</p>\n\n<p><strong>Простота</strong>: хотите понять, что делает код? Впихните туда println. Профессиональные отладчики прекрасны, но для быстрой проверки \"а что тут происходит?\" нет ничего проще вывода в консоль. Это изолента программирования.</p>\n\n<p><strong>Комбинируемость</strong>: Unix-философия \"делай одно, делай хорошо\" жива. Современный DevOps-инженер может написать однострочную команду из пяти программ, соединённых трубами, которая обработает гигабайты логов за секунды. Попробуйте такое в графическом интерфейсе.</p>\n\n<p><strong>Совместимость</strong>: миллионы строк кода, написанных за полвека, полагаются на stdin/stdout. Выбросить это — потерять экосистему инструментов размером с небольшую планету.</p>\n\n<p><strong>Скорость</strong>: опытный человек в терминале работает быстрее, чем кто угодно с мышкой. Руки на клавиатуре, мышление на уровне команд, никаких меню и подменю. </p>\n\n<p>Так что когда вы пишете в Scala 3 что-то вроде println, вы не используете устаревшую технологию. Вы подключаетесь к эпической саге, которая началась с грохочущих телетайпов, прошла через зелёные экраны VT100, пережила графические революции, освоила облака и продолжает жить.</p>\n\n<p>Консольный ввод-вывод — это не баг, это фича. Не технический долг, а фундамент. Он пережил перфокарты, дискеты, CD-ROM, и переживёт всё остальное.</p>\n\n<p>Потому что простые идеи бессмертны. А идея \"текст течёт по трубам между программами\" оказалась настолько простой и мощной, что человечество за пятьдесят лет не придумало ничего лучше.</p>",
  "video" : null,
  "options" : {
    
  },
  "subtitle_files" : [
  ],
  "is_deprecated" : false
}
```

</details>
