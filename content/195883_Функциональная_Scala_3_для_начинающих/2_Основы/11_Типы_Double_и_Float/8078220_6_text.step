{
  "step_id" : 8078220,
  "lesson_id" : 1230060,
  "position" : 6,
  "type" : "unknown",
  "block" : {
    "name" : "text",
    "text" : "<h1 style=\"text-align:center;\">Алгебраические свойства типа Double</h1>\n\n<p>В Scala тип <code>Double</code> — это не просто числовой примитив, а одна из наиболее насыщенных с точки зрения алгебры структур. Он реализует стандарт IEEE 754 для чисел с плавающей точкой двойной точности и тем самым отражает сложное взаимодействие между абстрактной математикой и практическими ограничениями вычислительных систем.</p>\n\n<p>С точки зрения алгебры <code>Double</code> можно рассматривать как приближение к полю действительных чисел. Большинство его операций подчиняются тем же законам, что и в математике, однако конечная точность представления вносит важные отличия. Появляются особые элементы (NaN, ±∞), а также погрешности округления, которые делают некоторые привычные свойства полей лишь приближённо верными.</p>\n\n<p>Эта двойственная природа делает <code>Double</code> особенно интересным: он ведёт себя как поле, но требует внимательности при работе с равенством, ассоциативностью и дистрибутивностью. На практике это означает, что численные алгоритмы должны учитывать специфику представления, чтобы быть корректными и устойчивыми.</p>\n\n<p>Понимание алгебраических особенностей <code>Double</code> критически важно в численных вычислениях, научном программировании и финансовых приложениях. При правильном использовании он становится мощным инструментом, позволяющим соединять строгость математических моделей с ограничениями аппаратных вычислений.</p>\n\n<p>Таким образом, <code>Double</code> в Scala — это центральный тип для научных и прикладных задач, воплощающий богатство математических операций в пределах вычислительной системы и открывающий путь к построению более надёжного и предсказуемого кода.</p>\n\n<blockquote>\n<p><strong>Примечание</strong>: Данная статья является справочной, и не требует подробного изучения в данный момент. Некоторые термины и понятия могут быть неизвестными для обучающегося. Однако она содержит полезную информацию обзорного свойства для более глубокого понимания темы.</p>\n</blockquote>\n\n<h2 style=\"text-align:center;\">Полевые структуры</h2>\n\n<h3>Аддитивная группа</h3>\n\n<p>Double с операцией сложения образует коммутативную группу (за исключением специальных значений):</p>\n\n<pre><code class=\"language-scala\">// Нейтральный элемент: 0.0\nval x = 42.5\nval zero = 0.0\n\nx + zero == x  // true\nzero + x == x  // true\n\n// Обратные элементы\nval y = 3.14\nval negY = -y\ny + negY == zero  // true (с учетом точности)\nnegY + y == zero  // true\n\n// Коммутативность\nval a = 2.5\nval b = 3.7\na + b == b + a  // true\n\n// Ассоциативность (с оговорками о точности)\nval c = 1.2\n(a + b) + c == a + (b + c)  // обычно true, но могут быть расхождения\n</code></pre>\n\n<h3>Мультипликативная группа</h3>\n\n<p>Double (исключая 0.0) с операцией умножения образует коммутативную группу:</p>\n\n<pre><code class=\"language-scala\">// Нейтральный элемент: 1.0\nval x = 42.5\nval one = 1.0\n\nx * one == x  // true\none * x == x  // true\n\n// Обратные элементы (кроме нуля)\nval y = 2.5\nval invY = 1.0 / y\ny * invY == one  // true (приближенно)\ninvY * y == one  // true (приближенно)\n\n// Коммутативность\nval a = 2.5\nval b = 3.0\na * b == b * a  // true\n\n// Ассоциативность\nval c = 4.0\n(a * b) * c == a * (b * c)  // true (с учетом точности)\n</code></pre>\n\n<h3>Полевые свойства</h3>\n\n<p>Double приближается к полю действительных чисел:</p>\n\n<pre><code class=\"language-scala\">val a = 2.5\nval b = 3.0\nval c = 1.5\n\n// Дистрибутивность: a * (b + c) = a * b + a * c\nval left = a * (b + c)\nval right = a * b + a * c\nmath.abs(left - right) &lt; 1e-15  // true (с учетом точности)\n\n// Существование обратных (кроме нуля)\nval x = 7.25\nval inverse = 1.0 / x\nmath.abs(x * inverse - 1.0) &lt; 1e-15  // true\n\n// Деление как умножение на обратный\nval y = 3.5\nval z = 2.0\nmath.abs(y / z - y * (1.0 / z)) &lt; 1e-15  // true\n</code></pre>\n\n<h2 style=\"text-align:center;\">Упорядоченные структуры</h2>\n\n<h3>Тотальный порядок</h3>\n\n<p>Double образует тотально упорядоченное множество (с особенностями для NaN):</p>\n\n<pre><code class=\"language-scala\">val a = 2.5\nval b = 3.7\nval c = 1.2\n\n// Сравнения\na &lt; b   // true\nb &gt; c   // true  \na &gt; c   // true\n\n// Транзитивность\n(a &lt; b) &amp;&amp; (b &gt; c) &amp;&amp; (a &gt; c)  // true\n\n// Антисимметричность\nval x = 2.5\nval y = 2.5\n(x &lt;= y) &amp;&amp; (y &lt;= x) &amp;&amp; (x == y)  // true\n\n// Сравнение с методами\na.compareTo(b)  // отрицательное число\nb.compareTo(a)  // положительное число  \na.compareTo(a)  // 0\n</code></pre>\n\n<h3>Минимум и максимум</h3>\n\n<pre><code class=\"language-scala\">val values = Array(3.14, 2.71, 1.41, 4.67)\n\n// Встроенные функции min/max\nval minimum = values.min  // 1.41\nval maximum = values.max  // 4.67\n\n// Math функции\nval a = 2.5\nval b = 3.7\nmath.min(a, b)  // 2.5\nmath.max(a, b)  // 3.7\n\n// Решеточные свойства (идемпотентность)\nmath.min(a, a) == a  // true\nmath.max(a, a) == a  // true\n\n// Коммутативность\nmath.min(a, b) == math.min(b, a)  // true\nmath.max(a, b) == math.max(b, a)  // true\n</code></pre>\n\n<h2 style=\"text-align:center;\">Специальные значения IEEE 754</h2>\n\n<h3>Положительная и отрицательная бесконечность</h3>\n\n<pre><code class=\"language-scala\">val posInf = Double.PositiveInfinity\nval negInf = Double.NegativeInfinity\nval finite = 42.5\n\n// Арифметика с бесконечностями\nfinite + posInf == posInf  // true\nfinite * posInf == posInf  // true (для положительных finite)\nposInf + posInf == posInf  // true\nposInf * posInf == posInf  // true\n\n// Деление на ноль\nfinite / 0.0 == posInf     // true (для положительных)\n(-finite) / 0.0 == negInf  // true\n\n// Сравнения с бесконечностями\nfinite &lt; posInf  // true\nfinite &gt; negInf  // true\nnegInf &lt; finite  // true\nposInf &gt; finite  // true\n</code></pre>\n\n<h3>NaN (Not a Number)</h3>\n\n<pre><code class=\"language-scala\">val nan = Double.NaN\nval finite = 42.5\n\n// Особые свойства NaN\nnan == nan        // false! (уникальное свойство)\nnan != nan        // true\nnan.equals(nan)   // true (в Scala)\n\n// NaN в арифметических операциях\nfinite + nan      // NaN\nfinite * nan      // NaN  \nnan + nan         // NaN\n\n// NaN в сравнениях\nnan &lt; finite      // false\nnan &gt; finite      // false\nnan == finite     // false\n\n// Проверка на NaN\nnan.isNaN         // true\nfinite.isNaN      // false\n</code></pre>\n\n<h3>Проверки специальных значений</h3>\n\n<pre><code class=\"language-scala\">val values = Array(42.5, Double.PositiveInfinity, Double.NaN, -17.3)\n\n// Классификация значений\nvalues.map(_.isFinite)     // Array(true, false, false, true)\nvalues.map(_.isInfinite)   // Array(false, true, false, false)  \nvalues.map(_.isNaN)        // Array(false, false, true, false)\n\n// Проверка знака\nval positive = 3.14\nval negative = -2.71\nval zero = 0.0\n\npositive.sign  // 1.0\nnegative.sign  // -1.0\nzero.sign      // 0.0\n\n// Проверка знака нуля\nval negativeZero = -0.0\nnegativeZero == zero     // true\n1.0 / zero == Double.PositiveInfinity   // true\n1.0 / negativeZero == Double.NegativeInfinity  // true\n</code></pre>\n\n<h2 style=\"text-align:center;\">Математические функции</h2>\n\n<h3>Элементарные функции</h3>\n\n<pre><code class=\"language-scala\">val x = 2.0\nval y = 3.0\n\n// Степенные функции\nmath.pow(x, y)    // 8.0 (2^3)\nmath.sqrt(x)      // 1.4142135623730951\nmath.cbrt(27.0)   // 3.0 (кубический корень)\n\n// Экспоненциальные функции  \nmath.exp(1.0)     // 2.718281828459045 (e)\nmath.exp2(3.0)    // 8.0 (2^3)\nmath.expm1(0.1)   // более точное вычисление exp(x) - 1\n\n// Логарифмические функции\nmath.log(math.E)   // 1.0 (натуральный логарифм)\nmath.log10(100.0)  // 2.0 (десятичный логарифм)\nmath.log1p(0.1)    // более точное вычисление log(1 + x)\n</code></pre>\n\n<h3>Тригонометрические функции</h3>\n\n<pre><code class=\"language-scala\">val angle = math.Pi / 4  // 45 градусов\n\n// Основные тригонометрические функции\nmath.sin(angle)      // 0.7071067811865476 (√2/2)\nmath.cos(angle)      // 0.7071067811865476 (√2/2)  \nmath.tan(angle)      // 1.0\n\n// Обратные тригонометрические функции\nmath.asin(0.5)       // π/6\nmath.acos(0.5)       // π/3\nmath.atan(1.0)       // π/4\n\n// Гиперболические функции\nmath.sinh(1.0)       // 1.1752011936438014\nmath.cosh(1.0)       // 1.5430806348152437\nmath.tanh(1.0)       // 0.7615941559557649\n\n// Тригонометрические тождества\nval x = 0.7\nval sinSquared = math.pow(math.sin(x), 2)\nval cosSquared = math.pow(math.cos(x), 2)\nmath.abs(sinSquared + cosSquared - 1.0) &lt; 1e-15  // true\n</code></pre>\n\n<h3>Функции округления</h3>\n\n<pre><code class=\"language-scala\">val x = 3.14159\nval y = -2.71828\n\n// Различные виды округления\nmath.floor(x)    // 3.0 (округление вниз)\nmath.ceil(x)     // 4.0 (округление вверх)  \nmath.round(x)    // 3 (Int) (округление к ближайшему)\nmath.rint(x)     // 3.0 (округление к ближайшему четному)\n\n// Округление отрицательных чисел\nmath.floor(y)    // -3.0\nmath.ceil(y)     // -2.0\nmath.round(y)    // -3\n\n// Извлечение частей\nval value = 123.456\nval intPart = math.floor(math.abs(value)) * math.signum(value)  // 123.0\nval fracPart = value - intPart  // 0.456\n</code></pre>\n\n<h2 style=\"text-align:center;\">Точность и ошибки вычислений</h2>\n\n<h3>Проблемы точности</h3>\n\n<pre><code class=\"language-scala\">// Классические проблемы с плавающей точкой\nval a = 0.1\nval b = 0.2\nval sum = a + b\nsum == 0.3  // false! (0.30000000000000004)\n\n// Безопасные сравнения\ndef almostEqual(x: Double, y: Double, epsilon: Double = 1e-15): Boolean =\n  math.abs(x - y) &lt; epsilon\n\nalmostEqual(sum, 0.3)  // true\n\n// Накопление ошибок\nval iterations = 1000000\nval increment = 1.0 / iterations  \nval accumulated = (1 to iterations).foldLeft(0.0)(_ + increment)\nalmostEqual(accumulated, 1.0, 1e-10)  // может быть false из-за накопления ошибок\n</code></pre>\n\n<h3>Машинная точность</h3>\n\n<pre><code class=\"language-scala\">// Машинный эпсилон\nval machineEpsilon = {\n  var eps = 1.0\n  while (1.0 + eps &gt; 1.0) {\n    eps /= 2.0\n  }\n  eps * 2.0\n}\n\n// Относительные ошибки\ndef relativeError(computed: Double, expected: Double): Double =\n  if (expected != 0.0) math.abs((computed - expected) / expected) else Double.PositiveInfinity\n\nval computed = math.sin(math.Pi)  // должно быть 0, но получаем ~1.2e-16\nval expected = 0.0\nrelativeError(computed, expected)  // Infinity (деление на ноль)\nmath.abs(computed) &lt; 1e-15  // true (абсолютная ошибка мала)\n</code></pre>\n\n<h2 style=\"text-align:center;\">Числовые представления</h2>\n\n<h3>Битовое представление</h3>\n\n<pre><code class=\"language-scala\">val x = 3.14159\n\n// Преобразование в Long (битовое представление)\nval bits = java.lang.Double.doubleToLongBits(x)\nval restored = java.lang.Double.longBitsToDouble(bits)\nrestored == x  // true\n\n// Сырые биты (учитывает NaN)\nval rawBits = java.lang.Double.doubleToRawLongBits(x)\n\n// Анализ структуры IEEE 754\nval signBit = (bits &gt;&gt;&gt; 63) &amp; 1\nval exponentBits = (bits &gt;&gt;&gt; 52) &amp; 0x7FF  \nval mantissaBits = bits &amp; 0xFFFFFFFFFFFFL\n\n// Специальные значения в битах\nval nanBits = java.lang.Double.doubleToLongBits(Double.NaN)\nval posInfBits = java.lang.Double.doubleToLongBits(Double.PositiveInfinity)\nval negInfBits = java.lang.Double.doubleToLongBits(Double.NegativeInfinity)\n</code></pre>\n\n<h3>Пределы и диапазоны</h3>\n\n<pre><code class=\"language-scala\">// Границы представления\nval maxValue = Double.MaxValue     // 1.7976931348623157E308\nval minValue = Double.MinValue     // 4.9E-324 (наименьшее положительное)\nval minNormal = Double.MinPositiveValue\n\n// Проверки диапазонов\nval huge = 1e300\nval tiny = 1e-300\n\nhuge &lt; Double.MaxValue    // true\ntiny &gt; Double.MinPositiveValue  // true\n\n// Переполнения\nval overflow = Double.MaxValue * 2  // Infinity\nval underflow = Double.MinPositiveValue / 2  // 0.0\n</code></pre>\n\n<h2 style=\"text-align:center;\">Преобразования типов</h2>\n\n<h3>Числовые преобразования</h3>\n\n<pre><code class=\"language-scala\">val d = 42.75\n\n// Преобразования в целые типы\nd.toInt      // 42 (обрезание дробной части)\nd.toLong     // 42L\nd.toShort    // 42\nd.toByte     // 42\n\n// Преобразования в другие типы с плавающей точкой\nd.toFloat    // 42.75f\n\n// Безопасные преобразования с проверкой диапазона\ndef safeToInt(d: Double): Option[Int] =\n  if (d.isValidInt) Some(d.toInt) else None\n\nsafeToInt(42.75)         // Some(42)\nsafeToInt(1e10)          // None (выходит за границы Int)\nsafeToInt(Double.NaN)    // None\n</code></pre>\n\n<h3>Строковые представления</h3>\n\n<pre><code class=\"language-scala\">val pi = math.Pi\nval large = 1.23e15\nval small = 1.23e-15\n\n// Различные форматы строк\npi.toString              // \"3.141592653589793\"\nlarge.toString           // \"1.23E15\"\nsmall.toString           // \"1.23E-15\"\n\n// Форматированный вывод\nf\"$pi%.2f\"              // \"3.14\"\nf\"$pi%.6f\"              // \"3.141593\"  \nf\"$large%.2e\"           // \"1.23e+15\"\nf\"$small%.2e\"           // \"1.23e-15\"\n\n// Парсинг из строк\n\"3.14159\".toDouble      // 3.14159\n\"1.23e-15\".toDouble     // 1.23E-15\n\"Infinity\".toDouble     // Infinity\n\"NaN\".toDouble          // NaN\n\n// Безопасный парсинг\n\"3.14\".toDoubleOption   // Some(3.14)\n\"not a number\".toDoubleOption  // None\n</code></pre>\n\n<h2 style=\"text-align:center;\">Статистические и агрегационные операции</h2>\n\n<h3>Базовые агрегации</h3>\n\n<pre><code class=\"language-scala\">val data = Array(1.5, 2.7, 3.1, 4.9, 2.3, 6.8, 1.2)\n\n// Основные статистики\nval sum = data.sum                    // 22.5\nval count = data.length               // 7\nval mean = sum / count                // 3.214...\n\nval minimum = data.min                // 1.2\nval maximum = data.max                // 6.8\nval range = maximum - minimum         // 5.6\n\n// Сортировка для медианы\nval sorted = data.sorted\nval median = if (sorted.length % 2 == 1) {\n  sorted(sorted.length / 2)\n} else {\n  (sorted(sorted.length / 2 - 1) + sorted(sorted.length / 2)) / 2\n}\n</code></pre>\n\n<h3>Дисперсия и стандартное отклонение</h3>\n\n<pre><code class=\"language-scala\">val values = Array(2.0, 4.0, 4.0, 4.0, 5.0, 5.0, 7.0, 9.0)\n\nval mean = values.sum / values.length\n\n// Дисперсия (несмещенная)\nval variance = values.map(x =&gt; math.pow(x - mean, 2)).sum / (values.length - 1)\n\n// Стандартное отклонение  \nval stdDev = math.sqrt(variance)\n\n// Коэффициент вариации\nval coefficientOfVariation = stdDev / mean\n\n// Z-оценки (стандартизация)\nval zScores = values.map(x =&gt; (x - mean) / stdDev)\n</code></pre>\n\n<h2 style=\"text-align:center;\">Численные методы</h2>\n\n<h3>Приближенные вычисления</h3>\n\n<pre><code class=\"language-scala\">// Метод Ньютона для квадратного корня\ndef newtonSqrt(x: Double, guess: Double = 1.0, iterations: Int = 10): Double = {\n  if (iterations == 0) guess\n  else {\n    val newGuess = (guess + x / guess) / 2\n    newtonSqrt(x, newGuess, iterations - 1)\n  }\n}\n\nval approximateSqrt = newtonSqrt(25.0)  // приближенно 5.0\nval exactSqrt = math.sqrt(25.0)\nmath.abs(approximateSqrt - exactSqrt) &lt; 1e-15  // true\n\n// Вычисление π методом Лейбница\ndef leibnizPi(terms: Int): Double = {\n  (0 until terms).map { n =&gt;\n    val sign = if (n % 2 == 0) 1.0 else -1.0\n    sign / (2 * n + 1)\n  }.sum * 4\n}\n\nval approximatePi = leibnizPi(100000)\nmath.abs(approximatePi - math.Pi) &lt; 0.01  // true (медленная сходимость)\n</code></pre>\n\n<h3>Интегрирование</h3>\n\n<pre><code class=\"language-scala\">// Правило трапеций для численного интегрирования\ndef trapezoidalRule(f: Double =&gt; Double, a: Double, b: Double, n: Int): Double = {\n  val h = (b - a) / n\n  val sum = (1 until n).map(i =&gt; f(a + i * h)).sum\n  h * (f(a) + 2 * sum + f(b)) / 2\n}\n\n// Интегрирование x^2 от 0 до 2 (точный результат: 8/3)\nval integral = trapezoidalRule(x =&gt; x * x, 0.0, 2.0, 1000)\nval exact = 8.0 / 3.0\nmath.abs(integral - exact) &lt; 0.001  // true\n</code></pre>\n\n<h2 style=\"text-align:center;\">Вероятностные распределения</h2>\n\n<h3>Генерация случайных чисел</h3>\n\n<pre><code class=\"language-scala\">import scala.util.Random\n\nval random = new Random(42)  // фиксированное seed\n\n// Равномерное распределение [0, 1)\nval uniform = random.nextDouble()\n\n// Нормальное распределение\nval gaussian = random.nextGaussian()\n\n// Равномерное в диапазоне [min, max)\ndef uniformRange(min: Double, max: Double): Double = \n  min + random.nextDouble() * (max - min)\n\n// Экспоненциальное распределение\ndef exponential(lambda: Double): Double = \n  -math.log(1 - random.nextDouble()) / lambda\n\n// Проверка свойств нормального распределения\nval samples = (1 to 10000).map(_ =&gt; random.nextGaussian())\nval sampleMean = samples.sum / samples.length\nval sampleVariance = samples.map(x =&gt; (x - sampleMean) * (x - sampleMean)).sum / samples.length\n\nmath.abs(sampleMean) &lt; 0.1      // должно быть близко к 0\nmath.abs(sampleVariance - 1.0) &lt; 0.1  // должно быть близко к 1\n</code></pre>",
    "video" : null,
    "options" : {
      
    },
    "subtitle_files" : [
    ],
    "is_deprecated" : false
  },
  "name" : "text",
  "course_id" : 195883,
  "course_name" : "Функциональная Scala 3 для начинающих",
  "exported_at" : "2025-12-20T22:21:05.3576614"
}