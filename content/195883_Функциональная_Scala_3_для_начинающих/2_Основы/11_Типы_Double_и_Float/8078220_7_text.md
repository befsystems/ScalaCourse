# Материал (Шаг 7)

## Информация о шаге

- **ID шага**: 8078220
- **Позиция**: 7
- **Тип**: text
- **Курс**: Функциональная Scala 3 для начинающих
- **Экспортирован**: 2026-01-10T10:17:05.6164739

## Содержание

# Алгебраические свойства типа Double

В Scala тип `Double` — это не просто числовой примитив, а одна из наиболее насыщенных с точки зрения алгебры структур. Он реализует стандарт IEEE 754 для чисел с плавающей точкой двойной точности и тем самым отражает сложное взаимодействие между абстрактной математикой и практическими ограничениями вычислительных систем.

С точки зрения алгебры `Double` можно рассматривать как приближение к полю действительных чисел. Большинство его операций подчиняются тем же законам, что и в математике, однако конечная точность представления вносит важные отличия. Появляются особые элементы (NaN, ±∞), а также погрешности округления, которые делают некоторые привычные свойства полей лишь приближённо верными.

Эта двойственная природа делает `Double` особенно интересным: он ведёт себя как поле, но требует внимательности при работе с равенством, ассоциативностью и дистрибутивностью. На практике это означает, что численные алгоритмы должны учитывать специфику представления, чтобы быть корректными и устойчивыми.

Понимание алгебраических особенностей `Double` критически важно в численных вычислениях, научном программировании и финансовых приложениях. При правильном использовании он становится мощным инструментом, позволяющим соединять строгость математических моделей с ограничениями аппаратных вычислений.

Таким образом, `Double` в Scala — это центральный тип для научных и прикладных задач, воплощающий богатство математических операций в пределах вычислительной системы и открывающий путь к построению более надёжного и предсказуемого кода.

**Примечание**: Данная статья является справочной, и не требует подробного изучения в данный момент. Некоторые термины и понятия могут быть неизвестными для обучающегося. Однако она содержит полезную информацию обзорного свойства для более глубокого понимания темы.

## Полевые структуры

### Аддитивная группа

Double с операцией сложения образует коммутативную группу (за исключением специальных значений):

// Нейтральный элемент: 0.0
val x = 42.5
val zero = 0.0

x + zero == x // true
zero + x == x // true

// Обратные элементы
val y = 3.14
val negY = -y
y + negY == zero // true (с учетом точности)
negY + y == zero // true

// Коммутативность
val a = 2.5
val b = 3.7
a + b == b + a // true

// Ассоциативность (с оговорками о точности)
val c = 1.2
(a + b) + c == a + (b + c) // обычно true, но могут быть расхождения

### Мультипликативная группа

Double (исключая 0.0) с операцией умножения образует коммутативную группу:

// Нейтральный элемент: 1.0
val x = 42.5
val one = 1.0

x * one == x // true
one * x == x // true

// Обратные элементы (кроме нуля)
val y = 2.5
val invY = 1.0 / y
y * invY == one // true (приближенно)
invY * y == one // true (приближенно)

// Коммутативность
val a = 2.5
val b = 3.0
a * b == b * a // true

// Ассоциативность
val c = 4.0
(a * b) * c == a * (b * c) // true (с учетом точности)

### Полевые свойства

Double приближается к полю действительных чисел:

val a = 2.5
val b = 3.0
val c = 1.5

// Дистрибутивность: a * (b + c) = a * b + a * c
val left = a * (b + c)
val right = a * b + a * c
math.abs(left - right) < 1e-15 // true (с учетом точности)

// Существование обратных (кроме нуля)
val x = 7.25
val inverse = 1.0 / x
math.abs(x * inverse - 1.0) < 1e-15 // true

// Деление как умножение на обратный
val y = 3.5
val z = 2.0
math.abs(y / z - y * (1.0 / z)) < 1e-15 // true

## Упорядоченные структуры

### Тотальный порядок

Double образует тотально упорядоченное множество (с особенностями для NaN):

val a = 2.5
val b = 3.7
val c = 1.2

// Сравнения
a < b // true
b > c // true
a > c // true

// Транзитивность
(a < b) && (b > c) && (a > c) // true

// Антисимметричность
val x = 2.5
val y = 2.5
(x <= y) && (y <= x) && (x == y) // true

// Сравнение с методами
a.compareTo(b) // отрицательное число
b.compareTo(a) // положительное число
a.compareTo(a) // 0

### Минимум и максимум

val values = Array(3.14, 2.71, 1.41, 4.67)

// Встроенные функции min/max
val minimum = values.min // 1.41
val maximum = values.max // 4.67

// Math функции
val a = 2.5
val b = 3.7
math.min(a, b) // 2.5
math.max(a, b) // 3.7

// Решеточные свойства (идемпотентность)
math.min(a, a) == a // true
math.max(a, a) == a // true

// Коммутативность
math.min(a, b) == math.min(b, a) // true
math.max(a, b) == math.max(b, a) // true

## Специальные значения IEEE 754

### Положительная и отрицательная бесконечность

val posInf = Double.PositiveInfinity
val negInf = Double.NegativeInfinity
val finite = 42.5

// Арифметика с бесконечностями
finite + posInf == posInf // true
finite * posInf == posInf // true (для положительных finite)
posInf + posInf == posInf // true
posInf * posInf == posInf // true

// Деление на ноль
finite / 0.0 == posInf // true (для положительных)
(-finite) / 0.0 == negInf // true

// Сравнения с бесконечностями
finite < posInf // true
finite > negInf // true
negInf < finite // true
posInf > finite // true

### NaN (Not a Number)

val nan = Double.NaN
val finite = 42.5

// Особые свойства NaN
nan == nan // false! (уникальное свойство)
nan != nan // true
nan.equals(nan) // true (в Scala)

// NaN в арифметических операциях
finite + nan // NaN
finite * nan // NaN
nan + nan // NaN

// NaN в сравнениях
nan < finite // false
nan > finite // false
nan == finite // false

// Проверка на NaN
nan.isNaN // true
finite.isNaN // false

### Проверки специальных значений

val values = Array(42.5, Double.PositiveInfinity, Double.NaN, -17.3)

// Классификация значений
values.map(_.isFinite) // Array(true, false, false, true)
values.map(_.isInfinite) // Array(false, true, false, false)
values.map(_.isNaN) // Array(false, false, true, false)

// Проверка знака
val positive = 3.14
val negative = -2.71
val zero = 0.0

positive.sign // 1.0
negative.sign // -1.0
zero.sign // 0.0

// Проверка знака нуля
val negativeZero = -0.0
negativeZero == zero // true
1.0 / zero == Double.PositiveInfinity // true
1.0 / negativeZero == Double.NegativeInfinity // true

## Математические функции

### Элементарные функции

val x = 2.0
val y = 3.0

// Степенные функции
math.pow(x, y) // 8.0 (2^3)
math.sqrt(x) // 1.4142135623730951
math.cbrt(27.0) // 3.0 (кубический корень)

// Экспоненциальные функции
math.exp(1.0) // 2.718281828459045 (e)
math.exp2(3.0) // 8.0 (2^3)
math.expm1(0.1) // более точное вычисление exp(x) - 1

// Логарифмические функции
math.log(math.E) // 1.0 (натуральный логарифм)
math.log10(100.0) // 2.0 (десятичный логарифм)
math.log1p(0.1) // более точное вычисление log(1 + x)

### Тригонометрические функции

val angle = math.Pi / 4 // 45 градусов

// Основные тригонометрические функции
math.sin(angle) // 0.7071067811865476 (√2/2)
math.cos(angle) // 0.7071067811865476 (√2/2)
math.tan(angle) // 1.0

// Обратные тригонометрические функции
math.asin(0.5) // π/6
math.acos(0.5) // π/3
math.atan(1.0) // π/4

// Гиперболические функции
math.sinh(1.0) // 1.1752011936438014
math.cosh(1.0) // 1.5430806348152437
math.tanh(1.0) // 0.7615941559557649

// Тригонометрические тождества
val x = 0.7
val sinSquared = math.pow(math.sin(x), 2)
val cosSquared = math.pow(math.cos(x), 2)
math.abs(sinSquared + cosSquared - 1.0) < 1e-15 // true

### Функции округления

val x = 3.14159
val y = -2.71828

// Различные виды округления
math.floor(x) // 3.0 (округление вниз)
math.ceil(x) // 4.0 (округление вверх)
math.round(x) // 3 (Int) (округление к ближайшему)
math.rint(x) // 3.0 (округление к ближайшему четному)

// Округление отрицательных чисел
math.floor(y) // -3.0
math.ceil(y) // -2.0
math.round(y) // -3

// Извлечение частей
val value = 123.456
val intPart = math.floor(math.abs(value)) * math.signum(value) // 123.0
val fracPart = value - intPart // 0.456

## Точность и ошибки вычислений

### Проблемы точности

// Классические проблемы с плавающей точкой
val a = 0.1
val b = 0.2
val sum = a + b
sum == 0.3 // false! (0.30000000000000004)

// Безопасные сравнения
def almostEqual(x: Double, y: Double, epsilon: Double = 1e-15): Boolean =
math.abs(x - y) < epsilon

almostEqual(sum, 0.3) // true

// Накопление ошибок
val iterations = 1000000
val increment = 1.0 / iterations
val accumulated = (1 to iterations).foldLeft(0.0)(_ + increment)
almostEqual(accumulated, 1.0, 1e-10) // может быть false из-за накопления ошибок

### Машинная точность

// Машинный эпсилон
val machineEpsilon = {
var eps = 1.0
while (1.0 + eps > 1.0) {
eps /= 2.0
}
eps * 2.0
}

// Относительные ошибки
def relativeError(computed: Double, expected: Double): Double =
if (expected != 0.0) math.abs((computed - expected) / expected) else Double.PositiveInfinity

val computed = math.sin(math.Pi) // должно быть 0, но получаем ~1.2e-16
val expected = 0.0
relativeError(computed, expected) // Infinity (деление на ноль)
math.abs(computed) < 1e-15 // true (абсолютная ошибка мала)

## Числовые представления

### Битовое представление

val x = 3.14159

// Преобразование в Long (битовое представление)
val bits = java.lang.Double.doubleToLongBits(x)
val restored = java.lang.Double.longBitsToDouble(bits)
restored == x // true

// Сырые биты (учитывает NaN)
val rawBits = java.lang.Double.doubleToRawLongBits(x)

// Анализ структуры IEEE 754
val signBit = (bits >>> 63) & 1
val exponentBits = (bits >>> 52) & 0x7FF
val mantissaBits = bits & 0xFFFFFFFFFFFFL

// Специальные значения в битах
val nanBits = java.lang.Double.doubleToLongBits(Double.NaN)
val posInfBits = java.lang.Double.doubleToLongBits(Double.PositiveInfinity)
val negInfBits = java.lang.Double.doubleToLongBits(Double.NegativeInfinity)

### Пределы и диапазоны

// Границы представления
val maxValue = Double.MaxValue // 1.7976931348623157E308
val minValue = Double.MinValue // 4.9E-324 (наименьшее положительное)
val minNormal = Double.MinPositiveValue

// Проверки диапазонов
val huge = 1e300
val tiny = 1e-300

huge < Double.MaxValue // true
tiny > Double.MinPositiveValue // true

// Переполнения
val overflow = Double.MaxValue * 2 // Infinity
val underflow = Double.MinPositiveValue / 2 // 0.0

## Преобразования типов

### Числовые преобразования

val d = 42.75

// Преобразования в целые типы
d.toInt // 42 (обрезание дробной части)
d.toLong // 42L
d.toShort // 42
d.toByte // 42

// Преобразования в другие типы с плавающей точкой
d.toFloat // 42.75f

// Безопасные преобразования с проверкой диапазона
def safeToInt(d: Double): Option[Int] =
if (d.isValidInt) Some(d.toInt) else None

safeToInt(42.75) // Some(42)
safeToInt(1e10) // None (выходит за границы Int)
safeToInt(Double.NaN) // None

### Строковые представления

val pi = math.Pi
val large = 1.23e15
val small = 1.23e-15

// Различные форматы строк
pi.toString // "3.141592653589793"
large.toString // "1.23E15"
small.toString // "1.23E-15"

// Форматированный вывод
f"$pi%.2f" // "3.14"
f"$pi%.6f" // "3.141593"
f"$large%.2e" // "1.23e+15"
f"$small%.2e" // "1.23e-15"

// Парсинг из строк
"3.14159".toDouble // 3.14159
"1.23e-15".toDouble // 1.23E-15
"Infinity".toDouble // Infinity
"NaN".toDouble // NaN

// Безопасный парсинг
"3.14".toDoubleOption // Some(3.14)
"not a number".toDoubleOption // None

## Статистические и агрегационные операции

### Базовые агрегации

val data = Array(1.5, 2.7, 3.1, 4.9, 2.3, 6.8, 1.2)

// Основные статистики
val sum = data.sum // 22.5
val count = data.length // 7
val mean = sum / count // 3.214...

val minimum = data.min // 1.2
val maximum = data.max // 6.8
val range = maximum - minimum // 5.6

// Сортировка для медианы
val sorted = data.sorted
val median = if (sorted.length % 2 == 1) {
sorted(sorted.length / 2)
} else {
(sorted(sorted.length / 2 - 1) + sorted(sorted.length / 2)) / 2
}

### Дисперсия и стандартное отклонение

val values = Array(2.0, 4.0, 4.0, 4.0, 5.0, 5.0, 7.0, 9.0)

val mean = values.sum / values.length

// Дисперсия (несмещенная)
val variance = values.map(x => math.pow(x - mean, 2)).sum / (values.length - 1)

// Стандартное отклонение
val stdDev = math.sqrt(variance)

// Коэффициент вариации
val coefficientOfVariation = stdDev / mean

// Z-оценки (стандартизация)
val zScores = values.map(x => (x - mean) / stdDev)

## Численные методы

### Приближенные вычисления

// Метод Ньютона для квадратного корня
def newtonSqrt(x: Double, guess: Double = 1.0, iterations: Int = 10): Double = {
if (iterations == 0) guess
else {
val newGuess = (guess + x / guess) / 2
newtonSqrt(x, newGuess, iterations - 1)
}
}

val approximateSqrt = newtonSqrt(25.0) // приближенно 5.0
val exactSqrt = math.sqrt(25.0)
math.abs(approximateSqrt - exactSqrt) < 1e-15 // true

// Вычисление π методом Лейбница
def leibnizPi(terms: Int): Double = {
(0 until terms).map { n =>
val sign = if (n % 2 == 0) 1.0 else -1.0
sign / (2 * n + 1)
}.sum * 4
}

val approximatePi = leibnizPi(100000)
math.abs(approximatePi - math.Pi) < 0.01 // true (медленная сходимость)

### Интегрирование

// Правило трапеций для численного интегрирования
def trapezoidalRule(f: Double => Double, a: Double, b: Double, n: Int): Double = {
val h = (b - a) / n
val sum = (1 until n).map(i => f(a + i * h)).sum
h * (f(a) + 2 * sum + f(b)) / 2
}

// Интегрирование x^2 от 0 до 2 (точный результат: 8/3)
val integral = trapezoidalRule(x => x * x, 0.0, 2.0, 1000)
val exact = 8.0 / 3.0
math.abs(integral - exact) < 0.001 // true

## Вероятностные распределения

### Генерация случайных чисел

import scala.util.Random

val random = new Random(42) // фиксированное seed

// Равномерное распределение [0, 1)
val uniform = random.nextDouble()

// Нормальное распределение
val gaussian = random.nextGaussian()

// Равномерное в диапазоне [min, max)
def uniformRange(min: Double, max: Double): Double =
min + random.nextDouble() * (max - min)

// Экспоненциальное распределение
def exponential(lambda: Double): Double =
-math.log(1 - random.nextDouble()) / lambda

// Проверка свойств нормального распределения
val samples = (1 to 10000).map(_ => random.nextGaussian())
val sampleMean = samples.sum / samples.length
val sampleVariance = samples.map(x => (x - sampleMean) * (x - sampleMean)).sum / samples.length

math.abs(sampleMean) < 0.1 // должно быть близко к 0
math.abs(sampleVariance - 1.0) < 0.1 // должно быть близко к 1

---

### Полные данные JSON

<details>
<summary>Показать JSON данные</summary>

```json
{
  "name" : "text",
  "text" : "<h1 style=\"text-align:center;\">Алгебраические свойства типа Double</h1>\n\n<p>В Scala тип <code>Double</code> — это не просто числовой примитив, а одна из наиболее насыщенных с точки зрения алгебры структур. Он реализует стандарт IEEE 754 для чисел с плавающей точкой двойной точности и тем самым отражает сложное взаимодействие между абстрактной математикой и практическими ограничениями вычислительных систем.</p>\n\n<p>С точки зрения алгебры <code>Double</code> можно рассматривать как приближение к полю действительных чисел. Большинство его операций подчиняются тем же законам, что и в математике, однако конечная точность представления вносит важные отличия. Появляются особые элементы (NaN, ±∞), а также погрешности округления, которые делают некоторые привычные свойства полей лишь приближённо верными.</p>\n\n<p>Эта двойственная природа делает <code>Double</code> особенно интересным: он ведёт себя как поле, но требует внимательности при работе с равенством, ассоциативностью и дистрибутивностью. На практике это означает, что численные алгоритмы должны учитывать специфику представления, чтобы быть корректными и устойчивыми.</p>\n\n<p>Понимание алгебраических особенностей <code>Double</code> критически важно в численных вычислениях, научном программировании и финансовых приложениях. При правильном использовании он становится мощным инструментом, позволяющим соединять строгость математических моделей с ограничениями аппаратных вычислений.</p>\n\n<p>Таким образом, <code>Double</code> в Scala — это центральный тип для научных и прикладных задач, воплощающий богатство математических операций в пределах вычислительной системы и открывающий путь к построению более надёжного и предсказуемого кода.</p>\n\n<blockquote>\n<p><strong>Примечание</strong>: Данная статья является справочной, и не требует подробного изучения в данный момент. Некоторые термины и понятия могут быть неизвестными для обучающегося. Однако она содержит полезную информацию обзорного свойства для более глубокого понимания темы.</p>\n</blockquote>\n\n<h2 style=\"text-align:center;\">Полевые структуры</h2>\n\n<h3>Аддитивная группа</h3>\n\n<p>Double с операцией сложения образует коммутативную группу (за исключением специальных значений):</p>\n\n<pre><code class=\"language-scala\">// Нейтральный элемент: 0.0\nval x = 42.5\nval zero = 0.0\n\nx + zero == x  // true\nzero + x == x  // true\n\n// Обратные элементы\nval y = 3.14\nval negY = -y\ny + negY == zero  // true (с учетом точности)\nnegY + y == zero  // true\n\n// Коммутативность\nval a = 2.5\nval b = 3.7\na + b == b + a  // true\n\n// Ассоциативность (с оговорками о точности)\nval c = 1.2\n(a + b) + c == a + (b + c)  // обычно true, но могут быть расхождения\n</code></pre>\n\n<h3>Мультипликативная группа</h3>\n\n<p>Double (исключая 0.0) с операцией умножения образует коммутативную группу:</p>\n\n<pre><code class=\"language-scala\">// Нейтральный элемент: 1.0\nval x = 42.5\nval one = 1.0\n\nx * one == x  // true\none * x == x  // true\n\n// Обратные элементы (кроме нуля)\nval y = 2.5\nval invY = 1.0 / y\ny * invY == one  // true (приближенно)\ninvY * y == one  // true (приближенно)\n\n// Коммутативность\nval a = 2.5\nval b = 3.0\na * b == b * a  // true\n\n// Ассоциативность\nval c = 4.0\n(a * b) * c == a * (b * c)  // true (с учетом точности)\n</code></pre>\n\n<h3>Полевые свойства</h3>\n\n<p>Double приближается к полю действительных чисел:</p>\n\n<pre><code class=\"language-scala\">val a = 2.5\nval b = 3.0\nval c = 1.5\n\n// Дистрибутивность: a * (b + c) = a * b + a * c\nval left = a * (b + c)\nval right = a * b + a * c\nmath.abs(left - right) &lt; 1e-15  // true (с учетом точности)\n\n// Существование обратных (кроме нуля)\nval x = 7.25\nval inverse = 1.0 / x\nmath.abs(x * inverse - 1.0) &lt; 1e-15  // true\n\n// Деление как умножение на обратный\nval y = 3.5\nval z = 2.0\nmath.abs(y / z - y * (1.0 / z)) &lt; 1e-15  // true\n</code></pre>\n\n<h2 style=\"text-align:center;\">Упорядоченные структуры</h2>\n\n<h3>Тотальный порядок</h3>\n\n<p>Double образует тотально упорядоченное множество (с особенностями для NaN):</p>\n\n<pre><code class=\"language-scala\">val a = 2.5\nval b = 3.7\nval c = 1.2\n\n// Сравнения\na &lt; b   // true\nb &gt; c   // true  \na &gt; c   // true\n\n// Транзитивность\n(a &lt; b) &amp;&amp; (b &gt; c) &amp;&amp; (a &gt; c)  // true\n\n// Антисимметричность\nval x = 2.5\nval y = 2.5\n(x &lt;= y) &amp;&amp; (y &lt;= x) &amp;&amp; (x == y)  // true\n\n// Сравнение с методами\na.compareTo(b)  // отрицательное число\nb.compareTo(a)  // положительное число  \na.compareTo(a)  // 0\n</code></pre>\n\n<h3>Минимум и максимум</h3>\n\n<pre><code class=\"language-scala\">val values = Array(3.14, 2.71, 1.41, 4.67)\n\n// Встроенные функции min/max\nval minimum = values.min  // 1.41\nval maximum = values.max  // 4.67\n\n// Math функции\nval a = 2.5\nval b = 3.7\nmath.min(a, b)  // 2.5\nmath.max(a, b)  // 3.7\n\n// Решеточные свойства (идемпотентность)\nmath.min(a, a) == a  // true\nmath.max(a, a) == a  // true\n\n// Коммутативность\nmath.min(a, b) == math.min(b, a)  // true\nmath.max(a, b) == math.max(b, a)  // true\n</code></pre>\n\n<h2 style=\"text-align:center;\">Специальные значения IEEE 754</h2>\n\n<h3>Положительная и отрицательная бесконечность</h3>\n\n<pre><code class=\"language-scala\">val posInf = Double.PositiveInfinity\nval negInf = Double.NegativeInfinity\nval finite = 42.5\n\n// Арифметика с бесконечностями\nfinite + posInf == posInf  // true\nfinite * posInf == posInf  // true (для положительных finite)\nposInf + posInf == posInf  // true\nposInf * posInf == posInf  // true\n\n// Деление на ноль\nfinite / 0.0 == posInf     // true (для положительных)\n(-finite) / 0.0 == negInf  // true\n\n// Сравнения с бесконечностями\nfinite &lt; posInf  // true\nfinite &gt; negInf  // true\nnegInf &lt; finite  // true\nposInf &gt; finite  // true\n</code></pre>\n\n<h3>NaN (Not a Number)</h3>\n\n<pre><code class=\"language-scala\">val nan = Double.NaN\nval finite = 42.5\n\n// Особые свойства NaN\nnan == nan        // false! (уникальное свойство)\nnan != nan        // true\nnan.equals(nan)   // true (в Scala)\n\n// NaN в арифметических операциях\nfinite + nan      // NaN\nfinite * nan      // NaN  \nnan + nan         // NaN\n\n// NaN в сравнениях\nnan &lt; finite      // false\nnan &gt; finite      // false\nnan == finite     // false\n\n// Проверка на NaN\nnan.isNaN         // true\nfinite.isNaN      // false\n</code></pre>\n\n<h3>Проверки специальных значений</h3>\n\n<pre><code class=\"language-scala\">val values = Array(42.5, Double.PositiveInfinity, Double.NaN, -17.3)\n\n// Классификация значений\nvalues.map(_.isFinite)     // Array(true, false, false, true)\nvalues.map(_.isInfinite)   // Array(false, true, false, false)  \nvalues.map(_.isNaN)        // Array(false, false, true, false)\n\n// Проверка знака\nval positive = 3.14\nval negative = -2.71\nval zero = 0.0\n\npositive.sign  // 1.0\nnegative.sign  // -1.0\nzero.sign      // 0.0\n\n// Проверка знака нуля\nval negativeZero = -0.0\nnegativeZero == zero     // true\n1.0 / zero == Double.PositiveInfinity   // true\n1.0 / negativeZero == Double.NegativeInfinity  // true\n</code></pre>\n\n<h2 style=\"text-align:center;\">Математические функции</h2>\n\n<h3>Элементарные функции</h3>\n\n<pre><code class=\"language-scala\">val x = 2.0\nval y = 3.0\n\n// Степенные функции\nmath.pow(x, y)    // 8.0 (2^3)\nmath.sqrt(x)      // 1.4142135623730951\nmath.cbrt(27.0)   // 3.0 (кубический корень)\n\n// Экспоненциальные функции  \nmath.exp(1.0)     // 2.718281828459045 (e)\nmath.exp2(3.0)    // 8.0 (2^3)\nmath.expm1(0.1)   // более точное вычисление exp(x) - 1\n\n// Логарифмические функции\nmath.log(math.E)   // 1.0 (натуральный логарифм)\nmath.log10(100.0)  // 2.0 (десятичный логарифм)\nmath.log1p(0.1)    // более точное вычисление log(1 + x)\n</code></pre>\n\n<h3>Тригонометрические функции</h3>\n\n<pre><code class=\"language-scala\">val angle = math.Pi / 4  // 45 градусов\n\n// Основные тригонометрические функции\nmath.sin(angle)      // 0.7071067811865476 (√2/2)\nmath.cos(angle)      // 0.7071067811865476 (√2/2)  \nmath.tan(angle)      // 1.0\n\n// Обратные тригонометрические функции\nmath.asin(0.5)       // π/6\nmath.acos(0.5)       // π/3\nmath.atan(1.0)       // π/4\n\n// Гиперболические функции\nmath.sinh(1.0)       // 1.1752011936438014\nmath.cosh(1.0)       // 1.5430806348152437\nmath.tanh(1.0)       // 0.7615941559557649\n\n// Тригонометрические тождества\nval x = 0.7\nval sinSquared = math.pow(math.sin(x), 2)\nval cosSquared = math.pow(math.cos(x), 2)\nmath.abs(sinSquared + cosSquared - 1.0) &lt; 1e-15  // true\n</code></pre>\n\n<h3>Функции округления</h3>\n\n<pre><code class=\"language-scala\">val x = 3.14159\nval y = -2.71828\n\n// Различные виды округления\nmath.floor(x)    // 3.0 (округление вниз)\nmath.ceil(x)     // 4.0 (округление вверх)  \nmath.round(x)    // 3 (Int) (округление к ближайшему)\nmath.rint(x)     // 3.0 (округление к ближайшему четному)\n\n// Округление отрицательных чисел\nmath.floor(y)    // -3.0\nmath.ceil(y)     // -2.0\nmath.round(y)    // -3\n\n// Извлечение частей\nval value = 123.456\nval intPart = math.floor(math.abs(value)) * math.signum(value)  // 123.0\nval fracPart = value - intPart  // 0.456\n</code></pre>\n\n<h2 style=\"text-align:center;\">Точность и ошибки вычислений</h2>\n\n<h3>Проблемы точности</h3>\n\n<pre><code class=\"language-scala\">// Классические проблемы с плавающей точкой\nval a = 0.1\nval b = 0.2\nval sum = a + b\nsum == 0.3  // false! (0.30000000000000004)\n\n// Безопасные сравнения\ndef almostEqual(x: Double, y: Double, epsilon: Double = 1e-15): Boolean =\n  math.abs(x - y) &lt; epsilon\n\nalmostEqual(sum, 0.3)  // true\n\n// Накопление ошибок\nval iterations = 1000000\nval increment = 1.0 / iterations  \nval accumulated = (1 to iterations).foldLeft(0.0)(_ + increment)\nalmostEqual(accumulated, 1.0, 1e-10)  // может быть false из-за накопления ошибок\n</code></pre>\n\n<h3>Машинная точность</h3>\n\n<pre><code class=\"language-scala\">// Машинный эпсилон\nval machineEpsilon = {\n  var eps = 1.0\n  while (1.0 + eps &gt; 1.0) {\n    eps /= 2.0\n  }\n  eps * 2.0\n}\n\n// Относительные ошибки\ndef relativeError(computed: Double, expected: Double): Double =\n  if (expected != 0.0) math.abs((computed - expected) / expected) else Double.PositiveInfinity\n\nval computed = math.sin(math.Pi)  // должно быть 0, но получаем ~1.2e-16\nval expected = 0.0\nrelativeError(computed, expected)  // Infinity (деление на ноль)\nmath.abs(computed) &lt; 1e-15  // true (абсолютная ошибка мала)\n</code></pre>\n\n<h2 style=\"text-align:center;\">Числовые представления</h2>\n\n<h3>Битовое представление</h3>\n\n<pre><code class=\"language-scala\">val x = 3.14159\n\n// Преобразование в Long (битовое представление)\nval bits = java.lang.Double.doubleToLongBits(x)\nval restored = java.lang.Double.longBitsToDouble(bits)\nrestored == x  // true\n\n// Сырые биты (учитывает NaN)\nval rawBits = java.lang.Double.doubleToRawLongBits(x)\n\n// Анализ структуры IEEE 754\nval signBit = (bits &gt;&gt;&gt; 63) &amp; 1\nval exponentBits = (bits &gt;&gt;&gt; 52) &amp; 0x7FF  \nval mantissaBits = bits &amp; 0xFFFFFFFFFFFFL\n\n// Специальные значения в битах\nval nanBits = java.lang.Double.doubleToLongBits(Double.NaN)\nval posInfBits = java.lang.Double.doubleToLongBits(Double.PositiveInfinity)\nval negInfBits = java.lang.Double.doubleToLongBits(Double.NegativeInfinity)\n</code></pre>\n\n<h3>Пределы и диапазоны</h3>\n\n<pre><code class=\"language-scala\">// Границы представления\nval maxValue = Double.MaxValue     // 1.7976931348623157E308\nval minValue = Double.MinValue     // 4.9E-324 (наименьшее положительное)\nval minNormal = Double.MinPositiveValue\n\n// Проверки диапазонов\nval huge = 1e300\nval tiny = 1e-300\n\nhuge &lt; Double.MaxValue    // true\ntiny &gt; Double.MinPositiveValue  // true\n\n// Переполнения\nval overflow = Double.MaxValue * 2  // Infinity\nval underflow = Double.MinPositiveValue / 2  // 0.0\n</code></pre>\n\n<h2 style=\"text-align:center;\">Преобразования типов</h2>\n\n<h3>Числовые преобразования</h3>\n\n<pre><code class=\"language-scala\">val d = 42.75\n\n// Преобразования в целые типы\nd.toInt      // 42 (обрезание дробной части)\nd.toLong     // 42L\nd.toShort    // 42\nd.toByte     // 42\n\n// Преобразования в другие типы с плавающей точкой\nd.toFloat    // 42.75f\n\n// Безопасные преобразования с проверкой диапазона\ndef safeToInt(d: Double): Option[Int] =\n  if (d.isValidInt) Some(d.toInt) else None\n\nsafeToInt(42.75)         // Some(42)\nsafeToInt(1e10)          // None (выходит за границы Int)\nsafeToInt(Double.NaN)    // None\n</code></pre>\n\n<h3>Строковые представления</h3>\n\n<pre><code class=\"language-scala\">val pi = math.Pi\nval large = 1.23e15\nval small = 1.23e-15\n\n// Различные форматы строк\npi.toString              // \"3.141592653589793\"\nlarge.toString           // \"1.23E15\"\nsmall.toString           // \"1.23E-15\"\n\n// Форматированный вывод\nf\"$pi%.2f\"              // \"3.14\"\nf\"$pi%.6f\"              // \"3.141593\"  \nf\"$large%.2e\"           // \"1.23e+15\"\nf\"$small%.2e\"           // \"1.23e-15\"\n\n// Парсинг из строк\n\"3.14159\".toDouble      // 3.14159\n\"1.23e-15\".toDouble     // 1.23E-15\n\"Infinity\".toDouble     // Infinity\n\"NaN\".toDouble          // NaN\n\n// Безопасный парсинг\n\"3.14\".toDoubleOption   // Some(3.14)\n\"not a number\".toDoubleOption  // None\n</code></pre>\n\n<h2 style=\"text-align:center;\">Статистические и агрегационные операции</h2>\n\n<h3>Базовые агрегации</h3>\n\n<pre><code class=\"language-scala\">val data = Array(1.5, 2.7, 3.1, 4.9, 2.3, 6.8, 1.2)\n\n// Основные статистики\nval sum = data.sum                    // 22.5\nval count = data.length               // 7\nval mean = sum / count                // 3.214...\n\nval minimum = data.min                // 1.2\nval maximum = data.max                // 6.8\nval range = maximum - minimum         // 5.6\n\n// Сортировка для медианы\nval sorted = data.sorted\nval median = if (sorted.length % 2 == 1) {\n  sorted(sorted.length / 2)\n} else {\n  (sorted(sorted.length / 2 - 1) + sorted(sorted.length / 2)) / 2\n}\n</code></pre>\n\n<h3>Дисперсия и стандартное отклонение</h3>\n\n<pre><code class=\"language-scala\">val values = Array(2.0, 4.0, 4.0, 4.0, 5.0, 5.0, 7.0, 9.0)\n\nval mean = values.sum / values.length\n\n// Дисперсия (несмещенная)\nval variance = values.map(x =&gt; math.pow(x - mean, 2)).sum / (values.length - 1)\n\n// Стандартное отклонение  \nval stdDev = math.sqrt(variance)\n\n// Коэффициент вариации\nval coefficientOfVariation = stdDev / mean\n\n// Z-оценки (стандартизация)\nval zScores = values.map(x =&gt; (x - mean) / stdDev)\n</code></pre>\n\n<h2 style=\"text-align:center;\">Численные методы</h2>\n\n<h3>Приближенные вычисления</h3>\n\n<pre><code class=\"language-scala\">// Метод Ньютона для квадратного корня\ndef newtonSqrt(x: Double, guess: Double = 1.0, iterations: Int = 10): Double = {\n  if (iterations == 0) guess\n  else {\n    val newGuess = (guess + x / guess) / 2\n    newtonSqrt(x, newGuess, iterations - 1)\n  }\n}\n\nval approximateSqrt = newtonSqrt(25.0)  // приближенно 5.0\nval exactSqrt = math.sqrt(25.0)\nmath.abs(approximateSqrt - exactSqrt) &lt; 1e-15  // true\n\n// Вычисление π методом Лейбница\ndef leibnizPi(terms: Int): Double = {\n  (0 until terms).map { n =&gt;\n    val sign = if (n % 2 == 0) 1.0 else -1.0\n    sign / (2 * n + 1)\n  }.sum * 4\n}\n\nval approximatePi = leibnizPi(100000)\nmath.abs(approximatePi - math.Pi) &lt; 0.01  // true (медленная сходимость)\n</code></pre>\n\n<h3>Интегрирование</h3>\n\n<pre><code class=\"language-scala\">// Правило трапеций для численного интегрирования\ndef trapezoidalRule(f: Double =&gt; Double, a: Double, b: Double, n: Int): Double = {\n  val h = (b - a) / n\n  val sum = (1 until n).map(i =&gt; f(a + i * h)).sum\n  h * (f(a) + 2 * sum + f(b)) / 2\n}\n\n// Интегрирование x^2 от 0 до 2 (точный результат: 8/3)\nval integral = trapezoidalRule(x =&gt; x * x, 0.0, 2.0, 1000)\nval exact = 8.0 / 3.0\nmath.abs(integral - exact) &lt; 0.001  // true\n</code></pre>\n\n<h2 style=\"text-align:center;\">Вероятностные распределения</h2>\n\n<h3>Генерация случайных чисел</h3>\n\n<pre><code class=\"language-scala\">import scala.util.Random\n\nval random = new Random(42)  // фиксированное seed\n\n// Равномерное распределение [0, 1)\nval uniform = random.nextDouble()\n\n// Нормальное распределение\nval gaussian = random.nextGaussian()\n\n// Равномерное в диапазоне [min, max)\ndef uniformRange(min: Double, max: Double): Double = \n  min + random.nextDouble() * (max - min)\n\n// Экспоненциальное распределение\ndef exponential(lambda: Double): Double = \n  -math.log(1 - random.nextDouble()) / lambda\n\n// Проверка свойств нормального распределения\nval samples = (1 to 10000).map(_ =&gt; random.nextGaussian())\nval sampleMean = samples.sum / samples.length\nval sampleVariance = samples.map(x =&gt; (x - sampleMean) * (x - sampleMean)).sum / samples.length\n\nmath.abs(sampleMean) &lt; 0.1      // должно быть близко к 0\nmath.abs(sampleVariance - 1.0) &lt; 0.1  // должно быть близко к 1\n</code></pre>",
  "video" : null,
  "options" : {
    
  },
  "subtitle_files" : [
  ],
  "is_deprecated" : false
}
```

</details>
