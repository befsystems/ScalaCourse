{
  "step_id" : 9206849,
  "lesson_id" : 1230060,
  "position" : 1,
  "type" : "unknown",
  "block" : {
    "name" : "text",
    "text" : "<h1 style=\"text-align:center;\">Идея типа данных Double</h1>\n\n<p>В 1985 году инженер Уильям Кахан получил премию Тьюринга за разработку стандарта IEEE 754. Этот документ определил, как компьютеры всего мира должны работать с дробными числами. В центре этой революции оказался тип данных, который мы сегодня знаем как Double. Но история началась гораздо раньше.</p>\n\n<h2 style=\"text-align:center;\">Проблема, которая стоила миллионы</h2>\n\n<p>В 1991 году американская ракета Patriot не смогла перехватить иракскую ракету Scud. Погибли 28 солдат. Причина? Ошибка округления в вычислениях времени. Система работала непрерывно 100 часов, и крошечная неточность в представлении десятичной дроби 0.1 в двоичной системе накопилась до критического значения. Ракета промахнулась на полкилометра.</p>\n\n<p>Это не первая и не последняя трагедия, связанная с точностью вычислений. В 1996 году европейская ракета Ariane 5 взорвалась через 37 секунд после старта из-за переполнения переменной при конвертации 64-битного числа в 16-битное. Ущерб составил 370 миллионов долларов.</p>\n\n<h2 style=\"text-align:center;\">Рождение проблемы</h2>\n\n<p>Когда в 1940-х годах появились первые электронные компьютеры, инженеры столкнулись с фундаментальной проблемой: как хранить в памяти числа с дробной частью? ENIAC, один из первых компьютеров, использовал десятичную систему и работал с фиксированной точкой. Каждая цифра требовала 10 вакуумных ламп. Это было расточительно и ненадёжно.</p>\n\n<p>Прорыв случился, когда математики предложили использовать плавающую точку — аналог научной нотации. Число 123.45 можно записать как 1.2345 × 10². В двоичной системе это выглядит как мантисса, умноженная на два в степени экспоненты.</p>\n\n<h2 style=\"text-align:center;\">Анархия стандартов</h2>\n\n<p>К 1970-м годам каждый производитель компьютеров изобрёл свой формат плавающей точки. IBM использовала один стандарт, DEC — другой, Cray — третий. Программа, написанная для одной машины, давала другие результаты на другой. Инженеры тратили месяцы на отладку кода, который работал на одном компьютере и падал на другом.</p>\n\n<p>Особенно страдали научные расчёты. Математик мог получить принципиально разные результаты моделирования в зависимости от компьютера. Это превратилось в кризис доверия к вычислительной технике.</p>\n\n<h2 style=\"text-align:center;\">Рыцарь плавающей точки</h2>\n\n<p>Уильям Кахан, профессор из Беркли, взялся за решение проблемы. Он был известен своей одержимостью точностью вычислений и резкими высказываниями в адрес небрежных программистов. Кахан разработал алгоритмы компенсации ошибок округления и доказал математические свойства, которым должна удовлетворять любая система плавающей точки.</p>\n\n<p>В 1980 году Intel начала работу над математическим сопроцессором 8087. Компания пригласила Кахана как консультанта. Он настоял на строгих требованиях к точности, предсказуемости и обработке особых случаев. Этот чип стал первой реализацией будущего стандарта.</p>\n\n<h2 style=\"text-align:center;\">Рождение Double</h2>\n\n<p>Стандарт IEEE 754, принятый в 1985 году, определил два основных формата: Single (32 бита) и Double (64 бита). Double получил своё название как \"двойная точность\" по сравнению с Single.</p>\n\n<p>Структура Double элегантна: один бит для знака, 11 бит для экспоненты и 52 бита для мантиссы (плюс один неявный бит). Это даёт около 15-17 десятичных знаков точности и диапазон от 10⁻³⁰⁸ до 10³⁰⁸.</p>\n\n<p>Но главная инновация была не в точности, а в специальных значениях. Стандарт ввёл понятия положительной и отрицательной бесконечности, NaN (Not a Number) для недопустимых операций и различал положительный и отрицательный ноль.</p>\n\n<h2 style=\"text-align:center;\">Тонкости, которые спасают жизни</h2>\n\n<p>Почему нужен отрицательный ноль? Представьте вычисление температуры, которая стремится к нулю с отрицательной стороны. Сохранение знака позволяет правильно обработать последующие операции. Функция 1/x даст отрицательную бесконечность для отрицательного нуля и положительную для положительного.</p>\n\n<p>NaN тоже имеет нюансы. Стандарт различает \"тихие\" и \"сигнализирующие\" NaN. Первые распространяются по цепочке вычислений, вторые вызывают исключение. Это позволяет программисту выбрать стратегию обработки ошибок.</p>\n\n<h2 style=\"text-align:center;\">Ловушки для программистов</h2>\n\n<p>Double кажется простым, но полон подводных камней. Классический пример: 0.1 + 0.2 не равно 0.3 в арифметике Double. Это не баг, а следствие того, что 0.1 невозможно точно представить в двоичной системе, как 1/3 невозможно точно записать в десятичной.</p>\n\n<p>Другая ловушка: потеря значимости при вычитании близких чисел. Выражение (x + y) - x может не равняться y, если x намного больше y. Биты y просто исчезают при округлении.</p>\n\n<p>Третья опасность: денормализованные числа. Когда экспонента достигает минимума, Double переключается в режим пониженной точности, теряя ведущие биты мантиссы. Это может замедлить вычисления в тысячи раз.</p>\n\n<h2 style=\"text-align:center;\">Победа стандарта</h2>\n\n<p>К 1990-м годам IEEE 754 победил. Все процессоры — Intel, AMD, ARM, IBM Power — реализовали этот стандарт в кремнии. Языки программирования приняли его: double в C/C++/Java, float64 в Go, Number в JavaScript.</p>\n\n<p>Победа была настолько полной, что программисты забыли о существовании альтернатив. Double стал невидимым фундаментом цифрового мира. Каждая финансовая транзакция, каждый GPS-навигатор, каждая компьютерная игра зависит от этого 64-битного формата.</p>\n\n<h2 style=\"text-align:center;\">Цена успеха</h2>\n\n<p>Но стандарт не идеален. Финансовые расчёты страдают от ошибок округления. Банки используют специальные библиотеки десятичной арифметики, потому что Double не может точно представить 0.01 доллара. Накопленные ошибки в процентах могут стоить миллионы.</p>\n\n<p>В научных вычислениях проблема ещё острее. Моделирование климата требует миллиардов операций, и ошибки округления накапливаются. Некоторые задачи требуют квадратной точности — 128 бит.</p>\n\n<h2 style=\"text-align:center;\">Эволюция продолжается</h2>\n\n<p>IEEE 754-2008 добавил новые форматы: binary16 (половинная точность для машинного обучения) и binary128 (квадратная точность для научных расчётов). Но Double остаётся стандартом де-факто.</p>\n\n<p>Появились альтернативные подходы. Google разработал bfloat16 — урезанную версию Single для нейросетей. Posit — новый формат, предложенный в 2017 году, обещает лучшую точность и динамический диапазон при том же количестве бит.</p>\n\n<h2 style=\"text-align:center;\">Квантовая угроза</h2>\n\n<p>Квантовые компьютеры ставят под вопрос будущее Double. Квантовые вычисления оперируют амплитудами вероятностей — непрерывными величинами. Представление их в формате Double может быть недостаточно точным. Уже разрабатываются новые стандарты для квантовой эры.</p>\n\n<h2 style=\"text-align:center;\">Наследие</h2>\n\n<p>История Double — это история компромиссов между скоростью, точностью и универсальностью. Это история о том, как математическая абстракция стала физической реальностью в кремнии. И это напоминание, что за каждым числом в компьютере стоит сложная инженерия и десятилетия эволюции.</p>\n\n<p>Когда вы видите double в коде, помните: это не просто тип данных. Это результат битвы за стандарты, трагедий из-за ошибок округления, гениальности Кахана и компромиссов между идеальной математикой и несовершенным железом. В этих 64 битах заключена история вычислительной техники.</p>",
    "video" : null,
    "options" : {
      
    },
    "subtitle_files" : [
    ],
    "is_deprecated" : false
  },
  "name" : "text",
  "course_id" : 195883,
  "course_name" : "Функциональная Scala 3 для начинающих",
  "exported_at" : "2026-01-10T10:17:05.6015955"
}