{
  "step_id" : 5740323,
  "lesson_id" : 1246744,
  "position" : 2,
  "type" : "unknown",
  "block" : {
    "name" : "text",
    "text" : "<h1 style=\"text-align:center;\"><strong>Все конструкции языка - выражения</strong></h1>\n\n<p>В Scala <strong>любая конструкция языка является выражением</strong>. Это значит, что её можно использовать <strong>в любом месте кода</strong>, где допустимо выражение, <strong>составлять блоки</strong>, <strong>быть вложенными</strong>, <strong>соединяться</strong> <strong>между собой</strong> с помощью доступных операций.</p>\n\n<p>Такой подход даёт <strong>огромную гибкость</strong>: не нужно создавать отдельные правила для различных конструкций, а код становится более выразительным и компактным.</p>\n\n<h3 style=\"text-align:center;\">Свойства выражений</h3>\n\n<ul>\n\t<li>Выражение <strong>вычисляется в значение</strong>.</li>\n\t<li>Это значение всегда <strong>имеет определённый тип</strong>.</li>\n</ul>\n\n<p>Иными словами, любую конструкцию языка можно рассматривать как выражение, даже если на первый взгляд она совсем не похожа на вычисление.&nbsp;Можно доказать, что все конструкции - это выражения, получив их значение.</p>\n\n<p>Примеры:</p>\n\n<pre><code class=\"language-scala\">al res1: Int     = 1 + 2 + 3          // 1 + 2 + 3 - выражение, значение 6, тип Int\nval res2: String  = \"Hello\" * 2        // \"Hello\" * 2 - выражение, значение \"HelloHello\", тип String\nval res3: Boolean = 2 &gt; 3 + 1          // 2 &gt; 3 + 1 - выражение, значение false, тип Boolean\nval res4: Int     = if 2 &gt; 1 then 1 else 0 // if ... then ... else ... - выражение, значение 1, тип Int\nval res5: Unit    = {}                  // {} - пустой блок, значение () типа Unit\nval res6: Unit    = { val a = 1 }       // определение переменной - выражение, значение () типа Unit\nval res7: Unit    = { def getNum = 1 }  // определение функции - выражение, значение () типа Unit\nval res8: Unit    = { import scala.math.* } // import - выражение, значение () типа Unit\nval res9: Unit    = if 1 &gt; 2 then 8     // неполное условие без else - выражение, значение () типа Unit\n\n</code></pre>\n\n<p>Обратите внимание, те конструкции, которые не в состоянии что-то вычислять, возвращают как результат значение () типа Unit. Это вполне реальное значение, и может влиять на значение итогового выражения.</p>\n\n<p>Пример, несколько экзотический:</p>\n\n<pre><code class=\"language-scala\">val res = { def getNum = 1 }.toString // значением будет строка \"()\"\n</code></pre>\n\n<p>Приведение всех конструкций к выражениям даёт большие возможности для <strong>комбинирования и вложения</strong>, но одновременно открывает путь к <strong>логически некорректным конструкциям</strong>.<br>\nКомпилятор воспринимает любое выражение как намеренное, поэтому даже неверная логика будет вычислена, а результат может быть неожиданным.</p>",
    "video" : null,
    "options" : {
      
    },
    "subtitle_files" : [
    ],
    "is_deprecated" : false
  },
  "name" : "text",
  "course_id" : 195883,
  "course_name" : "Функциональная Scala 3 для начинающих",
  "exported_at" : "2025-12-20T22:21:01.1145466"
}