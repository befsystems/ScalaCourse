{
  "step_id" : 7997039,
  "lesson_id" : 1228710,
  "position" : 1,
  "type" : "unknown",
  "block" : {
    "name" : "text",
    "text" : "<h1 style=\"text-align:center;\">Сопоставления с образцом</h1>\n\n<p><strong>Pattern matching</strong> (сопоставление с образцом) — это мощная конструкция в Scala, которая позволяет сопоставлять значения с определенными шаблонами (образцами) и выполнять соответствующие действия. Мы рассмотрим основы pattern matching на примере примитивных типов данных, хотя эта конструкция способна работать и с гораздо более сложными структурами данных. </p>\n\n<p><strong>Синтаксис:</strong></p>\n\n<pre><code class=\"language-scala\">значение match\n  case шаблон1 =&gt; выражение1  // альтернатива 1\n  case шаблон2 =&gt; выражение2  // альтернатива 2\n  case _ =&gt; выражениеПоУмолчанию // альтернатива по умолчанию\n</code></pre>\n\n<p><strong>Альтернатива</strong> — это основной элемент конструкции pattern matching, который состоит из двух частей:</p>\n\n<ol>\n\t<li><strong>Шаблон</strong> (pattern) — образец, с которым сопоставляется значение</li>\n\t<li><strong>Выражение</strong> — код, который выполняется при совпадении шаблона</li>\n</ol>\n\n<p>Каждая строка <code>case шаблон =&gt; выражение</code> представляет собой одну альтернативу. Конструкция match проверяет альтернативы последовательно <strong>сверху вниз</strong>, и как только находится <strong>подходящий шаблон</strong> под значение, вычисляется соответствующее выражение. Дальнейшие проверки альтернатив не выполняются. </p>\n\n<p>Если <strong>ни один шаблон</strong> не совпал со значением, то конструкция выдаст <strong>исключительное значение</strong> и программа может прервать свое выполнение, этого следует избегать.</p>\n\n<p>Конструкция <code>match</code> сама является <strong>выражением</strong>, то есть она вычисляет и возвращает значение. Значением конструкции <code>match</code> становится значение выражения той альтернативы, шаблон которой совпал с проверяемым значением. Выполняется только <strong>одна</strong> альтернатива.</p>\n\n<p>В Scala 3 фигурные скобки вокруг блока <code>match</code> стали необязательными благодаря значимым отступам.</p>\n\n<p><strong>Пример:</strong></p>\n\n<pre><code class=\"language-scala\">val number = 42\n// match - это выражение, поэтому его результат можно присвоить значению result\nval result = number match\n  case 0 =&gt; \"ноль\"                                    // Альтернатива 1\n  case 42 =&gt; \"ответ на главный вопрос жизни\"          // Альтернатива 2  \n  case n if n &gt; 0 =&gt; s\"положительное число: $n\"      // Альтернатива 3\n  case _ =&gt; \"отрицательное число\"                     // Альтернатива 4 (по умолчанию)\n\nresult // = \"ответ на главный вопрос жизни\"\n</code></pre>\n\n<p>В данном примере будет выбрана <strong>альтернатива 2</strong>, так как значение <code>42</code> точно совпадает с шаблоном во второй альтернативе. Остальные альтернативы проверяться не будут.</p>\n\n<h2 style=\"text-align:center;\">Сравнение с if-else</h2>\n\n<p>Pattern matching можно рассматривать как более мощную и выразительную альтернативу конструкции <code>if-else if-else</code>. В то время как <code>if-else</code> проверяет логические условия, <code>match</code> позволяет сопоставлять структуру и тип данных, обеспечивая большую гибкость и безопасность типов.</p>\n\n<p>Для лучшего понимания сравним эквивалентный код с использованием <code>if-else</code>:</p>\n\n<pre><code class=\"language-scala\">// Используя if-else (менее выразительно)\nval number = 42\nval result = if (number == 0) {\n  \"ноль\"\n} else if (number == 42) {\n  \"ответ на главный вопрос жизни\"\n} else if (number &gt; 0) {\n  s\"положительное число: $number\"\n} else {\n  \"отрицательное число\"\n}\n\n// Используя pattern matching (более выразительно и безопасно)\nval result2 = number match\n  case 0 =&gt; \"ноль\"\n  case 42 =&gt; \"ответ на главный вопрос жизни\"\n  case n if n &gt; 0 =&gt; s\"положительное число: $n\"\n  case _ =&gt; \"отрицательное число\"\n</code></pre>\n\n<p>Pattern matching предоставляет несколько преимуществ:</p>\n\n<ul>\n\t<li><strong>Более читаемый код</strong> - логика выражена более декларативно</li>\n\t<li><strong>Проверка исчерпывающности</strong> - компилятор предупредит, если не все случаи покрыты</li>\n\t<li><strong>Безопасность типов</strong> - автоматическое приведение типов в альтернативах</li>\n\t<li><strong>Мощные шаблоны</strong> - возможность сопоставления сложных структур данных</li>\n</ul>\n\n<h2 style=\"text-align:center;\">Альтернативы с блоками выражений</h2>\n\n<p>Выражение в альтернативе может быть блоком, и значением такого блока станет последнее выражение в нем:</p>\n\n<pre><code class=\"language-scala\">val number = 42\nval result = number match\n  case 0 =&gt;                              // Альтернатива 1 с блоком выражений\n    val message = \"Получен ноль\"\n    val status = \"special\"\n    s\"$message ($status)\"                // Это значение вернется из альтернативы\n  case n if n &gt; 0 =&gt;                     // Альтернатива 2 с блоком выражений\n    val doubled = n * 2\n    val category = \"положительное\"\n    s\"$category число $n, удвоенное: $doubled\"  // Это значение вернется из альтернативы\n  case _ =&gt;                              // Альтернатива 3 с блоком выражений\n    val category = \"отрицательное\"\n    val advice = \"проверьте входные данные\"\n    s\"$category число, $advice\"          // Это значение вернется из альтернативы\n\nresult // = \"положительное число 42, удвоенное: 84\"\n\n</code></pre>\n\n<h2 style=\"text-align:center;\">Совместимость типов альтернатив</h2>\n\n<p>Поскольку <code>match</code> является выражением, все альтернативы должны возвращать значения <strong>совместимых</strong> типов:</p>\n\n<pre><code class=\"language-scala\">// Пример с одинаковыми типами:\nval betterResult: String = x match\n  case 1 =&gt; \"один\"\n  case 2 =&gt; \"два\"  \n  case 3 =&gt; \"три\"\n  case n =&gt; s\"число $n\"       // Все альтернативы возвращают String\n\n// Пример с совместимыми числовыми типами:\nval numericResult: Double = x match\n  case 1 =&gt; 1.0               // Double\n  case 2 =&gt; 2                 // Int (автоматически приводится к Double)\n  case 3 =&gt; 3.0f              // Float (автоматически приводится к Double)\n  case _ =&gt; 0.0               // Double\n// Общий тип - Double\n\n// Компилятор может вывести тип автоматически:\nval autoType = x match\n  case 1 =&gt; true              // Boolean\n  case _ =&gt; false             // Boolean\n// autoType будет иметь тип Boolean\n\n// Пример с несовместимыми типами (похоже на ошибку):\nval result = x match\n  case 1 =&gt; \"строка\"           // String\n  case 2 =&gt; 42                 // Int  \n  case 3 =&gt; true               // Boolean\n  case _ =&gt; 3.14               // Double\n// Компилятор найдет общий базовый тип - Any, но это скорее не то, что вам нужно!\n\n</code></pre>\n\n<h2 style=\"text-align:center;\">Порядок сопоставления альтернатив</h2>\n\n<p>Сопоставление происходит сверху вниз. Первая подходящая альтернатива определяет результат, остальные альтернативы не проверяются:</p>\n\n<pre><code class=\"language-scala\">val x = 0\nval result = x match\n  case n if n &gt;= 0 =&gt; \"Неотрицательное\"  // Альтернатива 1 - сработает для x = 0\n  case 0 =&gt; \"Ноль\"                       // Альтернатива 2 - недостижимый код!\n  case _ =&gt; \"Другое\"                     // Альтернатива 3 - по умолчанию\n\n// Компилятор Scala выдаст предупреждение о наличии недостижимой альтернативы\n</code></pre>\n\n<h2 style=\"text-align:center;\">Исчерпывающность альтернатив</h2>\n\n<p>Компилятор проверяет, что все возможные случаи покрыты альтернативами:</p>\n\n<pre><code class=\"language-scala\">val flag = true\nval result = flag match\n  case true =&gt; \"Истина\"  // Альтернатива 1\n  // Компилятор предупредит о неполном покрытии альтернатив\n  // Нужно добавить альтернативу: case false =&gt; \"Ложь\"\n</code></pre>\n\n<h2 style=\"text-align:center;\">Альтернатива по умолчанию</h2>\n\n<p>Шаблон <code>_</code> (подчеркивание) соответствует любому значению и обычно используется как альтернатива по умолчанию:</p>\n\n<pre><code class=\"language-scala\">val grade = 'Z'\nval description = grade match\n  case 'A' =&gt; \"Отлично\"\n  case 'B' =&gt; \"Хорошо\"\n  case 'C' =&gt; \"Удовлетворительно\"\n  case _ =&gt; \"Неизвестная оценка\"  // Покрывает все остальные случаи\n\ndescription // = \"Неизвестная оценка\"\n</code></pre>\n\n<p> </p>\n\n<h2><strong>Ключевые моменты для запоминания:</strong></h2>\n\n<ul>\n\t<li><code>match</code> — это выражение, которое возвращает значение</li>\n\t<li>Альтернативы проверяются последовательно сверху вниз</li>\n\t<li>Только одна альтернатива выполняется</li>\n\t<li>Все альтернативы должны возвращать совместимые типы</li>\n\t<li>Компилятор проверяет исчерпывающность покрытия случаев</li>\n</ul>",
    "video" : null,
    "options" : {
      
    },
    "subtitle_files" : [
    ],
    "is_deprecated" : false
  },
  "name" : "text",
  "course_id" : 195883,
  "course_name" : "Функциональная Scala 3 для начинающих",
  "exported_at" : "2025-12-20T22:21:08.3793946"
}