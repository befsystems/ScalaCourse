# Материал (Шаг 2)

## Информация о шаге

- **ID шага**: 7997039
- **Позиция**: 2
- **Тип**: text
- **Курс**: Функциональная Scala 3 для начинающих
- **Экспортирован**: 2026-01-10T10:17:08.6033213

## Содержание

# Сопоставления с образцом

**Pattern matching** (сопоставление с образцом) — это мощная конструкция в Scala, которая позволяет сопоставлять значения с определенными шаблонами (образцами) и выполнять соответствующие действия. Мы рассмотрим основы pattern matching на примере примитивных типов данных, хотя эта конструкция способна работать и с гораздо более сложными структурами данных. 

**Синтаксис:**

значение match
case шаблон1 => выражение1 // альтернатива 1
case шаблон2 => выражение2 // альтернатива 2
case _ => выражениеПоУмолчанию // альтернатива по умолчанию

**Альтернатива** — это основной элемент конструкции pattern matching, который состоит из двух частей:

- **Шаблон** (pattern) — образец, с которым сопоставляется значение

- **Выражение** — код, который выполняется при совпадении шаблона

Каждая строка `case шаблон => выражение` представляет собой одну альтернативу. Конструкция match проверяет альтернативы последовательно **сверху вниз**, и как только находится **подходящий шаблон** под значение, вычисляется соответствующее выражение. Дальнейшие проверки альтернатив не выполняются. 

Если **ни один шаблон** не совпал со значением, то конструкция выдаст **исключительное значение** и программа может прервать свое выполнение, этого следует избегать.

Конструкция `match` сама является **выражением**, то есть она вычисляет и возвращает значение. Значением конструкции `match` становится значение выражения той альтернативы, шаблон которой совпал с проверяемым значением. Выполняется только **одна** альтернатива.

В Scala 3 фигурные скобки вокруг блока `match` стали необязательными благодаря значимым отступам.

**Пример:**

val number = 42
// match - это выражение, поэтому его результат можно присвоить значению result
val result = number match
case 0 => "ноль" // Альтернатива 1
case 42 => "ответ на главный вопрос жизни" // Альтернатива 2
case n if n > 0 => s"положительное число: $n" // Альтернатива 3
case _ => "отрицательное число" // Альтернатива 4 (по умолчанию)

result // = "ответ на главный вопрос жизни"

В данном примере будет выбрана **альтернатива 2**, так как значение `42` точно совпадает с шаблоном во второй альтернативе. Остальные альтернативы проверяться не будут.

## Сравнение с if-else

Pattern matching можно рассматривать как более мощную и выразительную альтернативу конструкции `if-else if-else`. В то время как `if-else` проверяет логические условия, `match` позволяет сопоставлять структуру и тип данных, обеспечивая большую гибкость и безопасность типов.

Для лучшего понимания сравним эквивалентный код с использованием `if-else`:

// Используя if-else (менее выразительно)
val number = 42
val result = if (number == 0) {
"ноль"
} else if (number == 42) {
"ответ на главный вопрос жизни"
} else if (number > 0) {
s"положительное число: $number"
} else {
"отрицательное число"
}

// Используя pattern matching (более выразительно и безопасно)
val result2 = number match
case 0 => "ноль"
case 42 => "ответ на главный вопрос жизни"
case n if n > 0 => s"положительное число: $n"
case _ => "отрицательное число"

Pattern matching предоставляет несколько преимуществ:

- **Более читаемый код** - логика выражена более декларативно

- **Проверка исчерпывающности** - компилятор предупредит, если не все случаи покрыты

- **Безопасность типов** - автоматическое приведение типов в альтернативах

- **Мощные шаблоны** - возможность сопоставления сложных структур данных

## Альтернативы с блоками выражений

Выражение в альтернативе может быть блоком, и значением такого блока станет последнее выражение в нем:

val number = 42
val result = number match
case 0 => // Альтернатива 1 с блоком выражений
val message = "Получен ноль"
val status = "special"
s"$message ($status)" // Это значение вернется из альтернативы
case n if n > 0 => // Альтернатива 2 с блоком выражений
val doubled = n * 2
val category = "положительное"
s"$category число $n, удвоенное: $doubled" // Это значение вернется из альтернативы
case _ => // Альтернатива 3 с блоком выражений
val category = "отрицательное"
val advice = "проверьте входные данные"
s"$category число, $advice" // Это значение вернется из альтернативы

result // = "положительное число 42, удвоенное: 84"

## Совместимость типов альтернатив

Поскольку `match` является выражением, все альтернативы должны возвращать значения **совместимых** типов:

// Пример с одинаковыми типами:
val betterResult: String = x match
case 1 => "один"
case 2 => "два"
case 3 => "три"
case n => s"число $n" // Все альтернативы возвращают String

// Пример с совместимыми числовыми типами:
val numericResult: Double = x match
case 1 => 1.0 // Double
case 2 => 2 // Int (автоматически приводится к Double)
case 3 => 3.0f // Float (автоматически приводится к Double)
case _ => 0.0 // Double
// Общий тип - Double

// Компилятор может вывести тип автоматически:
val autoType = x match
case 1 => true // Boolean
case _ => false // Boolean
// autoType будет иметь тип Boolean

// Пример с несовместимыми типами (похоже на ошибку):
val result = x match
case 1 => "строка" // String
case 2 => 42 // Int
case 3 => true // Boolean
case _ => 3.14 // Double
// Компилятор найдет общий базовый тип - Any, но это скорее не то, что вам нужно!

## Порядок сопоставления альтернатив

Сопоставление происходит сверху вниз. Первая подходящая альтернатива определяет результат, остальные альтернативы не проверяются:

val x = 0
val result = x match
case n if n >= 0 => "Неотрицательное" // Альтернатива 1 - сработает для x = 0
case 0 => "Ноль" // Альтернатива 2 - недостижимый код!
case _ => "Другое" // Альтернатива 3 - по умолчанию

// Компилятор Scala выдаст предупреждение о наличии недостижимой альтернативы

## Исчерпывающность альтернатив

Компилятор проверяет, что все возможные случаи покрыты альтернативами:

val flag = true
val result = flag match
case true => "Истина" // Альтернатива 1
// Компилятор предупредит о неполном покрытии альтернатив
// Нужно добавить альтернативу: case false => "Ложь"

## Альтернатива по умолчанию

Шаблон `_` (подчеркивание) соответствует любому значению и обычно используется как альтернатива по умолчанию:

val grade = 'Z'
val description = grade match
case 'A' => "Отлично"
case 'B' => "Хорошо"
case 'C' => "Удовлетворительно"
case _ => "Неизвестная оценка" // Покрывает все остальные случаи

description // = "Неизвестная оценка"

 

## **Ключевые моменты для запоминания:**

- `match` — это выражение, которое возвращает значение

- Альтернативы проверяются последовательно сверху вниз

- Только одна альтернатива выполняется

- Все альтернативы должны возвращать совместимые типы

- Компилятор проверяет исчерпывающность покрытия случаев

---

### Полные данные JSON

<details>
<summary>Показать JSON данные</summary>

```json
{
  "name" : "text",
  "text" : "<h1 style=\"text-align:center;\">Сопоставления с образцом</h1>\n\n<p><strong>Pattern matching</strong> (сопоставление с образцом) — это мощная конструкция в Scala, которая позволяет сопоставлять значения с определенными шаблонами (образцами) и выполнять соответствующие действия. Мы рассмотрим основы pattern matching на примере примитивных типов данных, хотя эта конструкция способна работать и с гораздо более сложными структурами данных. </p>\n\n<p><strong>Синтаксис:</strong></p>\n\n<pre><code class=\"language-scala\">значение match\n  case шаблон1 =&gt; выражение1  // альтернатива 1\n  case шаблон2 =&gt; выражение2  // альтернатива 2\n  case _ =&gt; выражениеПоУмолчанию // альтернатива по умолчанию\n</code></pre>\n\n<p><strong>Альтернатива</strong> — это основной элемент конструкции pattern matching, который состоит из двух частей:</p>\n\n<ol>\n\t<li><strong>Шаблон</strong> (pattern) — образец, с которым сопоставляется значение</li>\n\t<li><strong>Выражение</strong> — код, который выполняется при совпадении шаблона</li>\n</ol>\n\n<p>Каждая строка <code>case шаблон =&gt; выражение</code> представляет собой одну альтернативу. Конструкция match проверяет альтернативы последовательно <strong>сверху вниз</strong>, и как только находится <strong>подходящий шаблон</strong> под значение, вычисляется соответствующее выражение. Дальнейшие проверки альтернатив не выполняются. </p>\n\n<p>Если <strong>ни один шаблон</strong> не совпал со значением, то конструкция выдаст <strong>исключительное значение</strong> и программа может прервать свое выполнение, этого следует избегать.</p>\n\n<p>Конструкция <code>match</code> сама является <strong>выражением</strong>, то есть она вычисляет и возвращает значение. Значением конструкции <code>match</code> становится значение выражения той альтернативы, шаблон которой совпал с проверяемым значением. Выполняется только <strong>одна</strong> альтернатива.</p>\n\n<p>В Scala 3 фигурные скобки вокруг блока <code>match</code> стали необязательными благодаря значимым отступам.</p>\n\n<p><strong>Пример:</strong></p>\n\n<pre><code class=\"language-scala\">val number = 42\n// match - это выражение, поэтому его результат можно присвоить значению result\nval result = number match\n  case 0 =&gt; \"ноль\"                                    // Альтернатива 1\n  case 42 =&gt; \"ответ на главный вопрос жизни\"          // Альтернатива 2  \n  case n if n &gt; 0 =&gt; s\"положительное число: $n\"      // Альтернатива 3\n  case _ =&gt; \"отрицательное число\"                     // Альтернатива 4 (по умолчанию)\n\nresult // = \"ответ на главный вопрос жизни\"\n</code></pre>\n\n<p>В данном примере будет выбрана <strong>альтернатива 2</strong>, так как значение <code>42</code> точно совпадает с шаблоном во второй альтернативе. Остальные альтернативы проверяться не будут.</p>\n\n<h2 style=\"text-align:center;\">Сравнение с if-else</h2>\n\n<p>Pattern matching можно рассматривать как более мощную и выразительную альтернативу конструкции <code>if-else if-else</code>. В то время как <code>if-else</code> проверяет логические условия, <code>match</code> позволяет сопоставлять структуру и тип данных, обеспечивая большую гибкость и безопасность типов.</p>\n\n<p>Для лучшего понимания сравним эквивалентный код с использованием <code>if-else</code>:</p>\n\n<pre><code class=\"language-scala\">// Используя if-else (менее выразительно)\nval number = 42\nval result = if (number == 0) {\n  \"ноль\"\n} else if (number == 42) {\n  \"ответ на главный вопрос жизни\"\n} else if (number &gt; 0) {\n  s\"положительное число: $number\"\n} else {\n  \"отрицательное число\"\n}\n\n// Используя pattern matching (более выразительно и безопасно)\nval result2 = number match\n  case 0 =&gt; \"ноль\"\n  case 42 =&gt; \"ответ на главный вопрос жизни\"\n  case n if n &gt; 0 =&gt; s\"положительное число: $n\"\n  case _ =&gt; \"отрицательное число\"\n</code></pre>\n\n<p>Pattern matching предоставляет несколько преимуществ:</p>\n\n<ul>\n\t<li><strong>Более читаемый код</strong> - логика выражена более декларативно</li>\n\t<li><strong>Проверка исчерпывающности</strong> - компилятор предупредит, если не все случаи покрыты</li>\n\t<li><strong>Безопасность типов</strong> - автоматическое приведение типов в альтернативах</li>\n\t<li><strong>Мощные шаблоны</strong> - возможность сопоставления сложных структур данных</li>\n</ul>\n\n<h2 style=\"text-align:center;\">Альтернативы с блоками выражений</h2>\n\n<p>Выражение в альтернативе может быть блоком, и значением такого блока станет последнее выражение в нем:</p>\n\n<pre><code class=\"language-scala\">val number = 42\nval result = number match\n  case 0 =&gt;                              // Альтернатива 1 с блоком выражений\n    val message = \"Получен ноль\"\n    val status = \"special\"\n    s\"$message ($status)\"                // Это значение вернется из альтернативы\n  case n if n &gt; 0 =&gt;                     // Альтернатива 2 с блоком выражений\n    val doubled = n * 2\n    val category = \"положительное\"\n    s\"$category число $n, удвоенное: $doubled\"  // Это значение вернется из альтернативы\n  case _ =&gt;                              // Альтернатива 3 с блоком выражений\n    val category = \"отрицательное\"\n    val advice = \"проверьте входные данные\"\n    s\"$category число, $advice\"          // Это значение вернется из альтернативы\n\nresult // = \"положительное число 42, удвоенное: 84\"\n\n</code></pre>\n\n<h2 style=\"text-align:center;\">Совместимость типов альтернатив</h2>\n\n<p>Поскольку <code>match</code> является выражением, все альтернативы должны возвращать значения <strong>совместимых</strong> типов:</p>\n\n<pre><code class=\"language-scala\">// Пример с одинаковыми типами:\nval betterResult: String = x match\n  case 1 =&gt; \"один\"\n  case 2 =&gt; \"два\"  \n  case 3 =&gt; \"три\"\n  case n =&gt; s\"число $n\"       // Все альтернативы возвращают String\n\n// Пример с совместимыми числовыми типами:\nval numericResult: Double = x match\n  case 1 =&gt; 1.0               // Double\n  case 2 =&gt; 2                 // Int (автоматически приводится к Double)\n  case 3 =&gt; 3.0f              // Float (автоматически приводится к Double)\n  case _ =&gt; 0.0               // Double\n// Общий тип - Double\n\n// Компилятор может вывести тип автоматически:\nval autoType = x match\n  case 1 =&gt; true              // Boolean\n  case _ =&gt; false             // Boolean\n// autoType будет иметь тип Boolean\n\n// Пример с несовместимыми типами (похоже на ошибку):\nval result = x match\n  case 1 =&gt; \"строка\"           // String\n  case 2 =&gt; 42                 // Int  \n  case 3 =&gt; true               // Boolean\n  case _ =&gt; 3.14               // Double\n// Компилятор найдет общий базовый тип - Any, но это скорее не то, что вам нужно!\n\n</code></pre>\n\n<h2 style=\"text-align:center;\">Порядок сопоставления альтернатив</h2>\n\n<p>Сопоставление происходит сверху вниз. Первая подходящая альтернатива определяет результат, остальные альтернативы не проверяются:</p>\n\n<pre><code class=\"language-scala\">val x = 0\nval result = x match\n  case n if n &gt;= 0 =&gt; \"Неотрицательное\"  // Альтернатива 1 - сработает для x = 0\n  case 0 =&gt; \"Ноль\"                       // Альтернатива 2 - недостижимый код!\n  case _ =&gt; \"Другое\"                     // Альтернатива 3 - по умолчанию\n\n// Компилятор Scala выдаст предупреждение о наличии недостижимой альтернативы\n</code></pre>\n\n<h2 style=\"text-align:center;\">Исчерпывающность альтернатив</h2>\n\n<p>Компилятор проверяет, что все возможные случаи покрыты альтернативами:</p>\n\n<pre><code class=\"language-scala\">val flag = true\nval result = flag match\n  case true =&gt; \"Истина\"  // Альтернатива 1\n  // Компилятор предупредит о неполном покрытии альтернатив\n  // Нужно добавить альтернативу: case false =&gt; \"Ложь\"\n</code></pre>\n\n<h2 style=\"text-align:center;\">Альтернатива по умолчанию</h2>\n\n<p>Шаблон <code>_</code> (подчеркивание) соответствует любому значению и обычно используется как альтернатива по умолчанию:</p>\n\n<pre><code class=\"language-scala\">val grade = 'Z'\nval description = grade match\n  case 'A' =&gt; \"Отлично\"\n  case 'B' =&gt; \"Хорошо\"\n  case 'C' =&gt; \"Удовлетворительно\"\n  case _ =&gt; \"Неизвестная оценка\"  // Покрывает все остальные случаи\n\ndescription // = \"Неизвестная оценка\"\n</code></pre>\n\n<p> </p>\n\n<h2><strong>Ключевые моменты для запоминания:</strong></h2>\n\n<ul>\n\t<li><code>match</code> — это выражение, которое возвращает значение</li>\n\t<li>Альтернативы проверяются последовательно сверху вниз</li>\n\t<li>Только одна альтернатива выполняется</li>\n\t<li>Все альтернативы должны возвращать совместимые типы</li>\n\t<li>Компилятор проверяет исчерпывающность покрытия случаев</li>\n</ul>",
  "video" : null,
  "options" : {
    
  },
  "subtitle_files" : [
  ],
  "is_deprecated" : false
}
```

</details>
