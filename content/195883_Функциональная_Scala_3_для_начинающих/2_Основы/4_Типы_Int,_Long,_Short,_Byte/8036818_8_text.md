# Материал (Шаг 8)

## Информация о шаге

- **ID шага**: 8036818
- **Позиция**: 8
- **Тип**: text
- **Курс**: Функциональная Scala 3 для начинающих
- **Экспортирован**: 2026-01-10T10:17:06.5938016

## Содержание

# Алгебраические свойства типа Int

В функциональном программировании нередко упоминаются разные алгебраические абстракции. На первый взгляд они кажутся чем-то сложным и сугубо теоретическим. Но многие из этих структур уже присутствуют в самых простых типах.

Хороший пример — обычный `Int`. В системе типов Scala он является не просто представлением целого числа, а полноценным носителем множества алгебраических свойств. Разные операции над `Int` образуют целую палитру структур: моноиды, группы, кольца.

Такое богатство не случайно. Оно отражает фундаментальные свойства целых чисел и делает вычисления с ними предсказуемыми, композируемыми и подчинёнными строгим законам. Например, операции над `Int` демонстрируют ассоциативность, коммутативность, дистрибутивность и даже идемпотентность в некоторых случаях.

Осознание этих встроенных возможностей помогает использовать `Int` не только как примитив, но и как основу для функциональных абстракций. Это позволяет писать код, который проще комбинировать, легче анализировать и надёжнее сопровождать.

**Примечание**: Данная статья является справочной, и не требует подробного изучения в данный момент. Некоторые термины и понятия могут быть неизвестными для обучающегося. Однако она содержит полезную информацию обзорного свойства для более глубокого понимания темы.

## Моноидальные структуры

### Аддитивный моноид

Самая очевидная моноидальная структура `Int` основана на операции сложения:

// Нейтральный элемент: 0
val x = 42
x + 0 // 42
0 + x // 42

// Ассоциативность сложения
val a = 10
val b = 20
val c = 30
(a + b) + c == a + (b + c) // true, оба равны 60

Здесь `0` выступает как нейтральный элемент, а операция `+` ассоциативна, что делает `(Int, +, 0)` классическим моноидом.

### Мультипликативный моноид

Параллельно существует мультипликативная структура:

// Нейтральный элемент: 1
val x = 42
x * 1 // 42
1 * x // 42

// Ассоциативность умножения
val a = 2
val b = 3
val c = 4
(a * b) * c == a * (b * c) // true, оба равны 24

Структура `(Int, *, 1)` образует второй моноид на том же множестве, демонстрируя, что один тип может поддерживать множественные алгебраические интерпретации.

### Min/Max моноиды

Операции минимума и максимума также образуют моноидальные структуры:

// Min моноид с нейтральным элементом Int.MaxValue
val x = 42
math.min(x, Int.MaxValue) == x // true
math.min(math.min(10, 5), 15) == math.min(10, math.min(5, 15)) // true

// Max моноид с нейтральным элементом Int.MinValue
math.max(x, Int.MinValue) == x // true
math.max(math.max(10, 25), 15) == math.max(10, math.max(25, 15)) // true

### XOR моноид

Битовая операция исключающего ИЛИ создает еще один моноид:

// Нейтральный элемент: 0
val x = 42
x ^ 0 == x // true

// Ассоциативность и самообратность
val a = 5
val b = 3
val c = 7
(a ^ b) ^ c == a ^ (b ^ c) // true
a ^ a == 0 // true (каждый элемент обратен сам себе)

## Групповые структуры

### Аддитивная группа

`Int` с операцией сложения образует не только моноид, но и группу:

// Каждый элемент имеет обратный
val x = 42
val inverse = -x
x + inverse == 0 // true
inverse + x == 0 // true

// Обратный к обратному - исходный элемент
-(-x) == x // true

// Коммутативность (абелева группа)
val a = 10
val b = 7
a + b == b + a // true

Структура `(Int, +, 0, -)` является абелевой (коммутативной) группой, где каждое число имеет аддитивный обратный элемент.

## Кольцевые структуры

### Кольцо

Объединяя аддитивную группу и мультипликативный моноид, получаем кольцевую структуру:

val a = 2
val b = 3
val c = 4

// Левая дистрибутивность: a * (b + c) = a * b + a * c
a * (b + c) == a * b + a * c // true, оба равны 14

// Правая дистрибутивность: (a + b) * c = a * c + b * c
(a + b) * c == a * c + b * c // true, оба равны 20

// Аннигиляция нулем
val x = 5
x * 0 == 0 // true

### Евклидово кольцо

`Int` поддерживает деление с остатком, что делает его евклидовым кольцом:

// Деление с остатком
val dividend = 17
val divisor = 5
val quotient = dividend / divisor // 3
val remainder = dividend % divisor // 2

// Восстановление: a = bq + r, где |r| < |b|
quotient * divisor + remainder == dividend // true

// Алгоритм Евклида для НОД
def gcd(a: Int, b: Int): Int =
if (b == 0) math.abs(a) else gcd(b, a % b)

gcd(48, 18) // 6

## Упорядоченные структуры

### Решетка (Lattice)

Операции `min` и `max` превращают `Int` в решетку:

val x = 10
val y = 15
val z = 5

// Join (supremum) и meet (infimum)
math.max(x, y) // 15
math.min(x, y) // 10

// Коммутативность
math.max(x, y) == math.max(y, x) // true

// Ассоциативность
math.max(math.max(x, y), z) == math.max(x, math.max(y, z)) // true

// Законы поглощения: a ∨ (a ∧ b) = a
math.max(x, math.min(x, y)) == x // true
math.min(x, math.max(x, y)) == x // true

// Идемпотентность: a ∨ a = a
math.max(x, x) == x // true

### Тотально упорядоченное множество

`Int` образует линейно упорядоченное множество:

val x = 10
val y = 20

// Любые два элемента сравнимы (трихотомия)
(x < y) || (x == y) || (x > y) // true, точно одно условие выполнено

// Транзитивность
val a = 5
val b = 10
val c = 15
(a <= b) && (b <= c) && (a <= c) // true

// Антисимметричность
(x <= x) && (x >= x) && (x == x) // true

## Вычислительные структуры

### Числовые операции

Как числовой тип, `Int` поддерживает полный набор арифметических операций:

val x = 42
val y = 17

// Основные операции
x + y // 59
x - y // 25
x * y // 714
x / y // 2
x % y // 8

// Унарные операции
+x // 42
-x // -42
math.abs(-x) // 42

// Преобразования типов
x.toDouble // 42.0
x.toLong // 42L
x.toFloat // 42.0f

### Битовые операции

`Int` поддерживает полный набор битовых операций:

val a = 12 // 1100₂
val b = 10 // 1010₂

a & b // 8 (1000₂) - побитовое И
a | b // 14 (1110₂) - побитовое ИЛИ
a ^ b // 6 (0110₂) - исключающее ИЛИ
~a // -13 - побитовое отрицание
a << 1 // 24 - сдвиг влево
a >> 1 // 6 - арифметический сдвиг вправо

### Перечислимость (Enum-like поведение)

`Int` ведет себя как перечислимый тип:

val current = 42

// Следующий/предыдущий элемент
current + 1 // 43
current - 1 // 41

// Генерация последовательностей
1 to 5 // Range(1, 2, 3, 4, 5)
5 until 10 // Range(5, 6, 7, 8, 9)
0 to 10 by 2 // Range(0, 2, 4, 6, 8, 10)

// Конечные границы
Int.MaxValue // 2147483647
Int.MinValue // -2147483648

## Системные свойства

### Хеширование

`Int` является идеальным хешируемым типом:

val x = 42
val y = 42
val z = 17

// Одинаковые значения → одинаковые хеши
x.hashCode == y.hashCode // true

// Int хешируется в себя (для небольших значений)
x.hashCode == x // true

// Разные значения → разные хеши
x.hashCode != z.hashCode // true

### Сериализация

`Int` естественно сериализуется в различные представления:

val number = 42

// Текстовые представления
number.toString // "42"
number.toBinaryString // "101010"
number.toOctalString // "52"
number.toHexString // "2a"

// Обратное преобразование
"42".toInt == number // true

// Парсинг в различных системах счисления
Integer.parseInt("101010", 2) == number // true
Integer.parseInt("52", 8) == number // true
Integer.parseInt("2a", 16) == number // true

### Валидация диапазонов

`Int` предоставляет методы для проверки совместимости с другими числовыми типами:

val x = 442

x.isValidByte // false (вне диапазона [-128, 127])
x.isValidShort // true (в диапазоне [-32768, 32767])
x.isValidChar // true (в диапазоне [0, 65535])

// Граничные проверки
x < Int.MaxValue // true
x > Int.MinValue // true

---

### Полные данные JSON

<details>
<summary>Показать JSON данные</summary>

```json
{
  "name" : "text",
  "text" : "<h1 style=\"text-align:center;\">Алгебраические свойства типа Int</h1>\n\n<p>В функциональном программировании нередко упоминаются разные алгебраические абстракции. На первый взгляд они кажутся чем-то сложным и сугубо теоретическим. Но многие из этих структур уже присутствуют в самых простых типах.</p>\n\n<p>Хороший пример — обычный <code>Int</code>. В системе типов Scala он является не просто представлением целого числа, а полноценным носителем множества алгебраических свойств. Разные операции над <code>Int</code> образуют целую палитру структур: моноиды, группы, кольца.</p>\n\n<p>Такое богатство не случайно. Оно отражает фундаментальные свойства целых чисел и делает вычисления с ними предсказуемыми, композируемыми и подчинёнными строгим законам. Например, операции над <code>Int</code> демонстрируют ассоциативность, коммутативность, дистрибутивность и даже идемпотентность в некоторых случаях.</p>\n\n<p>Осознание этих встроенных возможностей помогает использовать <code>Int</code> не только как примитив, но и как основу для функциональных абстракций. Это позволяет писать код, который проще комбинировать, легче анализировать и надёжнее сопровождать.</p>\n\n<blockquote>\n<p><strong>Примечание</strong>: Данная статья является справочной, и не требует подробного изучения в данный момент. Некоторые термины и понятия могут быть неизвестными для обучающегося. Однако она содержит полезную информацию обзорного свойства для более глубокого понимания темы.</p>\n</blockquote>\n\n<h2 style=\"text-align:center;\">Моноидальные структуры</h2>\n\n<h3>Аддитивный моноид</h3>\n\n<p>Самая очевидная моноидальная структура <code>Int</code> основана на операции сложения:</p>\n\n<pre><code class=\"language-scala\">// Нейтральный элемент: 0\nval x = 42\nx + 0  // 42\n0 + x  // 42\n\n// Ассоциативность сложения\nval a = 10\nval b = 20  \nval c = 30\n(a + b) + c == a + (b + c)  // true, оба равны 60\n</code></pre>\n\n<p>Здесь <code>0</code> выступает как нейтральный элемент, а операция <code>+</code> ассоциативна, что делает <code>(Int, +, 0)</code> классическим моноидом.</p>\n\n<h3>Мультипликативный моноид</h3>\n\n<p>Параллельно существует мультипликативная структура:</p>\n\n<pre><code class=\"language-scala\">// Нейтральный элемент: 1\nval x = 42\nx * 1  // 42\n1 * x  // 42\n\n// Ассоциативность умножения\nval a = 2\nval b = 3\nval c = 4\n(a * b) * c == a * (b * c)  // true, оба равны 24\n</code></pre>\n\n<p>Структура <code>(Int, *, 1)</code> образует второй моноид на том же множестве, демонстрируя, что один тип может поддерживать множественные алгебраические интерпретации.</p>\n\n<h3>Min/Max моноиды</h3>\n\n<p>Операции минимума и максимума также образуют моноидальные структуры:</p>\n\n<pre><code class=\"language-scala\">// Min моноид с нейтральным элементом Int.MaxValue\nval x = 42\nmath.min(x, Int.MaxValue) == x  // true\nmath.min(math.min(10, 5), 15) == math.min(10, math.min(5, 15))  // true\n\n// Max моноид с нейтральным элементом Int.MinValue  \nmath.max(x, Int.MinValue) == x  // true\nmath.max(math.max(10, 25), 15) == math.max(10, math.max(25, 15))  // true\n</code></pre>\n\n<h3>XOR моноид</h3>\n\n<p>Битовая операция исключающего ИЛИ создает еще один моноид:</p>\n\n<pre><code class=\"language-scala\">// Нейтральный элемент: 0\nval x = 42\nx ^ 0 == x  // true\n\n// Ассоциативность и самообратность\nval a = 5\nval b = 3  \nval c = 7\n(a ^ b) ^ c == a ^ (b ^ c)  // true\na ^ a == 0  // true (каждый элемент обратен сам себе)\n</code></pre>\n\n<h2 style=\"text-align:center;\">Групповые структуры</h2>\n\n<h3>Аддитивная группа</h3>\n\n<p><code>Int</code> с операцией сложения образует не только моноид, но и группу:</p>\n\n<pre><code class=\"language-scala\">// Каждый элемент имеет обратный\nval x = 42\nval inverse = -x\nx + inverse == 0  // true\ninverse + x == 0  // true\n\n// Обратный к обратному - исходный элемент  \n-(-x) == x  // true\n\n// Коммутативность (абелева группа)\nval a = 10\nval b = 7  \na + b == b + a  // true\n</code></pre>\n\n<p>Структура <code>(Int, +, 0, -)</code> является абелевой (коммутативной) группой, где каждое число имеет аддитивный обратный элемент.</p>\n\n<h2 style=\"text-align:center;\">Кольцевые структуры</h2>\n\n<h3>Кольцо</h3>\n\n<p>Объединяя аддитивную группу и мультипликативный моноид, получаем кольцевую структуру:</p>\n\n<pre><code class=\"language-scala\">val a = 2\nval b = 3\nval c = 4\n\n// Левая дистрибутивность: a * (b + c) = a * b + a * c\na * (b + c) == a * b + a * c  // true, оба равны 14\n\n// Правая дистрибутивность: (a + b) * c = a * c + b * c  \n(a + b) * c == a * c + b * c  // true, оба равны 20\n\n// Аннигиляция нулем\nval x = 5\nx * 0 == 0  // true\n</code></pre>\n\n<h3>Евклидово кольцо</h3>\n\n<p><code>Int</code> поддерживает деление с остатком, что делает его евклидовым кольцом:</p>\n\n<pre><code class=\"language-scala\">// Деление с остатком\nval dividend = 17\nval divisor = 5\nval quotient = dividend / divisor   // 3\nval remainder = dividend % divisor  // 2\n\n// Восстановление: a = bq + r, где |r| &lt; |b|\nquotient * divisor + remainder == dividend  // true\n\n// Алгоритм Евклида для НОД\ndef gcd(a: Int, b: Int): Int =\n  if (b == 0) math.abs(a) else gcd(b, a % b)\n\ngcd(48, 18)  // 6\n</code></pre>\n\n<h2 style=\"text-align:center;\">Упорядоченные структуры</h2>\n\n<h3>Решетка (Lattice)</h3>\n\n<p>Операции <code>min</code> и <code>max</code> превращают <code>Int</code> в решетку:</p>\n\n<pre><code class=\"language-scala\">val x = 10\nval y = 15\nval z = 5\n\n// Join (supremum) и meet (infimum)\nmath.max(x, y)  // 15\nmath.min(x, y)  // 10\n\n// Коммутативность\nmath.max(x, y) == math.max(y, x)  // true\n\n// Ассоциативность  \nmath.max(math.max(x, y), z) == math.max(x, math.max(y, z))  // true\n\n// Законы поглощения: a ∨ (a ∧ b) = a\nmath.max(x, math.min(x, y)) == x  // true\nmath.min(x, math.max(x, y)) == x  // true\n\n// Идемпотентность: a ∨ a = a\nmath.max(x, x) == x  // true\n</code></pre>\n\n<h3>Тотально упорядоченное множество</h3>\n\n<p><code>Int</code> образует линейно упорядоченное множество:</p>\n\n<pre><code class=\"language-scala\">val x = 10\nval y = 20\n\n// Любые два элемента сравнимы (трихотомия)\n(x &lt; y) || (x == y) || (x &gt; y)  // true, точно одно условие выполнено\n\n// Транзитивность\nval a = 5\nval b = 10  \nval c = 15\n(a &lt;= b) &amp;&amp; (b &lt;= c) &amp;&amp; (a &lt;= c)  // true\n\n// Антисимметричность  \n(x &lt;= x) &amp;&amp; (x &gt;= x) &amp;&amp; (x == x)  // true\n</code></pre>\n\n<h2 style=\"text-align:center;\">Вычислительные структуры</h2>\n\n<h3>Числовые операции</h3>\n\n<p>Как числовой тип, <code>Int</code> поддерживает полный набор арифметических операций:</p>\n\n<pre><code class=\"language-scala\">val x = 42\nval y = 17\n\n// Основные операции\nx + y  // 59\nx - y  // 25  \nx * y  // 714\nx / y  // 2\nx % y  // 8\n\n// Унарные операции\n+x     // 42\n-x     // -42\nmath.abs(-x)  // 42\n\n// Преобразования типов\nx.toDouble  // 42.0\nx.toLong    // 42L\nx.toFloat   // 42.0f\n</code></pre>\n\n<h3>Битовые операции</h3>\n\n<p><code>Int</code> поддерживает полный набор битовых операций:</p>\n\n<pre><code class=\"language-scala\">val a = 12  // 1100₂\nval b = 10  // 1010₂\n\na &amp; b   // 8  (1000₂) - побитовое И\na | b   // 14 (1110₂) - побитовое ИЛИ  \na ^ b   // 6  (0110₂) - исключающее ИЛИ\n~a      // -13 - побитовое отрицание\na &lt;&lt; 1  // 24 - сдвиг влево\na &gt;&gt; 1  // 6  - арифметический сдвиг вправо\n</code></pre>\n\n<h3>Перечислимость (Enum-like поведение)</h3>\n\n<p><code>Int</code> ведет себя как перечислимый тип:</p>\n\n<pre><code class=\"language-scala\">val current = 42\n\n// Следующий/предыдущий элемент\ncurrent + 1  // 43\ncurrent - 1  // 41\n\n// Генерация последовательностей\n1 to 5         // Range(1, 2, 3, 4, 5)\n5 until 10     // Range(5, 6, 7, 8, 9)  \n0 to 10 by 2   // Range(0, 2, 4, 6, 8, 10)\n\n// Конечные границы\nInt.MaxValue  // 2147483647\nInt.MinValue  // -2147483648\n</code></pre>\n\n<h2 style=\"text-align:center;\">Системные свойства</h2>\n\n<h3>Хеширование</h3>\n\n<p><code>Int</code> является идеальным хешируемым типом:</p>\n\n<pre><code class=\"language-scala\">val x = 42\nval y = 42\nval z = 17\n\n// Одинаковые значения → одинаковые хеши\nx.hashCode == y.hashCode  // true\n\n// Int хешируется в себя (для небольших значений)  \nx.hashCode == x  // true\n\n// Разные значения → разные хеши\nx.hashCode != z.hashCode  // true\n</code></pre>\n\n<h3>Сериализация</h3>\n\n<p><code>Int</code> естественно сериализуется в различные представления:</p>\n\n<pre><code class=\"language-scala\">val number = 42\n\n// Текстовые представления\nnumber.toString        // \"42\"\nnumber.toBinaryString  // \"101010\"  \nnumber.toOctalString   // \"52\"\nnumber.toHexString     // \"2a\"\n\n// Обратное преобразование\n\"42\".toInt == number  // true\n\n// Парсинг в различных системах счисления\nInteger.parseInt(\"101010\", 2) == number   // true\nInteger.parseInt(\"52\", 8) == number       // true\nInteger.parseInt(\"2a\", 16) == number      // true\n</code></pre>\n\n<h3>Валидация диапазонов</h3>\n\n<p><code>Int</code> предоставляет методы для проверки совместимости с другими числовыми типами:</p>\n\n<pre><code class=\"language-scala\">val x = 442\n\nx.isValidByte    // false (вне диапазона [-128, 127])\nx.isValidShort   // true  (в диапазоне [-32768, 32767])\nx.isValidChar    // true  (в диапазоне [0, 65535])\n\n// Граничные проверки\nx &lt; Int.MaxValue  // true\nx &gt; Int.MinValue  // true\n</code></pre>",
  "video" : null,
  "options" : {
    
  },
  "subtitle_files" : [
  ],
  "is_deprecated" : false
}
```

</details>
