# Материал (Шаг 1)

## Информация о шаге

- **ID шага**: 5082784
- **Позиция**: 1
- **Тип**: text
- **Курс**: Функциональная Scala 3 для начинающих
- **Экспортирован**: 2026-01-10T10:17:06.5744579

## Содержание

# Тип Int

Тип данных `Int` является моделью целых чисел, которые могут быть положительными, отрицательными или нулевыми. В отличие от математических целых чисел имеет ограничения в размерах области определения, и не является бесконечным. Диапазон его значений от -231 до 231-1. Таким образом тип имеет 4 294 967 296 значений. В большинстве случаев этого достаточно для расчетов.

У типа Int есть литералы, с помощью которых можно явно указать значение этого типа:

- Десятичные литералы, например: `0`, `1`, `2`, `3`.

- Шестнадцатеричные литералы (числа в исчислении по основанию 16), например: `0x5`, `0x00FF`. Префикс 0x в начале числа показывает, что это шестнадцатеричное число. В числе используются символы от 0 до 9 и от A до F.

## Особенности типа Int

### Переполнение

Из-за того, что тип данных `Int `имеет ограниченный диапазон значений, при выполнении операций сложения, вычитания, умножения, а также при** конвертации** могут возникнуть ситуации **переполнения**. Переполнение происходит, когда результат операции выходит за пределы диапазона значений для данного типа данных.

При переполнении не возникает ошибки, так и задумано, а появляется значение с противоположного края диапазона значений. Диапазон значений как бы закольцован.

Получить максимальные и минимальные значения типа можно из констант:

Int.MinValue = -2147483648
Int.MaxValue = 2147483647

Пример переполнения:

`Int.MaxValue + 1`  получим в результате  ` Int.MinValue`

`Int.MaxValue + 2`  получим в результате   `Int.MinValue + 1`

Переполнение значения типа может пройти **незаметно**, и привести к неправильному результату, если ваш алгоритм вычислений не предполагает такое поведение типа Int.

Основной источник переполнения - это неконтролируемые входные данные. Проверяя входные данные на корректность и контролируя их размер, можно исключить переполнения, если конечно в самом коде выбраны правильные типы и математические операции учитывают диапазон значений типа.

Если вам нужны большие числа, то нужно использовать тип `Long `или `BigInt`.

### Целочисленное деление

У типа `Int` особый вид операции деления. Это целочисленное деление. Обозначение операции: `/`

**Целочисленное деление** — это операция деления одного целого числа на другое, при которой результатом является целое число, без остатка.

Пример:

val res: Int = 7 / 3 // результат будет 2
val res2: Int = 2 / 3 // результат будет 0

При операции целочисленного деления двух чисел типа Int, результатом будет также тип Int. Остаток от деления или дробная часть в данной операции отбрасывается.

### Остаток от целочисленного деления

Операция получения остатка от целочисленного деления представляет собой нахождение остатка, который остается после деления одного целого числа на другое. Эта операция обозначается знаком `%`.

Пример:

val res: Int = 7 % 3 // результат будет 1
val res2: Int = -2 % 3 // результат будет -2

Результат операции получения остатка от целочисленного деления можно **проверить** с помощью других операций.

*Для любых двух целых чисел a и b (где b ≠ 0), верно* *a = b × q + r*

*где:*

- *q — результат целочисленного деления a / b*

- *r — остаток от деления a % b*

Пример:

val q: Int = 7 / 3 // результат будет 2
val r: Int = 7 % 3 // результат будет 1
val isCorrect = 7 == 3 * q + r // результат будет true

### Деление на ноль

Часто встречающаяся проблема с типом Int, это деление на ноль. Эта проблема выявляется при выполнении программы, но не выявляется при анализе кода компилятором. Проблема связана с отсутствием в области определения типа Int таких значений, как минус бесконечность, плюс бесконечность, неопределенное значение. Соответственно, тип Int не может правильно представить значение некоторых операций. Опять же, решение проблемы деления на ноль возложена на разработчика, и требует создания специальных проверок. Это плата за производительность этого типа данных.

Более подробно о реализации типа Int можно посмотреть [видео](https://www.youtube.com/watch?v=BIYiuy8WWiU&list=PLIJLLSrXDPojDGKW0WZ7sU0eO3nyn0oDc&index=8)

---

### Полные данные JSON

<details>
<summary>Показать JSON данные</summary>

```json
{
  "name" : "text",
  "text" : "<h1 style=\"text-align:center;\">Тип Int</h1>\n\n<p>Тип данных <code>Int</code> является моделью целых чисел, которые могут быть положительными, отрицательными или нулевыми. В отличие от математических целых чисел имеет ограничения в размерах области определения, и не является бесконечным. Диапазон его значений от -2<sup>31</sup> до 2<sup>31</sup>-1. Таким образом тип имеет 4 294 967 296 значений. В большинстве случаев этого достаточно для расчетов.</p>\n\n<p>У типа Int есть литералы, с помощью которых можно явно указать значение этого типа:</p>\n\n<ul>\n\t<li>Десятичные литералы, например: <code>0</code>, <code>1</code>, <code>2</code>, <code>3</code>.</li>\n\t<li>Шестнадцатеричные литералы (числа в исчислении по основанию 16), например: <code>0x5</code>, <code>0x00FF</code>. Префикс 0x в начале числа показывает, что это шестнадцатеричное число. В числе используются символы от 0 до 9 и от A до F.</li>\n</ul>\n\n<h2 style=\"text-align:center;\">Особенности типа Int</h2>\n\n<h3 style=\"text-align:center;\">Переполнение</h3>\n\n<p>Из-за того, что тип данных <code>Int </code>имеет ограниченный диапазон значений, при выполнении операций сложения, вычитания, умножения, а также при<strong> конвертации</strong> могут возникнуть ситуации <strong>переполнения</strong>. Переполнение происходит, когда результат операции выходит за пределы диапазона значений для данного типа данных.</p>\n\n<p>При переполнении не возникает ошибки, так и задумано, а появляется значение с противоположного края диапазона значений. Диапазон значений как бы закольцован.</p>\n\n<p>Получить максимальные и минимальные значения типа можно из констант:</p>\n\n<pre><code>Int.MinValue = -2147483648 \nInt.MaxValue = 2147483647</code></pre>\n\n<p>Пример переполнения:</p>\n\n<p><code>Int.MaxValue + 1</code>  получим в результате  <code> Int.MinValue</code></p>\n\n<p><code>Int.MaxValue + 2</code>  получим в результате   <code>Int.MinValue + 1</code></p>\n\n<p>Переполнение значения типа может пройти <strong>незаметно</strong>, и привести к неправильному результату, если ваш алгоритм вычислений не предполагает такое поведение типа Int.</p>\n\n<p>Основной источник переполнения - это неконтролируемые входные данные. Проверяя входные данные на корректность и контролируя их размер, можно исключить переполнения, если конечно в самом коде выбраны правильные типы и математические операции учитывают диапазон значений типа.</p>\n\n<p>Если вам нужны большие числа, то нужно использовать тип <code>Long </code>или <code>BigInt</code>.</p>\n\n<h3 style=\"text-align:center;\">Целочисленное деление</h3>\n\n<p>У типа <code>Int</code> особый вид операции деления. Это целочисленное деление. Обозначение операции: <code>/</code></p>\n\n<p><strong>Целочисленное деление</strong> — это операция деления одного целого числа на другое, при которой результатом является целое число, без остатка.</p>\n\n<p>Пример:</p>\n\n<pre><code class=\"language-scala\">val res: Int = 7 / 3  // результат будет 2\nval res2: Int = 2 / 3 // результат будет 0</code></pre>\n\n<p>При операции целочисленного деления двух чисел типа Int, результатом будет также тип Int. Остаток от деления или дробная часть в данной операции отбрасывается.</p>\n\n<h3 style=\"text-align:center;\">Остаток от целочисленного деления</h3>\n\n<p>Операция получения остатка от целочисленного деления представляет собой нахождение остатка, который остается после деления одного целого числа на другое. Эта операция обозначается знаком <code>%</code>.</p>\n\n<p>Пример:</p>\n\n<pre><code class=\"language-scala\">val res: Int = 7 % 3  // результат будет 1\nval res2: Int = -2 % 3 // результат будет -2</code></pre>\n\n<p>Результат операции получения остатка от целочисленного деления можно <strong>проверить</strong> с помощью других операций.</p>\n\n<p><em>Для любых двух целых чисел a и b (где b ≠ 0), верно</em> <em>a = b × q + r</em></p>\n\n<p><em>где:</em></p>\n\n<ul>\n\t<li><em>q — результат целочисленного деления a / b</em></li>\n\t<li><em>r — остаток от деления a % b</em></li>\n</ul>\n\n<p>Пример:</p>\n\n<pre><code class=\"language-scala\">val q: Int = 7 / 3  // результат будет 2\nval r: Int = 7 % 3  // результат будет 1\nval isCorrect = 7 == 3 * q + r // результат будет true</code></pre>\n\n<h3 style=\"text-align:center;\">Деление на ноль</h3>\n\n<p>Часто встречающаяся проблема с типом Int, это деление на ноль. Эта проблема выявляется при выполнении программы, но не выявляется при анализе кода компилятором. Проблема связана с отсутствием в области определения типа Int таких значений, как минус бесконечность, плюс бесконечность, неопределенное значение. Соответственно, тип Int не может правильно представить значение некоторых операций. Опять же, решение проблемы деления на ноль возложена на разработчика, и требует создания специальных проверок. Это плата за производительность этого типа данных.</p>\n\n<p>Более подробно о реализации типа Int можно посмотреть <a href=\"https://www.youtube.com/watch?v=BIYiuy8WWiU&amp;list=PLIJLLSrXDPojDGKW0WZ7sU0eO3nyn0oDc&amp;index=8\" rel=\"noopener noreferrer nofollow\">видео</a></p>",
  "video" : null,
  "options" : {
    
  },
  "subtitle_files" : [
  ],
  "is_deprecated" : false
}
```

</details>
