{
  "step_id" : 8036818,
  "lesson_id" : 1221094,
  "position" : 8,
  "type" : "unknown",
  "block" : {
    "name" : "text",
    "text" : "<h1 style=\"text-align:center;\">Алгебраические свойства типа Int</h1>\n\n<p>В функциональном программировании нередко упоминаются разные алгебраические абстракции. На первый взгляд они кажутся чем-то сложным и сугубо теоретическим. Но многие из этих структур уже присутствуют в самых простых типах.</p>\n\n<p>Хороший пример — обычный <code>Int</code>. В системе типов Scala он является не просто представлением целого числа, а полноценным носителем множества алгебраических свойств. Разные операции над <code>Int</code> образуют целую палитру структур: моноиды, группы, кольца.</p>\n\n<p>Такое богатство не случайно. Оно отражает фундаментальные свойства целых чисел и делает вычисления с ними предсказуемыми, композируемыми и подчинёнными строгим законам. Например, операции над <code>Int</code> демонстрируют ассоциативность, коммутативность, дистрибутивность и даже идемпотентность в некоторых случаях.</p>\n\n<p>Осознание этих встроенных возможностей помогает использовать <code>Int</code> не только как примитив, но и как основу для функциональных абстракций. Это позволяет писать код, который проще комбинировать, легче анализировать и надёжнее сопровождать.</p>\n\n<blockquote>\n<p><strong>Примечание</strong>: Данная статья является справочной, и не требует подробного изучения в данный момент. Некоторые термины и понятия могут быть неизвестными для обучающегося. Однако она содержит полезную информацию обзорного свойства для более глубокого понимания темы.</p>\n</blockquote>\n\n<h2 style=\"text-align:center;\">Моноидальные структуры</h2>\n\n<h3>Аддитивный моноид</h3>\n\n<p>Самая очевидная моноидальная структура <code>Int</code> основана на операции сложения:</p>\n\n<pre><code class=\"language-scala\">// Нейтральный элемент: 0\nval x = 42\nx + 0  // 42\n0 + x  // 42\n\n// Ассоциативность сложения\nval a = 10\nval b = 20  \nval c = 30\n(a + b) + c == a + (b + c)  // true, оба равны 60\n</code></pre>\n\n<p>Здесь <code>0</code> выступает как нейтральный элемент, а операция <code>+</code> ассоциативна, что делает <code>(Int, +, 0)</code> классическим моноидом.</p>\n\n<h3>Мультипликативный моноид</h3>\n\n<p>Параллельно существует мультипликативная структура:</p>\n\n<pre><code class=\"language-scala\">// Нейтральный элемент: 1\nval x = 42\nx * 1  // 42\n1 * x  // 42\n\n// Ассоциативность умножения\nval a = 2\nval b = 3\nval c = 4\n(a * b) * c == a * (b * c)  // true, оба равны 24\n</code></pre>\n\n<p>Структура <code>(Int, *, 1)</code> образует второй моноид на том же множестве, демонстрируя, что один тип может поддерживать множественные алгебраические интерпретации.</p>\n\n<h3>Min/Max моноиды</h3>\n\n<p>Операции минимума и максимума также образуют моноидальные структуры:</p>\n\n<pre><code class=\"language-scala\">// Min моноид с нейтральным элементом Int.MaxValue\nval x = 42\nmath.min(x, Int.MaxValue) == x  // true\nmath.min(math.min(10, 5), 15) == math.min(10, math.min(5, 15))  // true\n\n// Max моноид с нейтральным элементом Int.MinValue  \nmath.max(x, Int.MinValue) == x  // true\nmath.max(math.max(10, 25), 15) == math.max(10, math.max(25, 15))  // true\n</code></pre>\n\n<h3>XOR моноид</h3>\n\n<p>Битовая операция исключающего ИЛИ создает еще один моноид:</p>\n\n<pre><code class=\"language-scala\">// Нейтральный элемент: 0\nval x = 42\nx ^ 0 == x  // true\n\n// Ассоциативность и самообратность\nval a = 5\nval b = 3  \nval c = 7\n(a ^ b) ^ c == a ^ (b ^ c)  // true\na ^ a == 0  // true (каждый элемент обратен сам себе)\n</code></pre>\n\n<h2 style=\"text-align:center;\">Групповые структуры</h2>\n\n<h3>Аддитивная группа</h3>\n\n<p><code>Int</code> с операцией сложения образует не только моноид, но и группу:</p>\n\n<pre><code class=\"language-scala\">// Каждый элемент имеет обратный\nval x = 42\nval inverse = -x\nx + inverse == 0  // true\ninverse + x == 0  // true\n\n// Обратный к обратному - исходный элемент  \n-(-x) == x  // true\n\n// Коммутативность (абелева группа)\nval a = 10\nval b = 7  \na + b == b + a  // true\n</code></pre>\n\n<p>Структура <code>(Int, +, 0, -)</code> является абелевой (коммутативной) группой, где каждое число имеет аддитивный обратный элемент.</p>\n\n<h2 style=\"text-align:center;\">Кольцевые структуры</h2>\n\n<h3>Кольцо</h3>\n\n<p>Объединяя аддитивную группу и мультипликативный моноид, получаем кольцевую структуру:</p>\n\n<pre><code class=\"language-scala\">val a = 2\nval b = 3\nval c = 4\n\n// Левая дистрибутивность: a * (b + c) = a * b + a * c\na * (b + c) == a * b + a * c  // true, оба равны 14\n\n// Правая дистрибутивность: (a + b) * c = a * c + b * c  \n(a + b) * c == a * c + b * c  // true, оба равны 20\n\n// Аннигиляция нулем\nval x = 5\nx * 0 == 0  // true\n</code></pre>\n\n<h3>Евклидово кольцо</h3>\n\n<p><code>Int</code> поддерживает деление с остатком, что делает его евклидовым кольцом:</p>\n\n<pre><code class=\"language-scala\">// Деление с остатком\nval dividend = 17\nval divisor = 5\nval quotient = dividend / divisor   // 3\nval remainder = dividend % divisor  // 2\n\n// Восстановление: a = bq + r, где |r| &lt; |b|\nquotient * divisor + remainder == dividend  // true\n\n// Алгоритм Евклида для НОД\ndef gcd(a: Int, b: Int): Int =\n  if (b == 0) math.abs(a) else gcd(b, a % b)\n\ngcd(48, 18)  // 6\n</code></pre>\n\n<h2 style=\"text-align:center;\">Упорядоченные структуры</h2>\n\n<h3>Решетка (Lattice)</h3>\n\n<p>Операции <code>min</code> и <code>max</code> превращают <code>Int</code> в решетку:</p>\n\n<pre><code class=\"language-scala\">val x = 10\nval y = 15\nval z = 5\n\n// Join (supremum) и meet (infimum)\nmath.max(x, y)  // 15\nmath.min(x, y)  // 10\n\n// Коммутативность\nmath.max(x, y) == math.max(y, x)  // true\n\n// Ассоциативность  \nmath.max(math.max(x, y), z) == math.max(x, math.max(y, z))  // true\n\n// Законы поглощения: a ∨ (a ∧ b) = a\nmath.max(x, math.min(x, y)) == x  // true\nmath.min(x, math.max(x, y)) == x  // true\n\n// Идемпотентность: a ∨ a = a\nmath.max(x, x) == x  // true\n</code></pre>\n\n<h3>Тотально упорядоченное множество</h3>\n\n<p><code>Int</code> образует линейно упорядоченное множество:</p>\n\n<pre><code class=\"language-scala\">val x = 10\nval y = 20\n\n// Любые два элемента сравнимы (трихотомия)\n(x &lt; y) || (x == y) || (x &gt; y)  // true, точно одно условие выполнено\n\n// Транзитивность\nval a = 5\nval b = 10  \nval c = 15\n(a &lt;= b) &amp;&amp; (b &lt;= c) &amp;&amp; (a &lt;= c)  // true\n\n// Антисимметричность  \n(x &lt;= x) &amp;&amp; (x &gt;= x) &amp;&amp; (x == x)  // true\n</code></pre>\n\n<h2 style=\"text-align:center;\">Вычислительные структуры</h2>\n\n<h3>Числовые операции</h3>\n\n<p>Как числовой тип, <code>Int</code> поддерживает полный набор арифметических операций:</p>\n\n<pre><code class=\"language-scala\">val x = 42\nval y = 17\n\n// Основные операции\nx + y  // 59\nx - y  // 25  \nx * y  // 714\nx / y  // 2\nx % y  // 8\n\n// Унарные операции\n+x     // 42\n-x     // -42\nmath.abs(-x)  // 42\n\n// Преобразования типов\nx.toDouble  // 42.0\nx.toLong    // 42L\nx.toFloat   // 42.0f\n</code></pre>\n\n<h3>Битовые операции</h3>\n\n<p><code>Int</code> поддерживает полный набор битовых операций:</p>\n\n<pre><code class=\"language-scala\">val a = 12  // 1100₂\nval b = 10  // 1010₂\n\na &amp; b   // 8  (1000₂) - побитовое И\na | b   // 14 (1110₂) - побитовое ИЛИ  \na ^ b   // 6  (0110₂) - исключающее ИЛИ\n~a      // -13 - побитовое отрицание\na &lt;&lt; 1  // 24 - сдвиг влево\na &gt;&gt; 1  // 6  - арифметический сдвиг вправо\n</code></pre>\n\n<h3>Перечислимость (Enum-like поведение)</h3>\n\n<p><code>Int</code> ведет себя как перечислимый тип:</p>\n\n<pre><code class=\"language-scala\">val current = 42\n\n// Следующий/предыдущий элемент\ncurrent + 1  // 43\ncurrent - 1  // 41\n\n// Генерация последовательностей\n1 to 5         // Range(1, 2, 3, 4, 5)\n5 until 10     // Range(5, 6, 7, 8, 9)  \n0 to 10 by 2   // Range(0, 2, 4, 6, 8, 10)\n\n// Конечные границы\nInt.MaxValue  // 2147483647\nInt.MinValue  // -2147483648\n</code></pre>\n\n<h2 style=\"text-align:center;\">Системные свойства</h2>\n\n<h3>Хеширование</h3>\n\n<p><code>Int</code> является идеальным хешируемым типом:</p>\n\n<pre><code class=\"language-scala\">val x = 42\nval y = 42\nval z = 17\n\n// Одинаковые значения → одинаковые хеши\nx.hashCode == y.hashCode  // true\n\n// Int хешируется в себя (для небольших значений)  \nx.hashCode == x  // true\n\n// Разные значения → разные хеши\nx.hashCode != z.hashCode  // true\n</code></pre>\n\n<h3>Сериализация</h3>\n\n<p><code>Int</code> естественно сериализуется в различные представления:</p>\n\n<pre><code class=\"language-scala\">val number = 42\n\n// Текстовые представления\nnumber.toString        // \"42\"\nnumber.toBinaryString  // \"101010\"  \nnumber.toOctalString   // \"52\"\nnumber.toHexString     // \"2a\"\n\n// Обратное преобразование\n\"42\".toInt == number  // true\n\n// Парсинг в различных системах счисления\nInteger.parseInt(\"101010\", 2) == number   // true\nInteger.parseInt(\"52\", 8) == number       // true\nInteger.parseInt(\"2a\", 16) == number      // true\n</code></pre>\n\n<h3>Валидация диапазонов</h3>\n\n<p><code>Int</code> предоставляет методы для проверки совместимости с другими числовыми типами:</p>\n\n<pre><code class=\"language-scala\">val x = 442\n\nx.isValidByte    // false (вне диапазона [-128, 127])\nx.isValidShort   // true  (в диапазоне [-32768, 32767])\nx.isValidChar    // true  (в диапазоне [0, 65535])\n\n// Граничные проверки\nx &lt; Int.MaxValue  // true\nx &gt; Int.MinValue  // true\n</code></pre>",
    "video" : null,
    "options" : {
      
    },
    "subtitle_files" : [
    ],
    "is_deprecated" : false
  },
  "name" : "text",
  "course_id" : 195883,
  "course_name" : "Функциональная Scala 3 для начинающих",
  "exported_at" : "2026-01-10T10:17:06.5928101"
}