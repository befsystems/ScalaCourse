# Материал (Шаг 1)

## Информация о шаге

- **ID шага**: 5100775
- **Позиция**: 1
- **Тип**: text
- **Курс**: Функциональная Scala 3 для начинающих
- **Экспортирован**: 2025-12-20T22:21:00.1013737

## Содержание

# Логические выражения

Логические выражения - это выражения, которые содержат **логические операторы** и вычисляются в **логическое значение** `true` или `false`.

Пример:

`val res = (1 > 2) && (2 > 3) // res имеет значение false`

Логические выражения позволяют создавать сложные условия для принятия решений, и организации выбора путей обработки данных.

Логические выражения могут быть большими, как и любые другие выражения, и содержать в себе выражения с другими типами.

`((10 - 5) >= (8 - 3)) && true || false ^ (true || false)`

Так как длинные логические выражения сложны для человеческого понимания, целесообразно ограничиваться простыми короткими выражениями, и далее их соединять в другие логические выражения с говорящими названиями.

val expr1 = 10 - 5
val expr2 = 8 - 3
val maxExpr = expr1 >= expr2 // бизнес условие 1
val condition1 = true
val condition2 = maxExpr && condition1 // бизнес условие 2
val condition3 = false
val condition4 = condition3 ^ (condition1 || condition3)// бизнес условие 3
val res = condition2 || condition4 // итоговый результат

## Преобразование логических выражений

Логические выражения можно преобразовывать в другие выражения, с тем же итоговыми результатами. Преобразования делаются по законам **алгебры логики**. Однако лучше в выражениях показывать **бизнес логику**. Это поможет вовремя заметить логические ошибки в выражении и в дальнейшем их легко дорабатывать. Не нужно будет разгадать тонкости оптимизированного выражения. Оптимизация (сокращение или упрощение) выражений, с точки зрения производительности вычислений вносят незначительный вклад, поэтому не стоит оптимизировать выражения с целью сделать их вычисления быстрее.

## Вычисление сложных выражений - метод подстановки

Для вычисления сложных выражений вручную, можно воспользоваться методом подстановки. Аналогичный подход использует и компилятор, когда строит алгоритм вычисления выражения.

На первом этапе, с учетом приоритетов, выявляются простые подвыражения, которые следует вычислить в первую очередь. И далее значения этих выражений подставляются в общее выражение.

Исходное выражение:

`((10 - 5) >= (8 - 3)) && true || false ^ (true || false)`

Вычисляем подвыражения:

10 - 5 = 5
8 - 3 = 5
true || false = true

Подставляем значения в выражение:

`(5 >= 5) && true || false ^ true`

И далее опять, вычисляем подвыражения:

5 >= 5 = true
false ^ true = true

Подставляем значения в выражение:

`true && true || true`

И далее опять, вычисляем подвыражения с учетом приоритета операций:

`true && true = true`

Подставляем значения в выражение:

`true || true`

Итоговое значение выражения: `true`

---

### Полные данные JSON

<details>
<summary>Показать JSON данные</summary>

```json
{
  "name" : "text",
  "text" : "<h1 style=\"text-align:center;\">Логические выражения</h1>\n\n<p>Логические выражения - это выражения, которые содержат <strong>логические операторы</strong> и вычисляются в <strong>логическое значение</strong> <code>true</code> или <code>false</code>.</p>\n\n<p>Пример:</p>\n\n<pre><code class=\"language-scala\">val res = (1 &gt; 2) &amp;&amp; (2 &gt; 3) // res имеет значение false</code></pre>\n\n<p>Логические выражения позволяют создавать сложные условия для принятия решений, и организации выбора путей обработки данных.</p>\n\n<p>Логические выражения могут быть большими, как и любые другие выражения, и содержать в себе выражения с другими типами.</p>\n\n<pre><code class=\"language-scala\">((10 - 5) &gt;= (8 - 3)) &amp;&amp; true || false ^ (true || false)</code></pre>\n\n<p>Так как длинные логические выражения сложны для человеческого понимания, целесообразно ограничиваться простыми короткими выражениями, и далее их соединять в другие&nbsp; логические выражения с говорящими названиями.</p>\n\n<pre><code class=\"language-scala\">val expr1 = 10 - 5\nval expr2 = 8 - 3 \nval maxExpr = expr1 &gt;= expr2  // бизнес условие 1\nval condition1 = true\nval condition2 = maxExpr &amp;&amp; condition1 // бизнес условие 2\nval condition3 = false\nval condition4 = condition3 ^ (condition1 || condition3)// бизнес условие 3\nval res = condition2 || condition4 // итоговый результат</code></pre>\n\n<h2 style=\"text-align:center;\">Преобразование логических выражений</h2>\n\n<p>Логические выражения можно преобразовывать в другие выражения, с тем же итоговыми результатами. Преобразования делаются по законам <strong>алгебры логики</strong>. Однако лучше в выражениях показывать <strong>бизнес логику</strong>. Это поможет вовремя заметить логические ошибки в выражении и в дальнейшем их легко дорабатывать. Не нужно будет разгадать тонкости оптимизированного выражения. Оптимизация (сокращение или упрощение) выражений, с точки зрения производительности вычислений вносят незначительный вклад, поэтому не стоит оптимизировать выражения с целью сделать их вычисления быстрее.</p>\n\n<h2 style=\"text-align:center;\">Вычисление сложных выражений - метод подстановки</h2>\n\n<p>Для вычисления сложных выражений вручную, можно воспользоваться методом подстановки. Аналогичный подход использует и компилятор, когда строит алгоритм вычисления выражения.</p>\n\n<p>На первом этапе, с учетом приоритетов, выявляются простые подвыражения, которые следует вычислить в первую очередь. И далее значения этих выражений подставляются в общее выражение.</p>\n\n<p>Исходное выражение:</p>\n\n<pre><code class=\"language-scala\">((10 - 5) &gt;= (8 - 3)) &amp;&amp; true || false ^ (true || false)</code></pre>\n\n<p>Вычисляем подвыражения:</p>\n\n<pre><code class=\"language-scala\">10 - 5 = 5\n8 - 3 = 5\ntrue || false = true</code></pre>\n\n<p>Подставляем значения в выражение:</p>\n\n<pre><code class=\"language-scala\">(5 &gt;= 5) &amp;&amp; true || false ^ true</code></pre>\n\n<p>И далее опять, вычисляем подвыражения:</p>\n\n<pre><code class=\"language-scala\">5 &gt;= 5 = true\nfalse ^ true = true</code></pre>\n\n<p>Подставляем значения в выражение:</p>\n\n<pre><code class=\"language-scala\">true &amp;&amp; true || true</code></pre>\n\n<p>И далее опять, вычисляем подвыражения с учетом приоритета операций:</p>\n\n<pre><code class=\"language-scala\">true &amp;&amp; true = true</code></pre>\n\n<p>Подставляем значения в выражение:</p>\n\n<pre><code class=\"language-scala\">true || true</code></pre>\n\n<p>Итоговое значение выражения: <code>true</code></p>",
  "video" : null,
  "options" : {
    
  },
  "subtitle_files" : [
  ],
  "is_deprecated" : false
}
```

</details>
