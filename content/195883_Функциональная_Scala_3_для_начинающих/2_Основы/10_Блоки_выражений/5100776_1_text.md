# Материал (Шаг 1)

## Информация о шаге

- **ID шага**: 5100776
- **Позиция**: 1
- **Тип**: text
- **Курс**: Функциональная Scala 3 для начинающих
- **Экспортирован**: 2026-01-10T10:16:58.8692863

## Содержание

# Блоки выражений

Программу можно написать используя большие выражения. Эти выражения будет сложно понимать и изменять.

Более правильный подход, это разбивать большие выражения на **именованные части**, и соединять эти части постепенно, как бы поясняя бизнес логику.

Множество небольших выражений можно группировать в **блоки**. Блок выражений формируется **фигурными** скобками. Каждое выражение должно располагаться на **отдельной **строке в блоке.

Пример:

{
val expression1 = 1 + 1
val expression2 = 2 + 2
expression1 * expression2
}

Сам блок является **выражением**. Его значением является значение **последнего выражения** в блоке.

Пример:

val res: Int = {
val expression1 = 1 + 1
val expression2 = 2 + 2
expression1 * expression2 // значение этого выражения является значением всего блока
}

// res имеет значение 8



Частая ошибка, это использовать **определение** последним выражением в блоке .

Пример:

val expression3 = {
val expression1 = 1 + 1
val expression2 = 2 + expression1 // Возможно ошибка, определение стоит последним выражением блока
}

// В expression3 будет значение () типа Unit

Скорее всего, это не тот результат блока выражений который хотелось получить. Но компилятор посчитает такой блок корректным.

Исправление:

val expression3 = {
val expression1 = 1 + 1
2 + expression1 // теперь последним стоит выражение с результатом типа Int
}

// в expression3 значение 4 типа Int.



Все имена определенные **внутри **блока **не доступны** для использования вне блока, их можно использовать **только** в самом блоке. Общее пространство имен не засоряется именами, определенными внутри блока.

Пример:

{
val expression1 = 1 + 1
val expression2 = 2 + 2
expression1 * expression2
}
expression2 // Ошибка! Имя expression2 вне блока неопределено



Все имена определенные **снаружи **блока **видны **внутри блока.

val expression4 = 4

val expression3: Int = {
val expression1 = 1 + 1
val expression2 = 2 + 2
expression1 * expression2 * expression4 // Имя expression4 доступно
}

// expression3 имеет значение 32



Если **внутри **блока определено имя, то оно **замещает** в блоке **внешнее** определенное имя.

val expression4 = 4

val expression3: Int = {
val expression1 = 1 + 1
val expression2 = 2 + 2
val expression4 = 5
expression1 * expression2 * expression4 // Используется имя expression4 определенное в предыдущей строке, а не вне блока.
}

// expression3 имеет значение 40

Количество вложенных друг в друга блоков неограниченно.

val expression5: Int = {
val expression4: Int = {
val expression3: Int = {
val expression1 = 1 + 1
val expression2 = 2 + 2
expression1 * expression2
}
expression3 + 1
}
expression4 + 2
}

// expression5 имеет значение 11

## Бесскобочный синтаксис

Если соблюдать отступы при написании блоков выражений, то фигурные скобки можно не использовать.

Пример:

val expression5: Int =
val expression4: Int =
val expression3: Int =
val expression1 = 1 + 1
val expression2 = 2 + 2
expression1 * expression2
expression3 + 1
expression4 + 2

// expression5 имеет значение 11

По величине отступа компилятор может определить в каком блоке находится выражение.

---

### Полные данные JSON

<details>
<summary>Показать JSON данные</summary>

```json
{
  "name" : "text",
  "text" : "<h1 style=\"text-align:center;\">Блоки выражений</h1>\n\n<p>Программу можно написать используя большие выражения. Эти выражения будет сложно понимать и изменять.</p>\n\n<p>Более правильный подход, это разбивать большие выражения на <strong>именованные части</strong>, и соединять эти части постепенно, как бы поясняя бизнес логику.</p>\n\n<p>Множество небольших выражений можно группировать в <strong>блоки</strong>. Блок выражений формируется <strong>фигурными</strong> скобками. Каждое выражение должно располагаться на <strong>отдельной </strong>строке в блоке.</p>\n\n<p>Пример:</p>\n\n<pre><code class=\"language-scala\">{\n    val expression1 = 1 + 1\n    val expression2 = 2 + 2\n    expression1 * expression2\n}</code></pre>\n\n<p><br>\nСам блок является <strong>выражением</strong>. Его значением является значение <strong>последнего выражения</strong> в блоке.</p>\n\n<p>Пример:</p>\n\n<pre><code class=\"language-scala\">val res: Int = {\n    val expression1 = 1 + 1\n    val expression2 = 2 + 2\n    expression1 * expression2  // значение этого выражения является значением всего блока\n} \n\n// res имеет значение 8</code></pre>\n\n<p>&nbsp;</p>\n\n<p>Частая ошибка, это использовать <strong>определение</strong> последним выражением в блоке .</p>\n\n<p>Пример:</p>\n\n<pre><code class=\"language-scala\">val expression3 = {\n    val expression1 = 1 + 1\n    val expression2 = 2 + expression1  // Возможно ошибка, определение стоит последним выражением блока\n}\n\n// В expression3 будет значение () типа Unit</code></pre>\n\n<p>Скорее всего, это не тот результат блока выражений который хотелось получить. Но компилятор посчитает такой блок корректным.</p>\n\n<p>Исправление:</p>\n\n<pre><code class=\"language-scala\">val expression3 = {\n    val expression1 = 1 + 1\n    2 + expression1 // теперь последним стоит выражение с результатом типа Int\n}\n\n// в expression3 значение 4 типа Int.</code></pre>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;Все имена определенные <strong>внутри </strong>блока <strong>не доступны</strong> для использования вне блока, их можно использовать <strong>только</strong> в самом блоке. Общее пространство имен не засоряется именами, определенными внутри блока.</p>\n\n<p>Пример:</p>\n\n<pre><code class=\"language-scala\">{\n    val expression1 = 1 + 1\n    val expression2 = 2 + 2\n    expression1 * expression2\n}\nexpression2 // Ошибка! Имя expression2 вне блока неопределено</code></pre>\n\n<p>&nbsp;</p>\n\n<p>Все имена определенные <strong>снаружи </strong>блока <strong>видны </strong>внутри блока.</p>\n\n<pre><code class=\"language-scala\">val expression4 = 4\n\nval expression3: Int = {\n    val expression1 = 1 + 1\n    val expression2 = 2 + 2\n    expression1 * expression2 * expression4 // Имя expression4 доступно\n}\n\n// expression3 имеет значение 32\n</code></pre>\n\n<p>&nbsp;</p>\n\n<p>Если <strong>внутри </strong>блока определено имя, то оно <strong>замещает</strong> в блоке <strong>внешнее</strong> определенное имя.</p>\n\n<pre><code class=\"language-scala\">val expression4 = 4\n\nval expression3: Int = {\n    val expression1 = 1 + 1\n    val expression2 = 2 + 2\n    val expression4 = 5\n    expression1 * expression2 * expression4 // Используется имя expression4 определенное в предыдущей строке, а не вне блока.\n}\n\n// expression3 имеет значение 40\n</code></pre>\n\n<p><br>\nКоличество вложенных друг в друга блоков неограниченно.</p>\n\n<pre><code class=\"language-scala\">val expression5: Int = {\n    val expression4: Int = {\n        val expression3: Int = {\n            val expression1 = 1 + 1\n            val expression2 = 2 + 2\n            expression1 * expression2\n        }\n        expression3 + 1\n    }\n    expression4 + 2\n}\n\n// expression5 имеет значение 11</code></pre>\n\n<h2 style=\"text-align:center;\">Бесскобочный синтаксис</h2>\n\n<p>Если соблюдать отступы при написании блоков выражений, то фигурные скобки можно не использовать.</p>\n\n<p>Пример:</p>\n\n<pre><code class=\"language-scala\">val expression5: Int = \n    val expression4: Int = \n        val expression3: Int = \n            val expression1 = 1 + 1\n            val expression2 = 2 + 2\n            expression1 * expression2        \n        expression3 + 1   \n    expression4 + 2\n\n\n// expression5 имеет значение 11</code></pre>\n\n<p>По величине отступа компилятор может определить в каком блоке находится выражение.</p>",
  "video" : null,
  "options" : {
    
  },
  "subtitle_files" : [
  ],
  "is_deprecated" : false
}
```

</details>
