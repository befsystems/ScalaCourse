{
  "step_id" : 8037000,
  "lesson_id" : 1229275,
  "position" : 5,
  "type" : "unknown",
  "block" : {
    "name" : "text",
    "text" : "<h1 style=\"text-align:center;\">Алгебраические свойства типа Boolean</h1>\n\n<p>Тип <code>Boolean</code> представляет собой один из самых элегантных примеров алгебраических структур в программировании. Несмотря на свою кажущуюся простоту - всего два значения <code>true</code> и <code>false</code> - Boolean демонстрирует богатый спектр математических свойств, от классической булевой алгебры до алгебраических абстракций функционального программирования.</p>\n\n<p>Boolean является фундаментальным типом в системе типов Scala, воплощающим принципы классической логики и булевой алгебры. Каждая логическая операция над Boolean реализует определенные алгебраические структуры, делая этот простой тип мощным инструментом для композиции логических вычислений.</p>\n\n<p>Изучение алгебраических свойств Boolean открывает путь к пониманию более сложных логических систем и показывает, как простейшие математические структуры лежат в основе всех вычислений.</p>\n\n<blockquote>\n<p><strong>Примечание</strong>: Данная статья является справочной, и не требует подробного изучения в данный момент. Некоторые термины и понятия могут быть неизвестными для обучающегося. Однако она содержит полезную информацию обзорного свойства для более глубокого понимания темы.</p>\n</blockquote>\n\n<h2 style=\"text-align:center;\">Булева алгебра</h2>\n\n<h3>Основные законы</h3>\n\n<p>Boolean естественным образом реализует все основные законы булевой алгебры:</p>\n\n<pre><code class=\"language-scala\">val a = true\nval b = false\n\n// Коммутативность\na &amp;&amp; b == b &amp;&amp; a  // true\na || b == b || a  // true\n\n// Ассоциативность\nval c = true\n(a &amp;&amp; b) &amp;&amp; c == a &amp;&amp; (b &amp;&amp; c)  // true\n(a || b) || c == a || (b || c)  // true\n\n// Дистрибутивность\na &amp;&amp; (b || c) == (a &amp;&amp; b) || (a &amp;&amp; c)  // true\na || (b &amp;&amp; c) == (a || b) &amp;&amp; (a || c)  // true\n</code></pre>\n\n<h3>Законы де Моргана</h3>\n\n<pre><code class=\"language-scala\">val x = true\nval y = false\n\n// Отрицание конъюнкции: ¬(a ∧ b) = ¬a ∨ ¬b\n!(x &amp;&amp; y) == (!x || !y)  // true\n\n// Отрицание дизъюнкции: ¬(a ∨ b) = ¬a ∧ ¬b  \n!(x || y) == (!x &amp;&amp; !y)  // true\n</code></pre>\n\n<h3>Законы поглощения</h3>\n\n<pre><code class=\"language-scala\">val a = true\nval b = false\n\n// a ∨ (a ∧ b) = a\na || (a &amp;&amp; b) == a  // true\n\n// a ∧ (a ∨ b) = a\na &amp;&amp; (a || b) == a  // true\n</code></pre>\n\n<h2 style=\"text-align:center;\">Моноидальные структуры</h2>\n\n<h3>Конъюнктивный моноид (AND)</h3>\n\n<p>Boolean с операцией <code>&amp;&amp;</code> образует моноид:</p>\n\n<pre><code class=\"language-scala\">// Нейтральный элемент: true\nval x = true\nval y = false\n\nx &amp;&amp; true == x  // true\ntrue &amp;&amp; x == x  // true\ny &amp;&amp; true == y  // true\n\n// Ассоциативность\nval a = true\nval b = false  \nval c = true\n(a &amp;&amp; b) &amp;&amp; c == a &amp;&amp; (b &amp;&amp; c)  // true, оба равны false\n</code></pre>\n\n<p>Структура <code>(Boolean, &amp;&amp;, true)</code> является коммутативным моноидом, где <code>true</code> служит нейтральным элементом.</p>\n\n<h3>Дизъюнктивный моноид (OR)</h3>\n\n<p>Параллельно существует дизъюнктивная моноидальная структура:</p>\n\n<pre><code class=\"language-scala\">// Нейтральный элемент: false\nval x = true\nval y = false\n\nx || false == x  // true\nfalse || x == x  // true\ny || false == y  // true\n\n// Ассоциативность\nval a = false\nval b = true\nval c = false\n(a || b) || c == a || (b || c)  // true, оба равны true\n</code></pre>\n\n<h3>XOR моноид</h3>\n\n<p>Исключающее ИЛИ также образует моноид:</p>\n\n<pre><code class=\"language-scala\">// Нейтральный элемент: false\nval x = true\nval y = false\n\nx ^ false == x  // true (x != false)\nfalse ^ x == x  // true\n\n// Ассоциативность и самообратность\nval a = true\nval b = false\nval c = true\n(a ^ b) ^ c == a ^ (b ^ c)  // true\na ^ a == false  // true (каждый элемент обратен сам себе)\n</code></pre>\n\n<h2 style=\"text-align:center;\">Решетка (Boolean Lattice)</h2>\n\n<p>Boolean образует полную булеву решетку:</p>\n\n<pre><code class=\"language-scala\">val a = true\nval b = false\n\n// Join (supremum) - дизъюнкция\na || b  // true (наибольший из a, b в порядке false &lt; true)\n\n// Meet (infimum) - конъюнкция\na &amp;&amp; b  // false (наименьший из a, b)\n\n// Дополнение (complement)\n!a  // false\n!b  // true\n\n// Законы решетки:\n// Коммутативность\na || b == b || a  // true\na &amp;&amp; b == b &amp;&amp; a  // true\n\n// Ассоциативность\nval c = false\n(a || b) || c == a || (b || c)  // true\n(a &amp;&amp; b) &amp;&amp; c == a &amp;&amp; (b &amp;&amp; c)  // true\n\n// Идемпотентность\na || a == a  // true\na &amp;&amp; a == a  // true\n\n// Поглощение\na || (a &amp;&amp; b) == a  // true\na &amp;&amp; (a || b) == a  // true\n</code></pre>\n\n<h2 style=\"text-align:center;\">Дополняемая решетка</h2>\n\n<p>Boolean является дополняемой решеткой с отрицанием:</p>\n\n<pre><code class=\"language-scala\">val a = true\nval b = false\n\n// Каждый элемент имеет дополнение\n!(!a) == a  // true (инволютивность)\n!(!b) == b  // true\n\n// Законы дополнения\na &amp;&amp; (!a) == false  // true (закон противоречия)\na || (!a) == true   // true (закон исключенного третьего)\n\n// Дополнение к нейтральным элементам\n!true == false   // true\n!false == true   // true\n</code></pre>\n\n<h2 style=\"text-align:center;\">Группоподобные структуры</h2>\n\n<h3>Группа с XOR</h3>\n\n<p>Boolean с операцией XOR образует абелеву группу:</p>\n\n<pre><code class=\"language-scala\">// Нейтральный элемент\nval identity = false\nval a = true\nval b = false\n\na ^ identity == a  // true\nb ^ identity == b  // true\n\n// Каждый элемент обратен сам себе\na ^ a == identity  // true\nb ^ b == identity  // true\n\n// Коммутативность (абелева группа)\na ^ b == b ^ a  // true\n\n// Ассоциативность\nval c = true\n(a ^ b) ^ c == a ^ (b ^ c)  // true\n</code></pre>\n\n<h2 style=\"text-align:center;\">Кольцеподобные структуры</h2>\n\n<p>Boolean можно рассматривать как кольцо с двумя элементами:</p>\n\n<pre><code class=\"language-scala\">// Кольцо (Z₂, +, ·) где + это XOR, · это AND\nval zero = false  // аддитивный нейтраль\nval one = true    // мультипликативный нейтраль\n\nval a = true\nval b = false\n\n// Аддитивная группа (XOR)\na ^ zero == a  // true\na ^ a == zero  // true (самообратность)\n\n// Мультипликативный моноид (AND)  \na &amp;&amp; one == a   // true\nb &amp;&amp; one == b   // true\n\n// Дистрибутивность: a ∧ (b ⊕ c) = (a ∧ b) ⊕ (a ∧ c)\nval c = true\na &amp;&amp; (b ^ c) == (a &amp;&amp; b) ^ (a &amp;&amp; c)  // true\n\n// Аннигиляция\na &amp;&amp; zero == zero  // true\nb &amp;&amp; zero == zero  // true\n</code></pre>\n\n<h2 style=\"text-align:center;\">Упорядоченная структура</h2>\n\n<p>Boolean образует тотально упорядоченное множество:</p>\n\n<pre><code class=\"language-scala\">// Частичный порядок: false &lt; true\nval f = false\nval t = true\n\nf &lt;= t  // true\nf &lt; t   // true  \nt &gt;= f  // true\nt &gt; f   // true\n\n// Антисимметричность\nf &lt;= f &amp;&amp; f &gt;= f &amp;&amp; f == f  // true\nt &lt;= t &amp;&amp; t &gt;= t &amp;&amp; t == t  // true\n\n// Транзитивность (тривиальна для двухэлементного множества)\nf &lt;= f &amp;&amp; f &lt;= t &amp;&amp; f &lt;= t  // true\n\n// Минимальный и максимальный элементы\nf &lt;= t  // false - минимальный элемент\nt &gt;= f  // true - максимальный элемент\n</code></pre>\n\n<h2 style=\"text-align:center;\">Функциональные структуры</h2>\n\n<h3>Сравнение и равенство</h3>\n\n<pre><code class=\"language-scala\">val a = true\nval b = false\nval c = true\n\n// Равенство\na == c  // true\na == b  // false\nb == b  // true\n\n// Неравенство\na != b  // true\na != c  // false\n\n// Сравнение (false &lt; true)\nb &lt; a   // true\na &gt; b   // true\nb &lt;= a  // true\na &gt;= b  // true\n</code></pre>\n\n<h3>Условная логика</h3>\n\n<pre><code class=\"language-scala\">val condition = true\nval alternative = false\n\n// Импликация (a → b эквивалентно ¬a ∨ b)\ndef implies(a: Boolean, b: Boolean): Boolean = !a || b\n\nimplies(true, true)    // true\nimplies(true, false)   // false  \nimplies(false, true)   // true\nimplies(false, false)  // true\n\n// Эквивалентность (a ↔ b эквивалентно (a → b) ∧ (b → a))\ndef equivalent(a: Boolean, b: Boolean): Boolean = (a == b)\n\nequivalent(true, true)    // true\nequivalent(false, false)  // true\nequivalent(true, false)   // false\n</code></pre>\n\n<h2 style=\"text-align:center;\">Идемпотентные структуры</h2>\n\n<p>Boolean демонстрирует идемпотентность в нескольких операциях:</p>\n\n<pre><code class=\"language-scala\">val a = true\nval b = false\n\n// Идемпотентность OR\na || a == a  // true  \nb || b == b  // true\n\n// Идемпотентность AND\na &amp;&amp; a == a  // true\nb &amp;&amp; b == b  // true\n\n// НЕ идемпотентность XOR\na ^ a == false  // true (не равно a)\nb ^ b == false  // true (не равно b)\n</code></pre>\n\n<h2 style=\"text-align:center;\">Инволютивные свойства</h2>\n\n<pre><code class=\"language-scala\">val a = true\nval b = false\n\n// Отрицание - инволюция\n!(!a) == a  // true\n!(!b) == b  // true\n\n// Двойное отрицание возвращает исходное значение\ndef doubleNegate(x: Boolean): Boolean = !(!x)\ndoubleNegate(a) == a  // true\ndoubleNegate(b) == b  // true\n</code></pre>\n\n<h2 style=\"text-align:center;\">Системные свойства</h2>\n\n<h3>Хеширование</h3>\n\n<pre><code class=\"language-scala\">val t = true\nval f = false\n\n// Стабильное хеширование\nt.hashCode == t.hashCode  // true\nf.hashCode == f.hashCode  // true\n\n// Разные значения → разные хеши  \nt.hashCode != f.hashCode  // true\n\n// Boolean хешируется предсказуемо\ntrue.hashCode   // 1231\nfalse.hashCode  // 1237\n</code></pre>\n\n<h3>Сериализация</h3>\n\n<pre><code class=\"language-scala\">val truthValue = true\nval falseValue = false\n\n// Строковое представление\ntruthValue.toString   // \"true\"\nfalseValue.toString   // \"false\"\n\n// Парсинг из строк\n\"true\".toBoolean == truthValue    // true\n\"false\".toBoolean == falseValue   // true\n\n// Регистронезависимый парсинг\n\"TRUE\".toLowerCase.toBoolean == truthValue   // true\n\"False\".toLowerCase.toBoolean == falseValue  // true\n</code></pre>\n\n<h3>Численные преобразования</h3>\n\n<pre><code class=\"language-scala\">val t = true\nval f = false\n\n// В численные типы (условно)\nif (t) 1 else 0  // 1\nif (f) 1 else 0  // 0\n\n// Сравнение как порядковые значения\nt.compareTo(f)   // 1 (true &gt; false)\nf.compareTo(t)   // -1 (false &lt; true)  \nt.compareTo(t)   // 0 (true == true)\n</code></pre>\n\n<h2>Комбинаторные структуры</h2>\n\n<pre><code class=\"language-scala\">// Булевы функции от n переменных\ndef nand(a: Boolean, b: Boolean): Boolean = !(a &amp;&amp; b)\ndef nor(a: Boolean, b: Boolean): Boolean = !(a || b)  \ndef xnor(a: Boolean, b: Boolean): Boolean = !(a ^ b)\n\n// Проверка полноты базиса\nval a = true\nval b = false\n\n// NAND - функционально полный базис\nnand(nand(a, a), nand(b, b)) == a || b           // true (OR через NAND)\nnand(nand(a, b), nand(a, b)) == a &amp;&amp; b           // true (AND через NAND)\nnand(a, a) == !a                                 // true (NOT через NAND)\n</code></pre>",
    "video" : null,
    "options" : {
      
    },
    "subtitle_files" : [
    ],
    "is_deprecated" : false
  },
  "name" : "text",
  "course_id" : 195883,
  "course_name" : "Функциональная Scala 3 для начинающих",
  "exported_at" : "2026-01-10T10:17:09.5971548"
}