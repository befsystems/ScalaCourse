{
  "step_id" : 5077216,
  "lesson_id" : 1221091,
  "position" : 5,
  "type" : "unknown",
  "block" : {
    "name" : "text",
    "text" : "<h1 style=\"text-align: center;\">Проблемы функционального подхода</h1>\n\n<p>Несмотря на множество преимуществ, функциональный подход имеет свои проблемы, которые сдерживают его использование.</p>\n\n<p><strong>Прикладное программирование - это не теоретическая математика</strong></p>\n\n<ul>\n\t<li><strong>Проблема</strong>: Невозможно создать <strong>полные и идеальные</strong> математические модели для реального мира. Соответственно, и используя функциональный подход невозможно <strong>идеально </strong>описать процессы с этими моделями, как бы этого не хотелось. Можно только приближаться к идеалу, используя различные методики, или заранее известные допущения (упрощения). Проблема выбора <strong>разумных допущений </strong>одна из <strong>острейших </strong>именно при функциональном подходе, так как это влияет на его идеалы и преимущества.</li>\n</ul>\n\n<p><strong>Провоцируемая сложность</strong></p>\n\n<ul>\n\t<li>Функциональный подход позволяет радикально <strong>снизить </strong>сложность объемных программ, но и одновременно провоцирует желание добавить точности моделям и процессам, что оборачивается итоговым <strong>увеличением </strong>сложности.</li>\n</ul>\n\n<p><strong>Снижение скорости выполнения программы:</strong></p>\n\n<ul>\n\t<li><strong>Проблема:</strong>  Функциональный подход <strong>не идеально</strong> стыкуется с аппаратными платформами, для которых родным является императивный подход. Также требуется больший объем памяти. Однако за последнее время аппаратная производительность вырастала настолько существенно, что программы уже <strong>могут позволить себе</strong> быть не сильно оптимальными к железу. На первое место выходит проблема <strong>сложности</strong> <strong>и надежности</strong> программ.</li>\n</ul>\n\n<p><strong>Сложные компиляторы:</strong></p>\n\n<ul>\n\t<li><strong>Проблема:</strong>  Функциональный подход требует сложных компиляторов, которые производят сложные проверки и радикальные преобразования кода программ. Сложные компиляторы требуют больших усилий при их создании и модификациях. Это замедляет развитие языка и реализацию пожеланий разработчиков. Также, сложные компиляторы работают несколько дольше при сборке программ.</li>\n</ul>\n\n<p><strong>Сложность интеграции со сторонними библиотеками:</strong></p>\n\n<ul>\n\t<li><strong>Проблема</strong>: Не все существующие библиотеки легко встраиваются в функциональные приложения. Некоторые сторонние библиотеки реализованы в императивном стиле и требуют <strong>дополнительного сопряжения</strong> с функциональным кодом программы.</li>\n</ul>\n\n<p><strong>Сложность в обучении:</strong></p>\n\n<ul>\n\t<li><strong>Проблема:</strong> Для разработчиков, привыкших к императивному стилю программирования, функциональный подход может быть сложным в понимании. Концепции, такие как неизменяемость данных, могут потребовать времени для освоения. Кроме того, функциональный стиль насыщен неадаптированными терминами с разных математических наук, а математикам хуже всего удается придумывать хорошие названия. Есть проблемы с качественным массовым преподаванием функциональных дисциплин.</li>\n\t<li><strong>Примечание:</strong> Сообщества функциональных программистов - самые молчаливые и дружелюбные сообщества программистов.</li>\n</ul>",
    "video" : null,
    "options" : {
      
    },
    "subtitle_files" : [
    ],
    "is_deprecated" : false
  },
  "name" : "text",
  "course_id" : 195883,
  "course_name" : "Функциональная Scala 3 для начинающих",
  "exported_at" : "2026-01-10T10:16:56.7162648"
}