# Материал (Шаг 1)

## Информация о шаге

- **ID шага**: 5100779
- **Позиция**: 1
- **Тип**: text
- **Курс**: Функциональная Scala 3 для начинающих
- **Экспортирован**: 2025-12-20T22:21:46.1027272

## Содержание

# Кортеж

**Кортеж **(tuple) представляет собой неизменяемый, упорядоченный набор значений различных типов.

## Создание кортежа

Кортеж создается из перечня значений, указанных через запятую, и заключенных в круглые скобки.

Пример создания кортежа:

`(1, "s", 3L, 'a')`

При этом тип данного кортежа будет выведен как:

`(Int, String, Long, Char)`

**Тип кортежа** образуется как комбинация всех **типов значений, их положения и количества**.

Например, это разные типы кортежей:

(Int, String, Long, Char)
(Long, String, Int, Char)

**Количество **элементов кортежа может быть любым, от **0 до бесконечности**. Но способ создания кортежа отличается в зависимости от количества элементов.

EmptyTuple // создание пустого кортежа
Tuple() // создание пустого кортежа
Tuple('a') // создание кортежа с одним значением
('a', 'b') // создание кортежа с двумя значениями
'a' -> 'b' // создание кортежа только с двумя значениями
('a', 8, 'c') // создание кортежа с тремя значениями (аналогично до 22 значений)
TupleXXL(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23) // создание кортежа свыше 22 значений

Обычно используются кортежи с количеством значений от **2 до 22**. Остальные размеры кортежей используются крайне редко, и обеспечивают математическую полноту типа. Могут пригодится при операциях получения кортежа из коллекций значений.

Кортеж является сущностью **первого класса** (first-class citizens), то есть является **значением**, и может быть использован везде, где могут использоваться значения.

Например присвоить имя значению кортежа:

`val tuple4: (Int, String, Long, Char) = (1, "s", 2L, 'a')`

## **Извлечение** элементов кортежа

Извлечение элементов кортежа можно выполнить по номеру позиции элемента:

val tuple4 = (1, "s", 2L, 'a') // Создание кортежа c четырьмя элементами
val el1: Int = tuple4._1 // Извлечение из кортежа элемента 1 с первой позиции
val el2: String = tuple4._2 // Извлечение из кортежа элемента 2 со второй позиции
val el3: Long = tuple4._3 // Извлечение из кортежа элемента 3 с третьей позиции
val el4: Char = tuple4._4 // Извлечение из кортежа элемента 4 с четвертой позиции
val res = el1 + el2 + el3 + el4 // Использование извлеченных элементов кортежа. Результат - строка "1s2a"

Нумерация элементов начинается с 1.

Или с помощью индекса:

val tuple4 = (1, "s", 2L, 'a') // Создание кортежа
val el1: Int = tuple4(0) // Извлечение из кортежа элемента 1 по индексу 0
val el2: String = tuple4(1) // Извлечение из кортежа элемента 2 по индексу 1
val el3: Long = tuple4(2) // Извлечение из кортежа элемента 3 по индексу 2
val el4: Char = tuple4(3) // Извлечение из кортежа элемента 4 по индексу 3
val res = el1 * el3 * el4 + el2 // Использование извлеченных элементов кортежа. Результат - строка "194s"

Индекс элементов начинается с 0.

## Декомпозиция кортежа

Можно получить все значения из кортежа сразу в одной строке:

val tuple4 = (1, "s", 2L, 'a') // Создание кортежа
val (el1, el2, el3, el4) = tuple4 // Декомпозиция кортежа на составные элементы
val res = el1 / el3 / el4 + el2 // Использование извлеченных элементов кортежа. Результат - строка "0s"

Такой прием извлечения элементов называется **декомпозицией** кортежа. Список имен извлекаемых значений нужно заключить в круглые скобки, количество имен должно строго соответствовать количеству элементов кортежа. Извлечение элементов кортежа в имена будет произведено по порядку их расположения в кортеже. Имена значений в списке могут быть произвольными, важен только их порядок.

При декомпозиции можно указать типы извлекаемых элементов, тогда будет дополнительно произведена проверка соответствия типов этих элементов:

val tuple4 = (1, "s", 2L, 'a') // Создание кортежа
val (a: Int, b: String, c: Long, d: Char) = tuple4 // Декомпозиция кортежа на составные элементы
val res = a / c / d + b // Использование извлеченных элементов кортежа. Результат - строка "0s"

Если при декомпозиции часть элементов не нужна, то вместо названия значения можно указать знак подстановки _ , но обязательно создать список для всех элементов, в порядке их нахождения в кортеже.

val tuple4 = (1, "s", 2L, 'a') // Создание кортежа
val (el1, _, el3, _) = tuple4 // Декомпозиция кортежа на составные элементы
val res = el1 / el3 // Использование извлеченных элементов кортежа. Результат - значение 0

Символ _ в перечне названий элементов указывает на то, что соответствующий элемент кортежа пропускается.

##  Вложенные кортежи

Элементами кортежа могут быть другие кортежы:

`val tuple3 = (1, "s", (2L, 'a')) // во внешнем кортеже три элемента, последний элемент - кортеж из двух элементов`

Соответственно, возможна  вложенная декомпозиция кортежей:

val tuple3 = (1, "s", (2L, 'a')) // Создание кортежа с элементом кортежем
val (el11, el12, (el21, el22)) = tuple3 // Вложенная декомпозиция кортежей
val res = el11 + el12 + el21 + el22 // Использование извлеченных элементов кортежей. Результат - строка "1s2a"

## Назначение кортежей в Scala

Несмотря на большую математическую важность кортежей, в Scala кортеж играет скорее вспомогательную, но частую роль.

Основное назначение кортежей в Scala - это манипуляция несколькими значениями как единым значением. Нужно рассматривать и использовать кортеж как вспомогательную временную структуру данных, предназначенную для однократной передачи значений из одной конструкции в другую.

### Преимущества

Основное преимущество кортежа в простоте его создания перед использованием. В Scala есть похожие структуры данных, но все они сложнее в создании. Появление именованных кортежей в Scala 3 значительно улучшило читаемость и удобство работы с ними.

### Недостатки

Основной недостаток обычных (неименованных) кортежей - доступ к элементам возможен только по их порядковому номеру. Нет имен элементов кортежа, и элементы можно легко перепутать, особенно в длинных кортежах. Именованные кортежи решают эту проблему. Также мало операций с кортежем в стандартной библиотеке.

---

### Полные данные JSON

<details>
<summary>Показать JSON данные</summary>

```json
{
  "name" : "text",
  "text" : "<h1 style=\"text-align:center;\">Кортеж</h1>\n\n<p><strong>Кортеж </strong>(tuple) представляет собой неизменяемый, упорядоченный набор значений различных типов.</p>\n\n<h2 style=\"text-align:center;\">Создание кортежа</h2>\n\n<p>Кортеж создается из перечня значений, указанных через запятую, и заключенных в круглые скобки.</p>\n\n<p>Пример создания кортежа:</p>\n\n<pre><code class=\"language-scala\">(1, \"s\", 3L, 'a')</code></pre>\n\n<p>При этом тип данного кортежа будет выведен как:</p>\n\n<pre><code class=\"language-scala\">(Int, String, Long, Char)</code></pre>\n\n<p><strong>Тип кортежа</strong> образуется как комбинация всех <strong>типов значений, их положения и количества</strong>.</p>\n\n<p>Например, это разные типы кортежей:</p>\n\n<pre><code class=\"language-scala\">(Int, String, Long, Char)\n(Long, String, Int, Char)</code></pre>\n\n<p><strong>Количество </strong>элементов кортежа может быть любым, от <strong>0 до бесконечности</strong>. Но способ создания кортежа отличается в зависимости от количества элементов.</p>\n\n<pre><code class=\"language-scala\">EmptyTuple // создание пустого кортежа\nTuple()    // создание пустого кортежа\nTuple('a') // создание кортежа с одним значением\n('a', 'b') // создание кортежа с двумя значениями\n'a' -&gt; 'b' // создание кортежа только с двумя значениями\n('a', 8, 'c') // создание кортежа с тремя значениями (аналогично до 22 значений)\nTupleXXL(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23) // создание кортежа свыше 22 значений\n</code></pre>\n\n<p>Обычно используются кортежи с количеством значений от <strong>2 до 22</strong>. Остальные размеры кортежей используются крайне редко, и обеспечивают математическую полноту типа. Могут пригодится при операциях получения кортежа из коллекций значений.</p>\n\n<p>Кортеж является сущностью <strong>первого класса</strong> (first-class citizens), то есть является <strong>значением</strong>, и может быть использован везде, где могут использоваться значения.</p>\n\n<p>Например присвоить имя значению кортежа:</p>\n\n<pre><code class=\"language-scala\">val tuple4: (Int, String, Long, Char) = (1, \"s\", 2L, 'a')</code></pre>\n\n<ol>\n</ol>\n\n<h2 style=\"text-align:center;\"><strong>Извлечение</strong> элементов кортежа</h2>\n\n<p>Извлечение элементов кортежа можно выполнить по номеру позиции элемента:</p>\n\n<pre><code class=\"language-scala\">val tuple4 = (1, \"s\", 2L, 'a')  // Создание кортежа c четырьмя элементами\nval el1: Int = tuple4._1        // Извлечение из кортежа элемента 1 с первой позиции\nval el2: String = tuple4._2     // Извлечение из кортежа элемента 2 со второй позиции\nval el3: Long = tuple4._3       // Извлечение из кортежа элемента 3 с третьей позиции\nval el4: Char = tuple4._4       // Извлечение из кортежа элемента 4 с четвертой позиции\nval res = el1 + el2 + el3 + el4 // Использование извлеченных элементов кортежа. Результат - строка \"1s2a\"</code></pre>\n\n<p>Нумерация элементов начинается с 1.</p>\n\n<p>Или с помощью индекса:</p>\n\n<pre><code class=\"language-scala\">val tuple4 = (1, \"s\", 2L, 'a')     // Создание кортежа\nval el1: Int = tuple4(0)           // Извлечение из кортежа элемента 1 по индексу 0\nval el2: String = tuple4(1)        // Извлечение из кортежа элемента 2 по индексу 1\nval el3: Long = tuple4(2)          // Извлечение из кортежа элемента 3 по индексу 2\nval el4: Char = tuple4(3)          // Извлечение из кортежа элемента 4 по индексу 3\nval res = el1 * el3 * el4 + el2    // Использование извлеченных элементов кортежа. Результат - строка \"194s\"</code></pre>\n\n<p>Индекс элементов начинается с 0.</p>\n\n<h2 style=\"text-align:center;\">Декомпозиция кортежа</h2>\n\n<p>Можно получить все значения из кортежа сразу в одной строке:</p>\n\n<pre><code class=\"language-scala\">val tuple4 = (1, \"s\", 2L, 'a')     // Создание кортежа\nval (el1, el2, el3, el4) = tuple4  // Декомпозиция кортежа на составные элементы\nval res = el1 / el3 / el4 + el2    // Использование извлеченных элементов кортежа. Результат - строка \"0s\"</code></pre>\n\n<p>Такой прием извлечения элементов называется <strong>декомпозицией</strong> кортежа. Список имен извлекаемых значений нужно заключить в круглые скобки, количество имен должно строго соответствовать количеству элементов кортежа. Извлечение элементов кортежа в имена будет произведено по порядку их расположения в кортеже. Имена значений в списке могут быть произвольными, важен только их порядок.</p>\n\n<p>При декомпозиции можно указать типы извлекаемых элементов, тогда будет дополнительно произведена проверка соответствия типов этих элементов:</p>\n\n<pre><code class=\"language-scala\">val tuple4 = (1, \"s\", 2L, 'a')     // Создание кортежа\nval (a: Int, b: String, c: Long, d: Char) = tuple4 // Декомпозиция кортежа на составные элементы\nval res = a / c / d + b    // Использование извлеченных элементов кортежа. Результат - строка \"0s\"</code></pre>\n\n<p>Если при декомпозиции часть элементов не нужна, то вместо названия значения можно указать знак подстановки _ , но обязательно создать список для всех элементов, в порядке их нахождения в кортеже.</p>\n\n<pre><code class=\"language-scala\">val tuple4 = (1, \"s\", 2L, 'a') // Создание кортежа\nval (el1, _, el3, _) = tuple4  // Декомпозиция кортежа на составные элементы\nval res = el1 / el3            // Использование извлеченных элементов кортежа. Результат - значение 0</code></pre>\n\n<p>Символ _ в перечне названий элементов указывает на то, что соответствующий элемент кортежа пропускается.</p>\n\n<h2 style=\"text-align:center;\"> Вложенные кортежи</h2>\n\n<p>Элементами кортежа могут быть другие кортежы:</p>\n\n<pre><code class=\"language-scala\">val tuple3 = (1, \"s\", (2L, 'a')) // во внешнем кортеже три элемента, последний элемент - кортеж из двух элементов</code></pre>\n\n<p>Соответственно, возможна  вложенная декомпозиция кортежей:</p>\n\n<pre><code class=\"language-scala\">val tuple3 = (1, \"s\", (2L, 'a'))        // Создание кортежа с элементом кортежем\nval (el11, el12, (el21, el22)) = tuple3 // Вложенная декомпозиция кортежей\nval res = el11 + el12 + el21 + el22     // Использование извлеченных элементов кортежей. Результат - строка \"1s2a\"</code></pre>\n\n<h2 style=\"text-align:center;\">Назначение кортежей в Scala</h2>\n\n<p>Несмотря на большую математическую важность кортежей, в Scala кортеж играет скорее вспомогательную, но частую роль.</p>\n\n<p>Основное назначение кортежей в Scala - это манипуляция несколькими значениями как единым значением. Нужно рассматривать и использовать кортеж как вспомогательную временную структуру данных, предназначенную для однократной передачи значений из одной конструкции в другую.</p>\n\n<h3>Преимущества</h3>\n\n<p>Основное преимущество кортежа в простоте его создания перед использованием. В Scala есть похожие структуры данных, но все они сложнее в создании. Появление именованных кортежей в Scala 3 значительно улучшило читаемость и удобство работы с ними.</p>\n\n<h3>Недостатки</h3>\n\n<p>Основной недостаток обычных (неименованных) кортежей - доступ к элементам возможен только по их порядковому номеру. Нет имен элементов кортежа, и элементы можно легко перепутать, особенно в длинных кортежах. Именованные кортежи решают эту проблему. Также мало операций с кортежем в стандартной библиотеке.</p>",
  "video" : null,
  "options" : {
    
  },
  "subtitle_files" : [
  ],
  "is_deprecated" : false
}
```

</details>
