# Материал (Шаг 1)

## Информация о шаге

- **ID шага**: 8361304
- **Позиция**: 1
- **Тип**: text
- **Курс**: Функциональная Scala 3 для начинающих
- **Экспортирован**: 2025-12-20T22:21:48.0628615

## Содержание

# Типы-произведения

**Тип-произведение** (Product type) — это **составной **тип данных, представляющий собой упорядоченный и фиксированный набор значений разных типов в единой структуре, где каждый компонент сохраняет свой тип и значение, и может быть извлечен независимо.

Название "product" происходит из **теории категорий**: если тип A содержит m значений, а тип B содержит n значений, то их произведение A × B содержит m × n возможных комбинаций. Это **декартово произведение** типов - И.

## Представители Product Types в Scala

### Кортежи (Tuples)

**Назначение:** быстрое создание временных структур данных без объявления типа.

// Создание кортежа
val point: (Int, Int) = (10, 20)
val person = ("Alice", 30, "Engineer")

**Когда использовать:**

- Для возврата нескольких значений из функции

- Временные структуры данных

- Группировка данных в map/groupBy

### Конструкция Case Class

**Назначение:** моделирование данных предметной области с именованными полями.

case class User(id: Long, name: String, email: String, active: Boolean)

val user = User(1, "Alice", "alice@example.com", true)

**Когда использовать:**

- Моделирование бизнес-данных (domain model)

- Когда важна читаемость и самодокументирование кода

- Когда нужна семантика имён полей

- Публичные API

- Когда структура устойчива

## Назначение типов-произведений

**1. Моделирование составных данных**

Product types позволяют точно моделировать реальные сущности, которые имеют несколько независимых характеристик:

// Точка имеет координаты x И y
case class Point(x: Double, y: Double)

// Пользователь имеет имя И email И возраст
case class User(name: String, email: String, age: Int)

**2. Гарантия полноты данных**

Например тип `(String, Int, Boolean)` гарантирует, что значение содержит **ВСЕ три** компонента. Невозможно создать "частичное" значение.

// Определение типа-произведения (tuple)
type Person = (String, Int, Boolean)

// ✅ Корректное создание — все три компонента присутствуют
val validPerson: Person = ("Alice", 30, true)

// ❌ Это не скомпилируется — недостаточно компонентов
// val invalidPerson: Person = ("Bob", 25)
// Found: (String, Int)
// Required: (String, Int, Boolean)

 Безопасный рефакторинг:

// Изменили структуру:
case class User(name: String, email: String) // убрали age

// Компилятор сразу покажет ВСЕ места, где использовался age:
def greet(user: User) = s"${user.name}, ${user.age}" // ❌ Ошибка компиляции!

**3. Типобезопасность**

Product types сохраняют тип каждого компонента, предотвращая ошибки:

// ❌ Это не скомпилируется — неправильный тип компонента
// val invalidPerson: Person = ("Charlie", "35", false)
// Found: (String, String, Boolean)
// Required: (String, Int, Boolean)

// ❌ Это не скомпилируется — неправильный порядок
// val invalidPerson: Person = (30, "David", true)
// Found: (Int, String, Boolean)
// Required: (String, Int, Boolean)

## Когда НЕ использовать Product Types

Product types не подходят когда:

- **Нужны взаимоисключающие альтернативы**: используйте Sum Types для моделирования "ИЛИ"

- **Много опциональных полей**: часто признак того, что нужен Sum Type с разными вариантами

- **Булевы флаги описывают состояние**: замените на Sum Type с явными состояниями

- **Данные имеют разную структуру по типу**: используйте Sum Type с разными case классами

- **Структура должна расширяться пользователями**: используйте trait вместо case class

##  

 

##  

##  

|   |   |   |   |
| --- | --- | --- | --- |
|   |   |   |   |
|   |   |   |   |
|   |   |   |   |
|   |   |   |   |
|   |   |   |   |
|   |   |   |   |
|   |   |   |   |
|   |   |   |   |
|   |   |   |   |

---

### Полные данные JSON

<details>
<summary>Показать JSON данные</summary>

```json
{
  "name" : "text",
  "text" : "<h1 style=\"text-align:center;\">Типы-произведения</h1>\n\n<p><strong>Тип-произведение</strong> (Product type) — это <strong>составной </strong>тип данных, представляющий собой упорядоченный и фиксированный набор значений разных типов в единой структуре, где каждый компонент сохраняет свой тип и значение, и может быть извлечен независимо.</p>\n\n<p>Название \"product\" происходит из <strong>теории категорий</strong>: если тип A содержит m значений, а тип B содержит n значений, то их произведение A × B содержит m × n возможных комбинаций. Это <strong>декартово произведение</strong> типов - И.</p>\n\n<h2 style=\"text-align:center;\">Представители Product Types в Scala</h2>\n\n<h3 style=\"text-align:center;\">Кортежи (Tuples)</h3>\n\n<p><strong>Назначение:</strong> быстрое создание временных структур данных без объявления типа.</p>\n\n<pre><code class=\"language-scala\">// Создание кортежа\nval point: (Int, Int) = (10, 20)\nval person = (\"Alice\", 30, \"Engineer\")</code></pre>\n\n<p><strong>Когда использовать:</strong></p>\n\n<ul>\n\t<li>Для возврата нескольких значений из функции</li>\n\t<li>Временные структуры данных</li>\n\t<li>Группировка данных в map/groupBy</li>\n</ul>\n\n<h3 style=\"text-align:center;\">Конструкция Case Class</h3>\n\n<p><strong>Назначение:</strong> моделирование данных предметной области с именованными полями.</p>\n\n<pre><code class=\"language-scala\">case class User(id: Long, name: String, email: String, active: Boolean)\n\nval user = User(1, \"Alice\", \"alice@example.com\", true)\n</code></pre>\n\n<p><strong>Когда использовать:</strong></p>\n\n<ul>\n\t<li>Моделирование бизнес-данных (domain model)</li>\n\t<li>Когда важна читаемость и самодокументирование кода</li>\n\t<li>Когда нужна семантика имён полей</li>\n\t<li>Публичные API</li>\n\t<li>Когда структура устойчива</li>\n</ul>\n\n<h2 style=\"text-align:center;\">Назначение типов-произведений</h2>\n\n<p><strong>1. Моделирование составных данных</strong></p>\n\n<p>Product types позволяют точно моделировать реальные сущности, которые имеют несколько независимых характеристик:</p>\n\n<pre><code class=\"language-scala\">// Точка имеет координаты x И y\ncase class Point(x: Double, y: Double)\n\n// Пользователь имеет имя И email И возраст\ncase class User(name: String, email: String, age: Int)\n</code></pre>\n\n<p><strong>2. Гарантия полноты данных</strong></p>\n\n<p>Например тип <code>(String, Int, Boolean)</code> гарантирует, что значение содержит <strong>ВСЕ три</strong> компонента. Невозможно создать \"частичное\" значение.</p>\n\n<pre><code class=\"language-scala\">// Определение типа-произведения (tuple)\ntype Person = (String, Int, Boolean)\n\n// ✅ Корректное создание — все три компонента присутствуют\nval validPerson: Person = (\"Alice\", 30, true)\n\n// ❌ Это не скомпилируется — недостаточно компонентов\n// val invalidPerson: Person = (\"Bob\", 25)\n// Found:    (String, Int)\n// Required: (String, Int, Boolean)</code></pre>\n\n<p> Безопасный рефакторинг:</p>\n\n<pre><code class=\"language-scala\">// Изменили структуру:\ncase class User(name: String, email: String) // убрали age\n\n// Компилятор сразу покажет ВСЕ места, где использовался age:\ndef greet(user: User) = s\"${user.name}, ${user.age}\" // ❌ Ошибка компиляции!\n</code></pre>\n\n<p><strong>3. Типобезопасность</strong></p>\n\n<p>Product types сохраняют тип каждого компонента, предотвращая ошибки:</p>\n\n<pre><code class=\"language-scala\">// ❌ Это не скомпилируется — неправильный тип компонента\n// val invalidPerson: Person = (\"Charlie\", \"35\", false)\n// Found:    (String, String, Boolean)\n// Required: (String, Int, Boolean)\n\n// ❌ Это не скомпилируется — неправильный порядок\n// val invalidPerson: Person = (30, \"David\", true)\n// Found:    (Int, String, Boolean)\n// Required: (String, Int, Boolean)\n</code></pre>\n\n<h2 style=\"text-align:center;\">Когда НЕ использовать Product Types</h2>\n\n<p>Product types не подходят когда:</p>\n\n<ol>\n\t<li><strong>Нужны взаимоисключающие альтернативы</strong>: используйте Sum Types для моделирования \"ИЛИ\"</li>\n\t<li><strong>Много опциональных полей</strong>: часто признак того, что нужен Sum Type с разными вариантами</li>\n\t<li><strong>Булевы флаги описывают состояние</strong>: замените на Sum Type с явными состояниями</li>\n\t<li><strong>Данные имеют разную структуру по типу</strong>: используйте Sum Type с разными case классами</li>\n\t<li><strong>Структура должна расширяться пользователями</strong>: используйте trait вместо case class</li>\n</ol>\n\n<h2 style=\"text-align:center;\"> </h2>\n\n<p> </p>\n\n<ul>\n</ul>\n\n<h2 style=\"text-align:center;\"> </h2>\n\n<ul>\n</ul>\n\n<h2 style=\"text-align:center;\"> </h2>\n\n<table>\n\t<thead>\n\t\t<tr>\n\t\t\t<th> </th>\n\t\t\t<th> </th>\n\t\t\t<th> </th>\n\t\t\t<th> </th>\n\t\t</tr>\n\t</thead>\n\t<tbody>\n\t\t<tr>\n\t\t\t<td> </td>\n\t\t\t<td> </td>\n\t\t\t<td> </td>\n\t\t\t<td> </td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td> </td>\n\t\t\t<td> </td>\n\t\t\t<td> </td>\n\t\t\t<td> </td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td> </td>\n\t\t\t<td> </td>\n\t\t\t<td> </td>\n\t\t\t<td> </td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td> </td>\n\t\t\t<td> </td>\n\t\t\t<td> </td>\n\t\t\t<td> </td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td> </td>\n\t\t\t<td> </td>\n\t\t\t<td> </td>\n\t\t\t<td> </td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td> </td>\n\t\t\t<td> </td>\n\t\t\t<td> </td>\n\t\t\t<td> </td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td> </td>\n\t\t\t<td> </td>\n\t\t\t<td> </td>\n\t\t\t<td> </td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td> </td>\n\t\t\t<td> </td>\n\t\t\t<td> </td>\n\t\t\t<td> </td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td> </td>\n\t\t\t<td> </td>\n\t\t\t<td> </td>\n\t\t\t<td> </td>\n\t\t</tr>\n\t</tbody>\n</table>",
  "video" : null,
  "options" : {
    
  },
  "subtitle_files" : [
  ],
  "is_deprecated" : false
}
```

</details>
