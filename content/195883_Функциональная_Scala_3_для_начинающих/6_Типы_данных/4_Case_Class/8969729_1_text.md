# Материал (Шаг 1)

## Информация о шаге

- **ID шага**: 8969729
- **Позиция**: 1
- **Тип**: text
- **Курс**: Функциональная Scala 3 для начинающих
- **Экспортирован**: 2025-12-20T22:21:45.0481698

## Содержание

# Конструкция Case Class

Case Class - самая часто используемая конструкция для создания сложных типов данных вида Product type. С помощью нее создаются модели предметной области, API, Data Transfer Objects.

Как и все другие **функциональные типы** данных, конструкция обеспечивает создание и работу с **неизменяемыми **(immutable) данными (значениями).

Конструкция позволяет использовать её в качестве **основы, **для создания более сложных абстрактных и рекурсивных типов данных, которые мы рассмотрим позже.

## Синтаксис

### Определение типа данных на основе case class

// Базовый синтаксис
case class TypeName(field1: String, field2: Int)
// case class - ключевые слова
// TypeName - произвольное имя типа данных
// field1, field1 - имена произвольных полей - элементов составного значения
// String, Int - типы произвольных полей

// С полями по умолчанию
case class User(
id: Long,
name: String,
email: String,
active: Boolean = true
)

// С несколькими списками полей
case class Request(method: String, path: String)(header: String)

### Создание значения типа

case class Point(x: Int, y: Int)

// Создание
val p1 = Point(10, 20)

// С именованными полями
val p2 = Point(x = 10, y = 20)
val p3 = Point(y = 20, x = 10) // Порядок не важен

// Со значениями по умолчанию
case class Config(host: String, port: Int = 8080, timeout: Int = 5000)

val c1 = Config("localhost") // port=8080, timeout=5000
val c2 = Config("localhost", 9000) // timeout=5000
val c3 = Config("localhost", timeout = 3000) // port=8080, timeout=3000
val c4 = Config(host = "localhost", port = 9000, timeout = 3000)

### Доступ к полям

case class User(id: Long, name: String, email: String)

val user = User(1, "Alice", "alice@example.com")

// Доступ к полям
user.id // 1
user.name // Alice
user.email // alice@example.com

// Поля неизменяемы
// user.name = "Bob" // ❌ Ошибка компиляции: reassignment to val

### Вложенные сложные типы

case class Address(street: String, city: String, zipCode: String)
case class Person(name: String, age: Int, address: Address)

val address = Address("5th Avenue", "New York", "10001")
val person = Person("Alice", 30, address)

// Доступ к вложенным полям
person.address.city // New York
person.address.zipCode // 10001

// Создание с вложенной структурой inline
val person2 = Person(
"Bob",
25,
Address("Main Street", "Boston", "02101")
)

## Декомпозиция

**Декомпозиция** — это извлечение данных из case class обратно в отдельные значения. Если конструктор case class **композирует** (точнее агрегирует) данные в единый объект, то декомпозиция делает **обратное** — разбирает объект на составные части. Это две стороны одной медали, автоматически предоставляемые компилятором. Case class автоматически поддерживает декомпозицию через операцию **unapply**.

case class User(name: String, age: Int)

val user = User("Anna", 25)

// Полная декомпозиция
val User(nameValue, ageValue) = user
nameValue // "Anna"
ageValue // 25

// Псевдо частичная декомпозиция (просто не используем поле)
val User(name = _, age = ageValue2) = user

// Полная декомпозиция в Pattern matching
user match {
case User(name, age) => println(s"$name is $age years old")
}

// Частичная декомпозиция в Pattern matching
user match {
case User(name = n) => println(s"$n ") // возраст игнорируется
}

// Сопостовление полей и получение недекомпозированного значения
val age = 25
user match {
case originalUser @ User(name = "Anna", age = `age`) => println(s"$originalUser") // User(Anna,25)
}

## Case Class vs Class

Можно заметить, что конструкции `case class` и `class` очень похожи по синтаксису и использованию. Но их следует использовать только по прямому назначению, и не путать.

**Case Class** — это конструкция для представления **неизменяемых данных** с уже готовыми базовыми операциями (создание, копирование, сравнение, декомпозиция), которых должно быть достаточно в большинстве случаев использования. Все остальные действия над такими данными должны выполнятся внешними функциями. В этом суть функционального подхода - разделение данных и операций над ними.

**Class** — это конструкция для создания **изменяемых данных**, с внутренним состоянием. Все возможные операции (методы) над данными нужно реализовывать самостоятельно внутри конструкции. Обычно она применяется в объектно-ориентированном подходе. В функциональной парадигме конструкция `class` рассматривается как динамический контейнер функций.

**Основное отличие:**

- Case class оптимизирован для работы с **данными как значениями** (value semantics)

- Class предназначен для объектов с **состоянием и поведением** (reference semantics)

**Правило выбора:** Если тип описывает **"что это"** — используй case class.

Если тип описывает **"что это делает"** — используй class.

---

### Полные данные JSON

<details>
<summary>Показать JSON данные</summary>

```json
{
  "name" : "text",
  "text" : "<h1 style=\"text-align:center;\">Конструкция Case Class</h1>\n\n<p>Case Class - самая часто используемая конструкция для создания сложных типов данных вида Product type. С помощью нее создаются модели предметной области, API, Data Transfer Objects.</p>\n\n<p>Как и все другие <strong>функциональные типы</strong> данных, конструкция обеспечивает создание и работу с <strong>неизменяемыми </strong>(immutable) данными (значениями).</p>\n\n<p>Конструкция позволяет использовать её в качестве <strong>основы, </strong>для создания более сложных абстрактных и рекурсивных типов данных, которые мы рассмотрим позже.</p>\n\n<h2 style=\"text-align:center;\">Синтаксис</h2>\n\n<h3>Определение типа данных на основе case class</h3>\n\n<pre><code class=\"language-scala\">// Базовый синтаксис\ncase class TypeName(field1: String, field2: Int)\n// case class - ключевые слова\n// TypeName - произвольное имя типа данных\n// field1, field1 - имена произвольных полей - элементов составного значения\n// String, Int - типы произвольных полей\n\n\n// С полями по умолчанию\ncase class User(\n  id: Long,\n  name: String,\n  email: String,\n  active: Boolean = true\n)\n\n// С несколькими списками полей\ncase class Request(method: String, path: String)(header: String)\n</code></pre>\n\n<h3>Создание значения типа</h3>\n\n<pre><code class=\"language-scala\">case class Point(x: Int, y: Int)\n\n// Создание\nval p1 = Point(10, 20)\n\n// С именованными полями\nval p2 = Point(x = 10, y = 20)\nval p3 = Point(y = 20, x = 10)  // Порядок не важен\n\n// Со значениями по умолчанию\ncase class Config(host: String, port: Int = 8080, timeout: Int = 5000)\n\nval c1 = Config(\"localhost\")                    // port=8080, timeout=5000\nval c2 = Config(\"localhost\", 9000)              // timeout=5000\nval c3 = Config(\"localhost\", timeout = 3000)    // port=8080, timeout=3000\nval c4 = Config(host = \"localhost\", port = 9000, timeout = 3000)\n</code></pre>\n\n<h3>Доступ к полям</h3>\n\n<pre><code class=\"language-scala\">case class User(id: Long, name: String, email: String)\n\nval user = User(1, \"Alice\", \"alice@example.com\")\n\n// Доступ к полям \nuser.id      // 1\nuser.name    // Alice\nuser.email   // alice@example.com\n\n// Поля неизменяемы\n// user.name = \"Bob\"  // ❌ Ошибка компиляции: reassignment to val\n</code></pre>\n\n<h3>Вложенные сложные типы</h3>\n\n<pre><code class=\"language-scala\">case class Address(street: String, city: String, zipCode: String)\ncase class Person(name: String, age: Int, address: Address)\n\nval address = Address(\"5th Avenue\", \"New York\", \"10001\")\nval person = Person(\"Alice\", 30, address)\n\n// Доступ к вложенным полям\nperson.address.city       // New York\nperson.address.zipCode    // 10001\n\n// Создание с вложенной структурой inline\nval person2 = Person(\n  \"Bob\",\n  25,\n  Address(\"Main Street\", \"Boston\", \"02101\")\n)\n</code></pre>\n\n<h2 style=\"text-align:center;\">Декомпозиция</h2>\n\n<p><strong>Декомпозиция</strong> — это извлечение данных из case class обратно в отдельные значения. Если конструктор case class <strong>композирует</strong> (точнее агрегирует) данные в единый объект, то декомпозиция делает <strong>обратное</strong> — разбирает объект на составные части. Это две стороны одной медали, автоматически предоставляемые компилятором. Case class автоматически поддерживает декомпозицию через операцию <strong>unapply</strong>.</p>\n\n<pre><code class=\"language-scala\">case class User(name: String, age: Int)\n\nval user = User(\"Anna\", 25)\n\n// Полная декомпозиция \nval User(nameValue, ageValue) = user\nnameValue // \"Anna\"\nageValue // 25\n\n// Псевдо частичная декомпозиция (просто не используем поле)\nval User(name = _, age = ageValue2) = user\n\n// Полная декомпозиция в Pattern matching\nuser match {\n  case User(name, age) =&gt; println(s\"$name is $age years old\")\n}\n\n// Частичная декомпозиция в Pattern matching\nuser match {\n  case User(name = n) =&gt; println(s\"$n \") // возраст игнорируется\n}\n\n// Сопостовление полей и получение недекомпозированного значения\nval age = 25\nuser match {\n  case originalUser @ User(name = \"Anna\", age = `age`) =&gt; println(s\"$originalUser\") // User(Anna,25)\n}</code></pre>\n\n<h2 style=\"text-align:center;\">Case Class vs Class</h2>\n\n<p>Можно заметить, что конструкции <code>case class</code> и <code>class</code> очень похожи по синтаксису и использованию. Но их следует использовать только по прямому назначению, и не путать.</p>\n\n<p><strong>Case Class</strong> — это конструкция для представления <strong>неизменяемых данных</strong> с уже готовыми базовыми операциями (создание, копирование, сравнение, декомпозиция), которых должно быть достаточно в большинстве случаев использования. Все остальные действия над такими данными должны выполнятся внешними функциями. В этом суть функционального подхода - разделение данных и операций над ними.</p>\n\n<p><strong>Class</strong> — это конструкция для создания <strong>изменяемых данных</strong>, с внутренним состоянием. Все возможные операции (методы) над данными нужно реализовывать самостоятельно внутри конструкции. Обычно она применяется в объектно-ориентированном подходе. В функциональной парадигме конструкция <code>class</code> рассматривается как динамический контейнер функций.</p>\n\n<p><strong>Основное отличие:</strong></p>\n\n<ul>\n\t<li>Case class оптимизирован для работы с <strong>данными как значениями</strong> (value semantics)</li>\n\t<li>Class предназначен для объектов с <strong>состоянием и поведением</strong> (reference semantics)</li>\n</ul>\n\n<p><strong>Правило выбора:</strong> Если тип описывает <strong>\"что это\"</strong> — используй case class.<br>\nЕсли тип описывает <strong>\"что это делает\"</strong> — используй class.</p>",
  "video" : null,
  "options" : {
    
  },
  "subtitle_files" : [
  ],
  "is_deprecated" : false
}
```

</details>
