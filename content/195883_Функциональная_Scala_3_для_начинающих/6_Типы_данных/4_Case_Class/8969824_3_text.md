# Материал (Шаг 3)

## Информация о шаге

- **ID шага**: 8969824
- **Позиция**: 3
- **Тип**: text
- **Курс**: Функциональная Scala 3 для начинающих
- **Экспортирован**: 2025-12-20T22:21:45.0566208

## Содержание

# Создание операций для типа

В функциональном программировании существует важный принцип: **данные и операции над ними должны быть разделены**. Однако реальная практика создания проектов не столь категорична и допускает баланс между независимыми функциями и встроенными в типы данных операциями (методами). Принципы такого разделения достаточно понятны и связаны со стремлением к читаемости кода, модульности и порядку в больших проектах. Как и большинство возможностей в Scala, разделение не регламентируется строго, а остается на усмотрение разработчика.

### Встроенные операции в тип (методы): 

- **Базовые операции над самим типом.** Операции, которые работают исключительно с данными того же типа и используются часто. Пример: `+`, `-`, `*`, `/` для числовых типов.

- **Стандартные конвертации и представления.** Операции преобразования значения в другие форматы и представления. Пример: `toString`, `toInt`, `hashCode`.

- **Универсальные операции высшего порядка.** Сложные, но математически устоявшиеся полиморфные операции, принимающие функции как аргументы. Пример: `map`, `flatMap`, `filter`, `foldLeft`.

**Философия:** Эти операции логически неразрывны с типом данных. Они математически предсказуемы, общеизвестны и не имеют альтернативных реализаций. Встраивание их в тип обеспечивает удобный цепочечный синтаксис (fluent interface) и улучшает читаемость. Размещать их отдельно было бы неразумно, так как они составляют фундаментальную часть семантики типа.

**Операции как отдельные функции:**

- **Бизнес-логика и операции предметной области.** Операции могут меняться независимо от структуры данных и отражают специфику конкретной задачи.

- **Операции над несколькими разнотипными значениями.** Функции, принимающие аргументы различных типов, не привязаны естественным образом ни к одному из них.

- **Сложные преобразования и вычисления.** Операции, требующие значительной логики или использующие дополнительный контекст.

- **Вариантные операции.** Ситуации, когда существует несколько альтернативных способов выполнить одно и то же действие (например, различные стратегии сортировки или валидации).

- **Операции с внешними зависимостями.** Включая операции с побочными эффектами (IO, состояние, случайность) или требующие внедрения зависимостей.

**Философия:** Разделение данных и операций обеспечивает модульность и гибкость. Типы данных описывают структуру предметной области без привязки к конкретному поведению, оставаясь простыми и понятными. Операции становятся композируемыми, легко тестируемыми и переиспользуемыми. Этот подход лучше отражает изменчивую природу бизнес-логики: добавление новых операций не требует изменения структуры данных. Такое разделение особенно ценно в бизнес-приложениях, где требования к операциям меняются чаще, чем сами сущности предметной области.

## Определение операций внутри типа (методы)

Для создания операций встроенных в тип, необходимо определить соответствующие именованные функции при определении типа после двоеточия. Отступы от начала строки определяют вложенность конструкций.

Пример:

case class Vector2D(x: Double, y: Double):
def add(v2: Vector2D): Vector2D =
Vector2D(x + v2.x, y + v2.y)

def subtract(v2: Vector2D): Vector2D =
Vector2D(x - v2.x, y - v2.y)

def dot(v2: Vector2D): Double =
x * v2.x + y * v2.y

def magnitude: Double =
math.sqrt(x * x + y * y)

def normalize: Vector2D =
val mag = magnitude
Vector2D(x / mag, y / mag)

Также можно операции определить в фигурных скобках.

case class Vector2D(x: Double, y: Double){
def add(v2: Vector2D): Vector2D =
Vector2D(x + v2.x, y + v2.y)
}

Вызов таких операций выполняется через точку от значения. 

val vector1 = Vector2D(1.0, 2.0)
val vector2 = Vector2D(2.0, 4.0)
// Точечная цепочка вызовов операций
val res: Double = vector1.add(vector2).subtract(vector1).normalize.dot(vector2)

Если при определении операторов указать префикс`infix`, то можно также использовать инфиксную нотацию вызова операций. 

case class Vector2D(x: Double, y: Double):
infix def add(v2: Vector2D): Vector2D =
Vector2D(x + v2.x, y + v2.y)

infix def subtract(v2: Vector2D): Vector2D =
Vector2D(x - v2.x, y - v2.y)

infix def dot(v2: Vector2D): Double =
x * v2.x + y * v2.y

def magnitude: Double =
math.sqrt(x * x + y * y)

def normalize: Vector2D =
val mag = magnitude
Vector2D(x / mag, y / mag)

val vector1 = Vector2D(1.0, 2.0)
val vector2 = Vector2D(2.0, 4.0)
// инфиксная цепочка вызовов операций
val res: Double = (vector1 add vector2 subtract vector1).normalize dot vector2

## Определение операций вне типа (функции)

Данный подход отделяет друг от друга тип и возможные операции с ним связанные. Определять тип и его операции можно в различных местах кода, в разных контейнерах. Но рекомендуется, размещать определения операций типа в одноименном статическом контейнере, который называют **объект-компаньон**.

case class Vector2D(x: Double, y: Double)

object Vector2D:
def add(v1: Vector2D, v2: Vector2D): Vector2D =
Vector2D(v1.x + v2.x, v1.y + v2.y)

def subtract(v1: Vector2D, v2: Vector2D): Vector2D =
Vector2D(v1.x - v2.x, v1.y - v2.y)

def dot(v1: Vector2D, v2: Vector2D): Double =
v1.x * v2.x + v1.y * v2.y

def magnitude(v: Vector2D): Double =
math.sqrt(v.x * v.x + v.y * v.y)

def normalize(v: Vector2D): Vector2D = {
val mag = magnitude(v)
Vector2D(v.x / mag, v.y / mag)
}

Вызов таких операций осуществляется как обычных функций.

val vector1 = Vector2D(1.0, 2.0)
val vector2 = Vector2D(2.0, 4.0)
val res = Vector2D.dot(Vector2D.normalize(Vector2D.subtract(Vector2D.add(vector1, vector2), vector1)), vector2)

Если импортировать функции из контейнера, то код будет лаконичней:

val vector1 = Vector2D(1.0, 2.0)
val vector2 = Vector2D(2.0, 4.0)
import Vector2D.*
val res = dot(normalize(subtract(add(vector1, vector2), vector1)), vector2)

А вот и композиция функций цепочкой:

val vector1 = Vector2D(1.0, 2.0)
val vector2 = Vector2D(2.0, 4.0)
import Vector2D.*
val res: Double = (add.curried(vector1)
andThen (v => subtract.curried(v)(vector1))
andThen normalize
andThen (v => dot.curried(v)(vector2)))(vector2)

## Определение дополнительных операции типа (внешние методы)

Подход, позволяющий совместить вышеприведенные способы определений операций типов. Операция определяется отдельно от типа, но в тоже время внедряется в тип. Это позволяет использовать точечную и инфиксную нотации в операциях.

При определении операций таким способом, их необходимо заключить в конструкцию` **extension**`

case class Vector2D(x: Double, y: Double)

extension (v: Vector2D){
def +(other: Vector2D): Vector2D = // Для символьных операторов указывать infix не требуется (+, -, *, /, ::, >>> и т.д.)
Vector2D(v.x + other.x, v.y + other.y)

def -(other: Vector2D): Vector2D =
Vector2D(v.x - other.x, v.y - other.y)

def magnitude: Double =
math.sqrt(v.x * v.x + v.y * v.y)

def normalize: Vector2D =
val mag = v.magnitude
if mag == 0 then v else Vector2D(v.x / mag, v.y / mag)
}

// Использование
val v1 = Vector2D(3.0, 4.0)
val v2 = Vector2D(1.0, 2.0)
val v3 = v1 + v2
println(v1.magnitude) // 5.0

Методы типа не могут перекрывать друг друга с помощью данного способа. Будет возникать ошибка компиляции. 

---

### Полные данные JSON

<details>
<summary>Показать JSON данные</summary>

```json
{
  "name" : "text",
  "text" : "<h1 style=\"text-align:center;\">Создание операций для типа</h1>\n\n<p>В функциональном программировании существует важный принцип: <strong>данные и операции над ними должны быть разделены</strong>. Однако реальная практика создания проектов не столь категорична и допускает баланс между независимыми функциями и встроенными в типы данных операциями (методами). Принципы такого разделения достаточно понятны и связаны со стремлением к читаемости кода, модульности и порядку в больших проектах. Как и большинство возможностей в Scala, разделение не регламентируется строго, а остается на усмотрение разработчика.</p>\n\n<h3>Встроенные операции в тип (методы): </h3>\n\n<ol>\n\t<li><strong>Базовые операции над самим типом.</strong> Операции, которые работают исключительно с данными того же типа и используются часто. Пример: <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code> для числовых типов.</li>\n\t<li><strong>Стандартные конвертации и представления.</strong> Операции преобразования значения в другие форматы и представления. Пример: <code>toString</code>, <code>toInt</code>, <code>hashCode</code>.</li>\n\t<li><strong>Универсальные операции высшего порядка.</strong> Сложные, но математически устоявшиеся полиморфные операции, принимающие функции как аргументы. Пример: <code>map</code>, <code>flatMap</code>, <code>filter</code>, <code>foldLeft</code>.</li>\n</ol>\n\n<p><strong>Философия:</strong> Эти операции логически неразрывны с типом данных. Они математически предсказуемы, общеизвестны и не имеют альтернативных реализаций. Встраивание их в тип обеспечивает удобный цепочечный синтаксис (fluent interface) и улучшает читаемость. Размещать их отдельно было бы неразумно, так как они составляют фундаментальную часть семантики типа.</p>\n\n<p><strong>Операции как отдельные функции:</strong></p>\n\n<ol>\n\t<li><strong>Бизнес-логика и операции предметной области.</strong> Операции могут меняться независимо от структуры данных и отражают специфику конкретной задачи.</li>\n\t<li><strong>Операции над несколькими разнотипными значениями.</strong> Функции, принимающие аргументы различных типов, не привязаны естественным образом ни к одному из них.</li>\n\t<li><strong>Сложные преобразования и вычисления.</strong> Операции, требующие значительной логики или использующие дополнительный контекст.</li>\n\t<li><strong>Вариантные операции.</strong> Ситуации, когда существует несколько альтернативных способов выполнить одно и то же действие (например, различные стратегии сортировки или валидации).</li>\n\t<li><strong>Операции с внешними зависимостями.</strong> Включая операции с побочными эффектами (IO, состояние, случайность) или требующие внедрения зависимостей.</li>\n</ol>\n\n<p><strong>Философия:</strong> Разделение данных и операций обеспечивает модульность и гибкость. Типы данных описывают структуру предметной области без привязки к конкретному поведению, оставаясь простыми и понятными. Операции становятся композируемыми, легко тестируемыми и переиспользуемыми. Этот подход лучше отражает изменчивую природу бизнес-логики: добавление новых операций не требует изменения структуры данных. Такое разделение особенно ценно в бизнес-приложениях, где требования к операциям меняются чаще, чем сами сущности предметной области.</p>\n\n<h2 style=\"text-align:center;\">Определение операций внутри типа (методы)</h2>\n\n<p>Для создания операций встроенных в тип, необходимо определить соответствующие именованные функции при определении типа после двоеточия. Отступы от начала строки определяют вложенность конструкций.</p>\n\n<p>Пример:</p>\n\n<pre><code class=\"language-scala\">case class Vector2D(x: Double, y: Double):\n  def add(v2: Vector2D): Vector2D =\n    Vector2D(x + v2.x, y + v2.y)\n\n  def subtract(v2: Vector2D): Vector2D =\n    Vector2D(x - v2.x, y - v2.y)\n\n  def dot(v2: Vector2D): Double =\n    x * v2.x + y * v2.y\n\n  def magnitude: Double =\n    math.sqrt(x * x + y * y)\n\n  def normalize: Vector2D =\n    val mag = magnitude\n    Vector2D(x / mag, y / mag)</code></pre>\n\n<p>Также можно операции определить в фигурных скобках.</p>\n\n<pre><code class=\"language-scala\">case class Vector2D(x: Double, y: Double){\n  def add(v2: Vector2D): Vector2D =\n    Vector2D(x + v2.x, y + v2.y)\n}\n</code></pre>\n\n<p>Вызов таких операций выполняется через точку от значения. </p>\n\n<pre><code class=\"language-scala\">val vector1 = Vector2D(1.0, 2.0)\nval vector2 = Vector2D(2.0, 4.0)\n// Точечная цепочка вызовов операций\nval res: Double = vector1.add(vector2).subtract(vector1).normalize.dot(vector2)\n</code></pre>\n\n<p>Если при определении операторов указать префикс<code>infix</code>, то можно также использовать инфиксную нотацию вызова операций. </p>\n\n<pre><code class=\"language-scala\">case class Vector2D(x: Double, y: Double):\n  infix def add(v2: Vector2D): Vector2D =\n    Vector2D(x + v2.x, y + v2.y)\n\n  infix def subtract(v2: Vector2D): Vector2D =\n    Vector2D(x - v2.x, y - v2.y)\n\n  infix def dot(v2: Vector2D): Double =\n    x * v2.x + y * v2.y\n\n  def magnitude: Double =\n    math.sqrt(x * x + y * y)\n\n  def normalize: Vector2D =\n    val mag = magnitude\n    Vector2D(x / mag, y / mag)\n\nval vector1 = Vector2D(1.0, 2.0)\nval vector2 = Vector2D(2.0, 4.0)\n// инфиксная цепочка вызовов операций\nval res: Double = (vector1 add vector2 subtract vector1).normalize dot vector2 \n</code></pre>\n\n<h2 style=\"text-align:center;\">Определение операций вне типа (функции)</h2>\n\n<p>Данный подход отделяет друг от друга тип и возможные операции с ним связанные. Определять тип и его операции можно в различных местах кода, в разных контейнерах. Но рекомендуется, размещать определения операций типа в одноименном статическом контейнере, который называют <strong>объект-компаньон</strong>.</p>\n\n<pre><code class=\"language-scala\">case class Vector2D(x: Double, y: Double)\n\nobject Vector2D:\n  def add(v1: Vector2D, v2: Vector2D): Vector2D =\n    Vector2D(v1.x + v2.x, v1.y + v2.y)\n  \n  def subtract(v1: Vector2D, v2: Vector2D): Vector2D =\n    Vector2D(v1.x - v2.x, v1.y - v2.y)\n  \n  def dot(v1: Vector2D, v2: Vector2D): Double =\n    v1.x * v2.x + v1.y * v2.y\n  \n  def magnitude(v: Vector2D): Double =\n    math.sqrt(v.x * v.x + v.y * v.y)\n  \n  def normalize(v: Vector2D): Vector2D = {\n    val mag = magnitude(v)\n    Vector2D(v.x / mag, v.y / mag)\n  }\n</code></pre>\n\n<p>Вызов таких операций осуществляется как обычных функций.</p>\n\n<pre><code class=\"language-scala\">val vector1 = Vector2D(1.0, 2.0)\nval vector2 = Vector2D(2.0, 4.0)\nval res = Vector2D.dot(Vector2D.normalize(Vector2D.subtract(Vector2D.add(vector1, vector2), vector1)), vector2)</code></pre>\n\n<p>Если импортировать функции из контейнера, то код будет лаконичней:</p>\n\n<pre><code class=\"language-scala\">val vector1 = Vector2D(1.0, 2.0)\nval vector2 = Vector2D(2.0, 4.0)\nimport Vector2D.*\nval res = dot(normalize(subtract(add(vector1, vector2), vector1)), vector2)</code></pre>\n\n<p>А вот и композиция функций цепочкой:</p>\n\n<pre><code class=\"language-scala\">val vector1 = Vector2D(1.0, 2.0)\nval vector2 = Vector2D(2.0, 4.0)\nimport Vector2D.*\nval res: Double = (add.curried(vector1)\n  andThen (v =&gt; subtract.curried(v)(vector1))\n  andThen normalize\n  andThen (v =&gt; dot.curried(v)(vector2)))(vector2)</code></pre>\n\n<h2 style=\"text-align:center;\">Определение дополнительных операции типа (внешние методы)</h2>\n\n<p>Подход, позволяющий совместить вышеприведенные способы определений операций типов. Операция определяется отдельно от типа, но в тоже время внедряется в тип. Это позволяет использовать точечную и инфиксную нотации в операциях.</p>\n\n<p>При определении операций таким способом, их необходимо заключить в конструкцию<code> <strong>extension</strong></code></p>\n\n<pre style=\"background:transparent; color:#383a42; text-align:left;\"><code class=\"language-scala\" style=\"background:transparent; color:#383a42; text-align:left;\">case class Vector2D(x: Double, y: Double)\n\nextension (v: Vector2D){\n  def +(other: Vector2D): Vector2D = //  Для символьных операторов указывать infix не требуется (+, -, *, /, ::, &gt;&gt;&gt; и т.д.)\n    Vector2D(v.x + other.x, v.y + other.y)\n  \n  def -(other: Vector2D): Vector2D = \n    Vector2D(v.x - other.x, v.y - other.y)\n  \n  def magnitude: Double = \n    math.sqrt(v.x * v.x + v.y * v.y)\n  \n  def normalize: Vector2D =\n    val mag = v.magnitude\n    if mag == 0 then v else Vector2D(v.x / mag, v.y / mag)\n}\n\n// Использование\nval v1 = Vector2D(3.0, 4.0)\nval v2 = Vector2D(1.0, 2.0)\nval v3 = v1 + v2\nprintln(v1.magnitude)  // 5.0</code></pre>\n\n<p>Методы типа не могут перекрывать друг друга с помощью данного способа. Будет возникать ошибка компиляции. </p>",
  "video" : null,
  "options" : {
    
  },
  "subtitle_files" : [
  ],
  "is_deprecated" : false
}
```

</details>
