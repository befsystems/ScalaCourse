# Материал (Шаг 1)

## Информация о шаге

- **ID шага**: 9033133
- **Позиция**: 1
- **Тип**: text
- **Курс**: Функциональная Scala 3 для начинающих
- **Экспортирован**: 2025-12-20T22:21:47.0837335

## Содержание

# Типы-суммы (Sum Types)

**Тип-сумма (Sum type)** — это тип данных, представляющий собой выбор между несколькими **альтернативными **вариантами, где значение может быть только одним из предопределённых типов.

Название "sum" происходит из теории категорий: если тип A содержит m значений, а тип B содержит n значений, то их сумма A + B содержит m + n возможных значений. Это дизъюнктное объединение типов - ИЛИ.

## Представители Sum Types в Scala

### Конструкция Enum (перечисления)

enum Color:
case Red, Green, Blue

### Конструкция sealed trait + case objects

sealed trait LogLevel
case object Debug extends LogLevel
case object Info extends LogLevel
case object Warning extends LogLevel
case object Error extends LogLevel

 

### Union Type

`type Status = "active" | "inactive" | "pending"`

### Примитивные типы данных

Примитивные типы представляют выбор одного значения из фиксированного набора альтернатив — это и есть определение Sum Type!

// Примитивные типы — это Sum Types с фиксированной кардинальностью

Boolean // |Boolean| = 2
Unit // |Unit| = 1
Byte // |Byte| = 2⁸ = 256
Char // |Char| = 2¹⁶ = 65536
Short // |Short| = 2¹⁶
Int // |Int| = 2³²
Long // |Long| = 2⁶⁴
Float // |Float| = 2³² (включая особые значения)
Double // |Double| = 2⁶⁴ (включая особые значения)

## Назначение типов-суммы

### 1. Моделирование взаимоисключающих состояний

Sum types позволяют точно выразить, что значение может находиться в одном из нескольких возможных состояний.

### 2. Исключение невалидных состояний

Sum types делают невозможными состояния, которые не должны существовать в программе.

### 3. Явное моделирование бизнес-логики

Sum types делают бизнес-правила видимыми в системе типов.

### 4. Безопасная обработка всех случаев

Компилятор гарантирует, что обработаны все возможные варианты.

## Когда НЕ использовать Sum Types

Sum types не подходят когда:

- **Множество вариантов может расширяться**: если нужна открытая иерархия, где пользователи могут добавлять новые варианты

- **Нужны данные в вариантах**: когда каждый вариант должен нести специфичные данные (это уже комбинация с Product Types)

- **Простые флаги достаточны**: для простого true/false Boolean проще

##  

---

### Полные данные JSON

<details>
<summary>Показать JSON данные</summary>

```json
{
  "name" : "text",
  "text" : "<h1 style=\"text-align:center;\">Типы-суммы (Sum Types)</h1>\n\n<p><strong>Тип-сумма (Sum type)</strong> — это тип данных, представляющий собой выбор между несколькими <strong>альтернативными </strong>вариантами, где значение может быть только одним из предопределённых типов.</p>\n\n<p>Название \"sum\" происходит из теории категорий: если тип A содержит m значений, а тип B содержит n значений, то их сумма A + B содержит m + n возможных значений. Это дизъюнктное объединение типов - ИЛИ.</p>\n\n<h2 style=\"text-align:center;\">Представители Sum Types в Scala</h2>\n\n<h3 style=\"text-align:center;\">Конструкция Enum (перечисления)</h3>\n\n<pre><code class=\"language-scala\">enum Color:\n  case Red, Green, Blue</code></pre>\n\n<h3 style=\"text-align:center;\">Конструкция sealed trait + case objects</h3>\n\n<pre><code class=\"language-scala\">sealed trait LogLevel\ncase object Debug extends LogLevel\ncase object Info extends LogLevel\ncase object Warning extends LogLevel\ncase object Error extends LogLevel</code></pre>\n\n<pre style=\"background:transparent; color:#abb2bf; text-align:left;\"> </pre>\n\n<h3 style=\"text-align:center;\">Union Type</h3>\n\n<pre><code class=\"language-scala\">type Status = \"active\" | \"inactive\" | \"pending\"</code></pre>\n\n<h3 style=\"text-align:center;\">Примитивные типы данных</h3>\n\n<p>Примитивные типы представляют выбор одного значения из фиксированного набора альтернатив — это и есть определение Sum Type!</p>\n\n<pre><code class=\"language-scala\">// Примитивные типы — это Sum Types с фиксированной кардинальностью\n\nBoolean   // |Boolean| = 2\nUnit      // |Unit| = 1\nByte      // |Byte| = 2⁸ = 256\nChar      // |Char| = 2¹⁶ = 65536\nShort     // |Short| = 2¹⁶\nInt       // |Int| = 2³²\nLong      // |Long| = 2⁶⁴\nFloat     // |Float| = 2³² (включая особые значения)\nDouble    // |Double| = 2⁶⁴ (включая особые значения)</code></pre>\n\n<h2 style=\"text-align:center;\">Назначение типов-суммы</h2>\n\n<h3>1. Моделирование взаимоисключающих состояний</h3>\n\n<p>Sum types позволяют точно выразить, что значение может находиться в одном из нескольких возможных состояний.</p>\n\n<h3>2. Исключение невалидных состояний</h3>\n\n<p>Sum types делают невозможными состояния, которые не должны существовать в программе.</p>\n\n<h3>3. Явное моделирование бизнес-логики</h3>\n\n<p>Sum types делают бизнес-правила видимыми в системе типов.</p>\n\n<h3>4. Безопасная обработка всех случаев</h3>\n\n<p>Компилятор гарантирует, что обработаны все возможные варианты.</p>\n\n<h2 style=\"text-align:center;\">Когда НЕ использовать Sum Types</h2>\n\n<p>Sum types не подходят когда:</p>\n\n<ol>\n\t<li><strong>Множество вариантов может расширяться</strong>: если нужна открытая иерархия, где пользователи могут добавлять новые варианты</li>\n\t<li><strong>Нужны данные в вариантах</strong>: когда каждый вариант должен нести специфичные данные (это уже комбинация с Product Types)</li>\n\t<li><strong>Простые флаги достаточны</strong>: для простого true/false Boolean проще</li>\n</ol>\n\n<h2> </h2>",
  "video" : null,
  "options" : {
    
  },
  "subtitle_files" : [
  ],
  "is_deprecated" : false
}
```

</details>
