# Материал (Шаг 2)

## Информация о шаге

- **ID шага**: 9034203
- **Позиция**: 2
- **Тип**: text
- **Курс**:  Система типов Scala 3
- **Экспортирован**: 2026-01-10T10:36:27.5564066

## Содержание

# Конструкция enum

Основной способ определения суммарных типов это конструкция  `**enum**.`

## Синтаксис определения enum

enum EnumName:
case Value1
case Value2
case ValueN

// или
enum EnumName:
case Value1, Value2, ValueN

**Value** - может быть как **тип-****одиночка**, так и **тип-****product**. 

### **Одиночный тип значений:**

// Суммарный тип Color с тремя возможными одиночными значениями - Red, Green, Yellow
enum Color:
case Red // |Red| = 1
case Green // |Green| = 1
case Yellow // |Yellow| = 1

// Color = Red + Green + Yellow
// |Color| = |Red| + |Green| + |Yellow| = 1 + 1 + 1 = 3

// Определение значений
val myColor: Color = Color.Red
val trafficLight: Color = Color.Green

// Pattern matching
def describe(c: Color): String = c match
case Color.Red => "Стой"
case Color.Green => "Иди"
case Color.Yellow => "Осторожно"
// Компилятор проверяет полноту покрытия всех вариантов.

### Значения - тип product:

// Суммарный тип HttpStatus с тремя возможными product значениями - Ok, NotFound, Error
enum HttpStatus:
case Ok(message: String)
case NotFound(path: String)
case Error(code: Int)

// HttpStatus = Ok + NotFound + Error
// |HttpStatus| = |Ok| + |NotFound| + |Error| = ∞ + ∞ + 2³² = ∞

// Определение значений
val success = HttpStatus.Ok("Request processed")
val notFound = HttpStatus.NotFound("/api/users")
val error = HttpStatus.Error(500)

// Pattern matching
def handle(result: HttpStatus): String = result match
case HttpStatus.Ok(v) => s"Ok: $v"
case HttpStatus.NotFound(e) => s"NotFound: $e"
case HttpStatus.Error(e) => s"Error: $e"
// Компилятор проверяет полноту покрытия всех вариантов.

### Значения - тип product и **тип-****одиночка одновременно**

// Суммарный тип Result с двумя возможными значениями - Ok, Error
enum Result:
case Ok
case Error(code: Int)

// Result= Ok + Error
// |Result| = |Ok| + |Error| = 1 + 2³²

// Определение значений
val success = Result.Ok
val error = Result.Error(500)

// Pattern matching
def handle(result: Result): String = result match
case Result.Ok => "Success!"
case Result.Error(e) => s"Error: $e"
// Компилятор проверяет полноту покрытия всех вариантов.

## Композиция сумм и произведений

enum Color:
case Red, Green, Blue
// |Color| = 3

enum Size:
case Small, Medium, Large
// |Size| = 3

// Произведение (И)
type ColoredSize = (Color, Size)
// |ColoredSize| = |Color| × |Size| = 3 × 3 = 9
// Возможные значения: (Red, Small), (Red, Medium), (Red, Large),
// (Green, Small), (Green, Medium), ... и т.д.

## Операции в enum

В конструкцию `enum `можно встроить **общие **для типа операции: 

enum Color:
case Red, Green, Blue

def toHex: String = this match
case Red => "#FF0000"
case Green => "#00FF00"
case Blue => "#0000FF"

println(Color.Red.toHex) // #FF0000

Операцию можно добавить для **отдельного значения**:

enum Storage:
case Empty
case Filled(amount: Int):
def isFull: Boolean = amount >= 100

val storage = Storage.Filled(80)
// storage.isFull доступен только для Filled

##  Сравнение enum

enum Size:
case Small, Medium, Large

val s1 = Size.Small
val s2 = Size.Small
val s3 = Size.Large

println(s1 == s2) // true
println(s1 == s3) // false

enum Result:
case Ok
case Error(code: Int)

val error1 = Result.Error(500)
val error2 = Result.Error(400)
val error3 = Result.Error(500)

println(error1 == error3) // true
println(error1 == error2) // false

## Порядковый номер

У значений  **`enum `**есть порядковый номер:

enum Priority:
case Low, Medium, High

println(Priority.Low.ordinal) // 0
println(Priority.Medium.ordinal) // 1
println(Priority.High.ordinal) // 2

Это полезно для сортировки.

## Общие поля enum

**`enum`** может иметь поля, которые будут обязательно у каждого значения:

### Константное значение:

enum Planet(val mass: Double, val radius: Double):
case Mercury extends Planet(3.303e23, 2.4397e6)
case Venus extends Planet(4.869e24, 6.0518e6)
case Earth extends Planet(5.976e24, 6.37814e6)

def surfaceGravity: Double =
val G = 6.67300e-11
G * mass / (radius * radius)

val earthMass = Planet.Earth.mass
val earthGravity = Planet.Earth.surfaceGravity

### Задаваемое при создании:

// Имеем два поля, celsius - внутренее, degrees - внешнее
enum Temperature(val celsius: Double):
case Celsius(degrees: Double) extends Temperature(degrees)
case Fahrenheit(degrees: Double) extends Temperature((degrees - 32) * 5 / 9)
case Kelvin(degrees: Double) extends Temperature(degrees - 273.15)
case AbsoluteZero extends Temperature(-273.15)

val temper: Temperature = Temperature.Fahrenheit(77.0)

// Pattern matching
def handle(temper: Temperature): String = temper match {
case c @ Temperature.Fahrenheit(v) => s"Temperature = ${c.celsius}°C = $v°F"
case _ => s"Temperature not accurate"
}

println(handle(temper)) //Temperature = 25.0°C = 77.0°F

---

### Полные данные JSON

<details>
<summary>Показать JSON данные</summary>

```json
{
  "name" : "text",
  "text" : "<h1 style=\"text-align:center;\">Конструкция enum</h1>\n\n<p>Основной способ определения суммарных типов это конструкция  <code><strong>enum</strong>.</code></p>\n\n<h2 style=\"text-align:center;\">Синтаксис определения enum</h2>\n\n<pre><code class=\"language-scala\">enum EnumName:  \n  case Value1\n  case Value2\n  case ValueN\n\n// или\nenum EnumName:  \n  case Value1, Value2, ValueN</code></pre>\n\n<p><strong>Value</strong> - может быть как <strong>тип-</strong><strong>одиночка</strong>, так и <strong>тип-</strong><strong>product</strong>. </p>\n\n<h3><strong>Одиночный тип значений:</strong></h3>\n\n<pre><code class=\"language-scala\">// Суммарный тип Color с тремя возможными одиночными значениями - Red, Green, Yellow\nenum Color:\n  case Red      // |Red| = 1\n  case Green    // |Green| = 1\n  case Yellow     // |Yellow| = 1\n\n// Color = Red + Green + Yellow\n// |Color| = |Red| + |Green| + |Yellow| = 1 + 1 + 1 = 3\n\n// Определение значений\nval myColor: Color = Color.Red\nval trafficLight: Color = Color.Green\n\n// Pattern matching\ndef describe(c: Color): String = c match\n  case Color.Red   =&gt; \"Стой\"\n  case Color.Green =&gt; \"Иди\"\n  case Color.Yellow  =&gt; \"Осторожно\"\n// Компилятор проверяет полноту покрытия всех вариантов.</code></pre>\n\n<h3>Значения - тип product:</h3>\n\n<pre><code class=\"language-scala\">// Суммарный тип HttpStatus с тремя возможными product значениями - Ok, NotFound, Error\nenum HttpStatus:\n  case Ok(message: String)\n  case NotFound(path: String)\n  case Error(code: Int)\n\n// HttpStatus = Ok + NotFound + Error\n// |HttpStatus| = |Ok| + |NotFound| + |Error| = ∞ + ∞ + 2³² = ∞\n\n// Определение значений\nval success = HttpStatus.Ok(\"Request processed\")\nval notFound = HttpStatus.NotFound(\"/api/users\")\nval error = HttpStatus.Error(500)\n\n// Pattern matching\ndef handle(result: HttpStatus): String = result match\n  case HttpStatus.Ok(v) =&gt; s\"Ok: $v\"\n  case HttpStatus.NotFound(e) =&gt; s\"NotFound: $e\"\n  case HttpStatus.Error(e) =&gt; s\"Error: $e\"\n// Компилятор проверяет полноту покрытия всех вариантов.\n\n</code></pre>\n\n<h3>Значения - тип product и <strong>тип-</strong><strong>одиночка одновременно</strong></h3>\n\n<pre><code class=\"language-scala\">// Суммарный тип Result с двумя возможными значениями - Ok, Error\nenum Result:\n  case Ok\n  case Error(code: Int)\n\n// Result= Ok + Error\n// |Result| = |Ok| + |Error| = 1 + 2³² \n\n// Определение значений\nval success = Result.Ok\nval error = Result.Error(500)\n\n// Pattern matching\ndef handle(result: Result): String = result match\n  case Result.Ok =&gt; \"Success!\"\n  case Result.Error(e) =&gt; s\"Error: $e\"\n// Компилятор проверяет полноту покрытия всех вариантов.</code></pre>\n\n<h2 style=\"text-align:center;\">Композиция сумм и произведений</h2>\n\n<pre><code class=\"language-scala\">enum Color:\n  case Red, Green, Blue\n// |Color| = 3\n\nenum Size:\n  case Small, Medium, Large\n// |Size| = 3\n\n// Произведение (И)\ntype ColoredSize = (Color, Size)\n// |ColoredSize| = |Color| × |Size| = 3 × 3 = 9\n// Возможные значения: (Red, Small), (Red, Medium), (Red, Large),\n//                     (Green, Small), (Green, Medium), ... и т.д.</code></pre>\n\n<h2 style=\"text-align:center;\">Операции в enum</h2>\n\n<p>В конструкцию <code>enum </code>можно встроить <strong>общие </strong>для типа операции: </p>\n\n<pre><code class=\"language-scala\">enum Color:\n  case Red, Green, Blue\n  \n  def toHex: String = this match\n    case Red   =&gt; \"#FF0000\"\n    case Green =&gt; \"#00FF00\"\n    case Blue  =&gt; \"#0000FF\"\n\nprintln(Color.Red.toHex)  // #FF0000</code></pre>\n\n<p>Операцию можно добавить для <strong>отдельного значения</strong>:</p>\n\n<pre><code class=\"language-scala\">enum Storage:\n  case Empty\n  case Filled(amount: Int):\n    def isFull: Boolean = amount &gt;= 100\n  \nval storage = Storage.Filled(80)\n// storage.isFull доступен только для Filled\n</code></pre>\n\n<h2 style=\"text-align:center;\"> Сравнение enum</h2>\n\n<pre><code class=\"language-scala\">enum Size:\n  case Small, Medium, Large\n\nval s1 = Size.Small\nval s2 = Size.Small\nval s3 = Size.Large\n\nprintln(s1 == s2)  // true\nprintln(s1 == s3)  // false\n</code></pre>\n\n<pre><code class=\"language-scala\">enum Result:\n  case Ok\n  case Error(code: Int)\n\nval error1 = Result.Error(500)\nval error2 = Result.Error(400)\nval error3 = Result.Error(500)\n\nprintln(error1 == error3)  // true\nprintln(error1 == error2)  // false\n</code></pre>\n\n<h2 style=\"text-align:center;\">Порядковый номер</h2>\n\n<p>У значений  <strong><code>enum </code></strong>есть порядковый номер:</p>\n\n<pre><code class=\"language-scala\">enum Priority:\n  case Low, Medium, High\n\nprintln(Priority.Low.ordinal)     // 0\nprintln(Priority.Medium.ordinal)  // 1\nprintln(Priority.High.ordinal)    // 2\n</code></pre>\n\n<p>Это полезно для сортировки.</p>\n\n<h2 style=\"text-align:center;\">Общие поля enum</h2>\n\n<p><strong><code>enum</code></strong> может иметь поля, которые будут обязательно у каждого значения:</p>\n\n<h3>Константное значение:</h3>\n\n<pre><code class=\"language-scala\">enum Planet(val mass: Double, val radius: Double):\n  case Mercury extends Planet(3.303e23, 2.4397e6)\n  case Venus extends Planet(4.869e24, 6.0518e6)\n  case Earth extends Planet(5.976e24, 6.37814e6)\n  \n  def surfaceGravity: Double =\n    val G = 6.67300e-11\n    G * mass / (radius * radius)\n\nval earthMass = Planet.Earth.mass\nval earthGravity = Planet.Earth.surfaceGravity\n</code></pre>\n\n<h3>Задаваемое при создании:</h3>\n\n<pre><code class=\"language-scala\">// Имеем два поля, celsius - внутренее, degrees - внешнее\nenum Temperature(val celsius: Double):\n  case Celsius(degrees: Double) extends Temperature(degrees)\n  case Fahrenheit(degrees: Double) extends Temperature((degrees - 32) * 5 / 9)\n  case Kelvin(degrees: Double) extends Temperature(degrees - 273.15)\n  case AbsoluteZero extends Temperature(-273.15)\n\n\n  val temper: Temperature = Temperature.Fahrenheit(77.0)\n\n  // Pattern matching\n  def handle(temper: Temperature): String = temper match {\n    case c @ Temperature.Fahrenheit(v) =&gt; s\"Temperature = ${c.celsius}°C = $v°F\"\n    case _ =&gt; s\"Temperature not accurate\"\n  }\n\n  println(handle(temper))  //Temperature = 25.0°C = 77.0°F\n</code></pre>",
  "video" : null,
  "options" : {
    
  },
  "subtitle_files" : [
  ],
  "is_deprecated" : false
}
```

</details>
