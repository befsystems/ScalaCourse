# Материал (Шаг 1)

## Информация о шаге

- **ID шага**: 9033133
- **Позиция**: 1
- **Тип**: text
- **Курс**:  Система типов Scala 3
- **Экспортирован**: 2026-01-10T10:36:27.5504548

## Содержание

# Суммарные типы (Sum Types)

В предыдущем уроке мы говорили о типах-произведениях — когда нам нужно **И** то, **И** другое одновременно. Сегодня мы рассмотрим их противоположность: суммарные типы, которые моделируют **ИЛИ** — ситуации, когда значение может быть *либо* этим, *либо* тем.

Представьте светофор: в каждый момент времени он горит **либо** красным, **либо** жёлтым, **либо** зелёным — но никогда несколькими цветами сразу. Или состояние сетевого соединения: оно **либо** установлено, **либо** разрывается, **либо** отсутствует. Именно такие ситуации моделируют суммарные типы.

Почему "суммарные"? Всё дело в алгебре типов. Если произведение `(A, B)` означает "A **И** B", и количество возможных значений *перемножается*, то сумма `A | B` означает "A **ИЛИ** B", и количество возможных значений *складывается*. В этом уроке мы рассмотрим самую простую форму суммарных типов — "чистые суммы" без данных, где каждый вариант существует сам по себе, как флаг или метка. Суммы с данными (ADT — algebraic data types) мы оставим для следующего урока.

## Boolean: простейший суммарный тип

Самый знакомый каждому программисту суммарный тип — это `Boolean`. Давайте посмотрим на него через призму алгебры типов:

// Boolean = true | false
// Алгебраически: Boolean = 1 + 1 = 2

У типа `Boolean` ровно два возможных значения: `true` и `false`. Это **сумма** двух единиц. Каждый из вариантов (`true` или `false`) сам по себе не несёт никаких данных — это просто метка, флаг. Кардинальность (количество возможных значений) типа `Boolean` равна 2.

Сравните это с произведением:

type BoolPair = (Boolean, Boolean)
// |BoolPair| = |Boolean| × |Boolean| = 2 × 2 = 4
// Возможные значения: (true, true), (true, false), (false, true), (false, false)

 

Видите разницу? В сумме значения **складываются** (2 = 1 + 1), в произведении — **умножаются** (4 = 2 × 2). Это фундаментальное различие между "ИЛИ" и "И".

**Тип-сумма (Sum type)** — это тип данных, представляющий собой выбор между несколькими **альтернативными **вариантами, где значение может быть только одним из предопределённых типов.

## Представители суммарных типов в Scala

### Конструкция enum (перечисления)

enum Color:
case Red, Green, Blue

### Конструкция sealed trait + case objects

sealed trait LogLevel
case object Debug extends LogLevel
case object Info extends LogLevel
case object Warning extends LogLevel
case object Error extends LogLevel

### Тип Option

enum Option[A]:
case Some(value: A)
case None

### Тип Either

enum Either[A, B]:
case Left(value: A)
case Right(value: B)

### Тип Try

enum Try[T]:
case Success(value: T)
case Failure(exception: Throwable)

### Примитивные типы данных

Примитивные типы представляют выбор одного значения из фиксированного набора альтернатив — это и есть определение Sum Type!

// Примитивные типы — это Sum Types с фиксированной кардинальностью

Boolean // |Boolean| = 2
Unit // |Unit| = 1
Byte // |Byte| = 2⁸ = 256
Char // |Char| = 2¹⁶ = 65536
Short // |Short| = 2¹⁶
Int // |Int| = 2³²
Long // |Long| = 2⁶⁴
Float // |Float| = 2³² (включая особые значения)
Double // |Double| = 2⁶⁴ (включая особые значения)

***Внимание!** Union Type  - не  является суммарным типом , несмотря на то, что очень похож на него.  У его другие математические свойства .*

## Назначение суммарных типов

### 1. Моделирование взаимоисключающих состояний

Sum types позволяют точно выразить, что значение может находиться в одном из нескольких возможных состояний.

### 2. Исключение невалидных состояний

Sum types делают невозможными состояния, которые не должны существовать в программе.

### 3. Явное моделирование бизнес-логики

Sum types делают бизнес-правила видимыми в системе типов.

### 4. Безопасная обработка всех случаев

Компилятор гарантирует, что обработаны все возможные варианты.

## Когда НЕ использовать суммарные типы

Sum types не подходят когда:

- **Множество вариантов может расширяться**: если нужна открытая иерархия, где пользователи могут добавлять новые варианты

- **Нужны данные в вариантах**: когда каждый вариант должен нести специфичные данные (это уже комбинация с Product Types)

- **Простые флаги достаточны**: для простого true/false Boolean проще

##  

---

### Полные данные JSON

<details>
<summary>Показать JSON данные</summary>

```json
{
  "name" : "text",
  "text" : "<h1 style=\"text-align:center;\">Суммарные типы (Sum Types)</h1>\n\n<p>В предыдущем уроке мы говорили о типах-произведениях — когда нам нужно <strong>И</strong> то, <strong>И</strong> другое одновременно. Сегодня мы рассмотрим их противоположность: суммарные типы, которые моделируют <strong>ИЛИ</strong> — ситуации, когда значение может быть <em>либо</em> этим, <em>либо</em> тем.</p>\n\n<p>Представьте светофор: в каждый момент времени он горит <strong>либо</strong> красным, <strong>либо</strong> жёлтым, <strong>либо</strong> зелёным — но никогда несколькими цветами сразу. Или состояние сетевого соединения: оно <strong>либо</strong> установлено, <strong>либо</strong> разрывается, <strong>либо</strong> отсутствует. Именно такие ситуации моделируют суммарные типы.</p>\n\n<p>Почему \"суммарные\"? Всё дело в алгебре типов. Если произведение <code>(A, B)</code> означает \"A <strong>И</strong> B\", и количество возможных значений <em>перемножается</em>, то сумма <code>A | B</code> означает \"A <strong>ИЛИ</strong> B\", и количество возможных значений <em>складывается</em>. В этом уроке мы рассмотрим самую простую форму суммарных типов — \"чистые суммы\" без данных, где каждый вариант существует сам по себе, как флаг или метка. Суммы с данными (ADT — algebraic data types) мы оставим для следующего урока.</p>\n\n<h2 style=\"text-align:center;\">Boolean: простейший суммарный тип</h2>\n\n<p>Самый знакомый каждому программисту суммарный тип — это <code>Boolean</code>. Давайте посмотрим на него через призму алгебры типов:</p>\n\n<pre><code class=\"language-scala\">// Boolean = true | false\n// Алгебраически: Boolean = 1 + 1 = 2</code></pre>\n\n<p>У типа <code>Boolean</code> ровно два возможных значения: <code>true</code> и <code>false</code>. Это <strong>сумма</strong> двух единиц. Каждый из вариантов (<code>true</code> или <code>false</code>) сам по себе не несёт никаких данных — это просто метка, флаг. Кардинальность (количество возможных значений) типа <code>Boolean</code> равна 2.</p>\n\n<p>Сравните это с произведением:</p>\n\n<pre><code class=\"language-scala\">type BoolPair = (Boolean, Boolean)\n// |BoolPair| = |Boolean| × |Boolean| = 2 × 2 = 4\n// Возможные значения: (true, true), (true, false), (false, true), (false, false)</code></pre>\n\n<pre style=\"background:transparent; color:#abb2bf; text-align:left;\"> </pre>\n\n<p>Видите разницу? В сумме значения <strong>складываются</strong> (2 = 1 + 1), в произведении — <strong>умножаются</strong> (4 = 2 × 2). Это фундаментальное различие между \"ИЛИ\" и \"И\".</p>\n\n<p><strong>Тип-сумма (Sum type)</strong> — это тип данных, представляющий собой выбор между несколькими <strong>альтернативными </strong>вариантами, где значение может быть только одним из предопределённых типов.</p>\n\n<h2 style=\"text-align:center;\">Представители суммарных типов в Scala</h2>\n\n<h3 style=\"text-align:center;\">Конструкция enum (перечисления)</h3>\n\n<pre><code class=\"language-scala\">enum Color:\n  case Red, Green, Blue</code></pre>\n\n<h3 style=\"text-align:center;\">Конструкция sealed trait + case objects</h3>\n\n<pre><code class=\"language-scala\">sealed trait LogLevel\ncase object Debug extends LogLevel\ncase object Info extends LogLevel\ncase object Warning extends LogLevel\ncase object Error extends LogLevel</code></pre>\n\n<h3 style=\"text-align:center;\">Тип Option</h3>\n\n<pre><code class=\"language-scala\">enum Option[A]:\n  case Some(value: A)\n  case None</code></pre>\n\n<h3 style=\"text-align:center;\">Тип Either</h3>\n\n<pre><code class=\"language-scala\">enum Either[A, B]:\n  case Left(value: A)\n  case Right(value: B)</code></pre>\n\n<h3 style=\"text-align:center;\">Тип Try</h3>\n\n<pre><code class=\"language-scala\">enum Try[T]:\n  case Success(value: T)\n  case Failure(exception: Throwable)</code></pre>\n\n<h3 style=\"text-align:center;\">Примитивные типы данных</h3>\n\n<p>Примитивные типы представляют выбор одного значения из фиксированного набора альтернатив — это и есть определение Sum Type!</p>\n\n<pre><code class=\"language-scala\">// Примитивные типы — это Sum Types с фиксированной кардинальностью\n\nBoolean   // |Boolean| = 2\nUnit      // |Unit| = 1\nByte      // |Byte| = 2⁸ = 256\nChar      // |Char| = 2¹⁶ = 65536\nShort     // |Short| = 2¹⁶\nInt       // |Int| = 2³²\nLong      // |Long| = 2⁶⁴\nFloat     // |Float| = 2³² (включая особые значения)\nDouble    // |Double| = 2⁶⁴ (включая особые значения)</code></pre>\n\n<p><em><strong>Внимание!</strong> Union Type  - не  является суммарным типом , несмотря на то, что очень похож на него.  У его другие математические свойства .</em></p>\n\n<h2 style=\"text-align:center;\">Назначение суммарных типов</h2>\n\n<h3>1. Моделирование взаимоисключающих состояний</h3>\n\n<p>Sum types позволяют точно выразить, что значение может находиться в одном из нескольких возможных состояний.</p>\n\n<h3>2. Исключение невалидных состояний</h3>\n\n<p>Sum types делают невозможными состояния, которые не должны существовать в программе.</p>\n\n<h3>3. Явное моделирование бизнес-логики</h3>\n\n<p>Sum types делают бизнес-правила видимыми в системе типов.</p>\n\n<h3>4. Безопасная обработка всех случаев</h3>\n\n<p>Компилятор гарантирует, что обработаны все возможные варианты.</p>\n\n<h2 style=\"text-align:center;\">Когда НЕ использовать суммарные типы</h2>\n\n<p>Sum types не подходят когда:</p>\n\n<ol>\n\t<li><strong>Множество вариантов может расширяться</strong>: если нужна открытая иерархия, где пользователи могут добавлять новые варианты</li>\n\t<li><strong>Нужны данные в вариантах</strong>: когда каждый вариант должен нести специфичные данные (это уже комбинация с Product Types)</li>\n\t<li><strong>Простые флаги достаточны</strong>: для простого true/false Boolean проще</li>\n</ol>\n\n<h2> </h2>",
  "video" : null,
  "options" : {
    
  },
  "subtitle_files" : [
  ],
  "is_deprecated" : false
}
```

</details>
