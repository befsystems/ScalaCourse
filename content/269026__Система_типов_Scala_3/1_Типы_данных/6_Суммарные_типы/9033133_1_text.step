{
  "step_id" : 9033133,
  "lesson_id" : 1912370,
  "position" : 1,
  "type" : "unknown",
  "block" : {
    "name" : "text",
    "text" : "<h1 style=\"text-align:center;\">Суммарные типы (Sum Types)</h1>\n\n<p>В предыдущем уроке мы говорили о типах-произведениях — когда нам нужно <strong>И</strong> то, <strong>И</strong> другое одновременно. Сегодня мы рассмотрим их противоположность: суммарные типы, которые моделируют <strong>ИЛИ</strong> — ситуации, когда значение может быть <em>либо</em> этим, <em>либо</em> тем.</p>\n\n<p>Представьте светофор: в каждый момент времени он горит <strong>либо</strong> красным, <strong>либо</strong> жёлтым, <strong>либо</strong> зелёным — но никогда несколькими цветами сразу. Или состояние сетевого соединения: оно <strong>либо</strong> установлено, <strong>либо</strong> разрывается, <strong>либо</strong> отсутствует. Именно такие ситуации моделируют суммарные типы.</p>\n\n<p>Почему \"суммарные\"? Всё дело в алгебре типов. Если произведение <code>(A, B)</code> означает \"A <strong>И</strong> B\", и количество возможных значений <em>перемножается</em>, то сумма <code>A | B</code> означает \"A <strong>ИЛИ</strong> B\", и количество возможных значений <em>складывается</em>. В этом уроке мы рассмотрим самую простую форму суммарных типов — \"чистые суммы\" без данных, где каждый вариант существует сам по себе, как флаг или метка. Суммы с данными (ADT — algebraic data types) мы оставим для следующего урока.</p>\n\n<h2 style=\"text-align:center;\">Boolean: простейший суммарный тип</h2>\n\n<p>Самый знакомый каждому программисту суммарный тип — это <code>Boolean</code>. Давайте посмотрим на него через призму алгебры типов:</p>\n\n<pre><code class=\"language-scala\">// Boolean = true | false\n// Алгебраически: Boolean = 1 + 1 = 2</code></pre>\n\n<p>У типа <code>Boolean</code> ровно два возможных значения: <code>true</code> и <code>false</code>. Это <strong>сумма</strong> двух единиц. Каждый из вариантов (<code>true</code> или <code>false</code>) сам по себе не несёт никаких данных — это просто метка, флаг. Кардинальность (количество возможных значений) типа <code>Boolean</code> равна 2.</p>\n\n<p>Сравните это с произведением:</p>\n\n<pre><code class=\"language-scala\">type BoolPair = (Boolean, Boolean)\n// |BoolPair| = |Boolean| × |Boolean| = 2 × 2 = 4\n// Возможные значения: (true, true), (true, false), (false, true), (false, false)</code></pre>\n\n<pre style=\"background:transparent; color:#abb2bf; text-align:left;\"> </pre>\n\n<p>Видите разницу? В сумме значения <strong>складываются</strong> (2 = 1 + 1), в произведении — <strong>умножаются</strong> (4 = 2 × 2). Это фундаментальное различие между \"ИЛИ\" и \"И\".</p>\n\n<p><strong>Тип-сумма (Sum type)</strong> — это тип данных, представляющий собой выбор между несколькими <strong>альтернативными </strong>вариантами, где значение может быть только одним из предопределённых типов.</p>\n\n<h2 style=\"text-align:center;\">Представители суммарных типов в Scala</h2>\n\n<h3 style=\"text-align:center;\">Конструкция enum (перечисления)</h3>\n\n<pre><code class=\"language-scala\">enum Color:\n  case Red, Green, Blue</code></pre>\n\n<h3 style=\"text-align:center;\">Конструкция sealed trait + case objects</h3>\n\n<pre><code class=\"language-scala\">sealed trait LogLevel\ncase object Debug extends LogLevel\ncase object Info extends LogLevel\ncase object Warning extends LogLevel\ncase object Error extends LogLevel</code></pre>\n\n<h3 style=\"text-align:center;\">Тип Option</h3>\n\n<pre><code class=\"language-scala\">enum Option[A]:\n  case Some(value: A)\n  case None</code></pre>\n\n<h3 style=\"text-align:center;\">Тип Either</h3>\n\n<pre><code class=\"language-scala\">enum Either[A, B]:\n  case Left(value: A)\n  case Right(value: B)</code></pre>\n\n<h3 style=\"text-align:center;\">Тип Try</h3>\n\n<pre><code class=\"language-scala\">enum Try[T]:\n  case Success(value: T)\n  case Failure(exception: Throwable)</code></pre>\n\n<h3 style=\"text-align:center;\">Примитивные типы данных</h3>\n\n<p>Примитивные типы представляют выбор одного значения из фиксированного набора альтернатив — это и есть определение Sum Type!</p>\n\n<pre><code class=\"language-scala\">// Примитивные типы — это Sum Types с фиксированной кардинальностью\n\nBoolean   // |Boolean| = 2\nUnit      // |Unit| = 1\nByte      // |Byte| = 2⁸ = 256\nChar      // |Char| = 2¹⁶ = 65536\nShort     // |Short| = 2¹⁶\nInt       // |Int| = 2³²\nLong      // |Long| = 2⁶⁴\nFloat     // |Float| = 2³² (включая особые значения)\nDouble    // |Double| = 2⁶⁴ (включая особые значения)</code></pre>\n\n<p><em><strong>Внимание!</strong> Union Type  - не  является суммарным типом , несмотря на то, что очень похож на него.  У его другие математические свойства .</em></p>\n\n<h2 style=\"text-align:center;\">Назначение суммарных типов</h2>\n\n<h3>1. Моделирование взаимоисключающих состояний</h3>\n\n<p>Sum types позволяют точно выразить, что значение может находиться в одном из нескольких возможных состояний.</p>\n\n<h3>2. Исключение невалидных состояний</h3>\n\n<p>Sum types делают невозможными состояния, которые не должны существовать в программе.</p>\n\n<h3>3. Явное моделирование бизнес-логики</h3>\n\n<p>Sum types делают бизнес-правила видимыми в системе типов.</p>\n\n<h3>4. Безопасная обработка всех случаев</h3>\n\n<p>Компилятор гарантирует, что обработаны все возможные варианты.</p>\n\n<h2 style=\"text-align:center;\">Когда НЕ использовать суммарные типы</h2>\n\n<p>Sum types не подходят когда:</p>\n\n<ol>\n\t<li><strong>Множество вариантов может расширяться</strong>: если нужна открытая иерархия, где пользователи могут добавлять новые варианты</li>\n\t<li><strong>Нужны данные в вариантах</strong>: когда каждый вариант должен нести специфичные данные (это уже комбинация с Product Types)</li>\n\t<li><strong>Простые флаги достаточны</strong>: для простого true/false Boolean проще</li>\n</ol>\n\n<h2> </h2>",
    "video" : null,
    "options" : {
      
    },
    "subtitle_files" : [
    ],
    "is_deprecated" : false
  },
  "name" : "text",
  "course_id" : 269026,
  "course_name" : " Система типов Scala 3",
  "exported_at" : "2026-01-10T10:36:27.5489679"
}