{
  "step_id" : 9034203,
  "lesson_id" : 1912370,
  "position" : 2,
  "type" : "unknown",
  "block" : {
    "name" : "text",
    "text" : "<h1 style=\"text-align:center;\">Конструкция enum</h1>\n\n<p>Основной способ определения суммарных типов это конструкция  <code><strong>enum</strong>.</code></p>\n\n<h2 style=\"text-align:center;\">Синтаксис определения enum</h2>\n\n<pre><code class=\"language-scala\">enum EnumName:  \n  case Value1\n  case Value2\n  case ValueN\n\n// или\nenum EnumName:  \n  case Value1, Value2, ValueN</code></pre>\n\n<p><strong>Value</strong> - может быть как <strong>тип-</strong><strong>одиночка</strong>, так и <strong>тип-</strong><strong>product</strong>. </p>\n\n<h3><strong>Одиночный тип значений:</strong></h3>\n\n<pre><code class=\"language-scala\">// Суммарный тип Color с тремя возможными одиночными значениями - Red, Green, Yellow\nenum Color:\n  case Red      // |Red| = 1\n  case Green    // |Green| = 1\n  case Yellow     // |Yellow| = 1\n\n// Color = Red + Green + Yellow\n// |Color| = |Red| + |Green| + |Yellow| = 1 + 1 + 1 = 3\n\n// Определение значений\nval myColor: Color = Color.Red\nval trafficLight: Color = Color.Green\n\n// Pattern matching\ndef describe(c: Color): String = c match\n  case Color.Red   =&gt; \"Стой\"\n  case Color.Green =&gt; \"Иди\"\n  case Color.Yellow  =&gt; \"Осторожно\"\n// Компилятор проверяет полноту покрытия всех вариантов.</code></pre>\n\n<h3>Значения - тип product:</h3>\n\n<pre><code class=\"language-scala\">// Суммарный тип HttpStatus с тремя возможными product значениями - Ok, NotFound, Error\nenum HttpStatus:\n  case Ok(message: String)\n  case NotFound(path: String)\n  case Error(code: Int)\n\n// HttpStatus = Ok + NotFound + Error\n// |HttpStatus| = |Ok| + |NotFound| + |Error| = ∞ + ∞ + 2³² = ∞\n\n// Определение значений\nval success = HttpStatus.Ok(\"Request processed\")\nval notFound = HttpStatus.NotFound(\"/api/users\")\nval error = HttpStatus.Error(500)\n\n// Pattern matching\ndef handle(result: HttpStatus): String = result match\n  case HttpStatus.Ok(v) =&gt; s\"Ok: $v\"\n  case HttpStatus.NotFound(e) =&gt; s\"NotFound: $e\"\n  case HttpStatus.Error(e) =&gt; s\"Error: $e\"\n// Компилятор проверяет полноту покрытия всех вариантов.\n\n</code></pre>\n\n<h3>Значения - тип product и <strong>тип-</strong><strong>одиночка одновременно</strong></h3>\n\n<pre><code class=\"language-scala\">// Суммарный тип Result с двумя возможными значениями - Ok, Error\nenum Result:\n  case Ok\n  case Error(code: Int)\n\n// Result= Ok + Error\n// |Result| = |Ok| + |Error| = 1 + 2³² \n\n// Определение значений\nval success = Result.Ok\nval error = Result.Error(500)\n\n// Pattern matching\ndef handle(result: Result): String = result match\n  case Result.Ok =&gt; \"Success!\"\n  case Result.Error(e) =&gt; s\"Error: $e\"\n// Компилятор проверяет полноту покрытия всех вариантов.</code></pre>\n\n<h2 style=\"text-align:center;\">Композиция сумм и произведений</h2>\n\n<pre><code class=\"language-scala\">enum Color:\n  case Red, Green, Blue\n// |Color| = 3\n\nenum Size:\n  case Small, Medium, Large\n// |Size| = 3\n\n// Произведение (И)\ntype ColoredSize = (Color, Size)\n// |ColoredSize| = |Color| × |Size| = 3 × 3 = 9\n// Возможные значения: (Red, Small), (Red, Medium), (Red, Large),\n//                     (Green, Small), (Green, Medium), ... и т.д.</code></pre>\n\n<h2 style=\"text-align:center;\">Операции в enum</h2>\n\n<p>В конструкцию <code>enum </code>можно встроить <strong>общие </strong>для типа операции: </p>\n\n<pre><code class=\"language-scala\">enum Color:\n  case Red, Green, Blue\n  \n  def toHex: String = this match\n    case Red   =&gt; \"#FF0000\"\n    case Green =&gt; \"#00FF00\"\n    case Blue  =&gt; \"#0000FF\"\n\nprintln(Color.Red.toHex)  // #FF0000</code></pre>\n\n<p>Операцию можно добавить для <strong>отдельного значения</strong>:</p>\n\n<pre><code class=\"language-scala\">enum Storage:\n  case Empty\n  case Filled(amount: Int):\n    def isFull: Boolean = amount &gt;= 100\n  \nval storage = Storage.Filled(80)\n// storage.isFull доступен только для Filled\n</code></pre>\n\n<h2 style=\"text-align:center;\"> Сравнение enum</h2>\n\n<pre><code class=\"language-scala\">enum Size:\n  case Small, Medium, Large\n\nval s1 = Size.Small\nval s2 = Size.Small\nval s3 = Size.Large\n\nprintln(s1 == s2)  // true\nprintln(s1 == s3)  // false\n</code></pre>\n\n<pre><code class=\"language-scala\">enum Result:\n  case Ok\n  case Error(code: Int)\n\nval error1 = Result.Error(500)\nval error2 = Result.Error(400)\nval error3 = Result.Error(500)\n\nprintln(error1 == error3)  // true\nprintln(error1 == error2)  // false\n</code></pre>\n\n<h2 style=\"text-align:center;\">Порядковый номер</h2>\n\n<p>У значений  <strong><code>enum </code></strong>есть порядковый номер:</p>\n\n<pre><code class=\"language-scala\">enum Priority:\n  case Low, Medium, High\n\nprintln(Priority.Low.ordinal)     // 0\nprintln(Priority.Medium.ordinal)  // 1\nprintln(Priority.High.ordinal)    // 2\n</code></pre>\n\n<p>Это полезно для сортировки.</p>\n\n<h2 style=\"text-align:center;\">Общие поля enum</h2>\n\n<p><strong><code>enum</code></strong> может иметь поля, которые будут обязательно у каждого значения:</p>\n\n<h3>Константное значение:</h3>\n\n<pre><code class=\"language-scala\">enum Planet(val mass: Double, val radius: Double):\n  case Mercury extends Planet(3.303e23, 2.4397e6)\n  case Venus extends Planet(4.869e24, 6.0518e6)\n  case Earth extends Planet(5.976e24, 6.37814e6)\n  \n  def surfaceGravity: Double =\n    val G = 6.67300e-11\n    G * mass / (radius * radius)\n\nval earthMass = Planet.Earth.mass\nval earthGravity = Planet.Earth.surfaceGravity\n</code></pre>\n\n<h3>Задаваемое при создании:</h3>\n\n<pre><code class=\"language-scala\">// Имеем два поля, celsius - внутренее, degrees - внешнее\nenum Temperature(val celsius: Double):\n  case Celsius(degrees: Double) extends Temperature(degrees)\n  case Fahrenheit(degrees: Double) extends Temperature((degrees - 32) * 5 / 9)\n  case Kelvin(degrees: Double) extends Temperature(degrees - 273.15)\n  case AbsoluteZero extends Temperature(-273.15)\n\n\n  val temper: Temperature = Temperature.Fahrenheit(77.0)\n\n  // Pattern matching\n  def handle(temper: Temperature): String = temper match {\n    case c @ Temperature.Fahrenheit(v) =&gt; s\"Temperature = ${c.celsius}°C = $v°F\"\n    case _ =&gt; s\"Temperature not accurate\"\n  }\n\n  println(handle(temper))  //Temperature = 25.0°C = 77.0°F\n</code></pre>",
    "video" : null,
    "options" : {
      
    },
    "subtitle_files" : [
    ],
    "is_deprecated" : false
  },
  "name" : "text",
  "course_id" : 269026,
  "course_name" : " Система типов Scala 3",
  "exported_at" : "2026-01-10T10:36:27.5554144"
}