{
  "step_id" : 9172852,
  "lesson_id" : 2141033,
  "position" : 2,
  "type" : "unknown",
  "block" : {
    "name" : "text",
    "text" : "<h1 style=\"text-align:center;\">Тип Option</h1>\n\n<p>В функциональном программировании мы стремимся избегать использования значения <code>null</code>(отсутствие значения), делая наш код более безопасным. Scala предоставляет для этого тип <code>Option</code> — элегантное решение для представления значений, которые могут отсутствовать.</p>\n\n<h2 style=\"text-align:center;\"> Тип Option - тип с параметром</h2>\n\n<p>Прежде чем углубиться в Option, важно понимать концепцию типов с параметрами. <em>(полностью тема будет раскрыта в следующих уроках)</em></p>\n\n<p>Option является <strong>параметризованным типом</strong> (или generic type). Это означает, что при создании значения типа мы указываем, какой тип данных будет храниться в нём. Например:</p>\n\n<pre><code class=\"language-scala\">val numberOpt: Option[Int] = Option(1)\nval wordOpt: Option[String] = Option(\"hello\")\nval flagOpt: Option[Boolean] = Option(true)</code></pre>\n\n<p>Запись <strong><code>Option[Int]</code></strong> читается как \"контейнер Option для целого числа\", где <code>Int</code> — это <strong>параметр типа</strong>. Можно провести аналогию: <strong><code>Option</code></strong> — это коробка, а параметр типа указывает, что именно в ней хранится.</p>\n\n<p>Компилятор Scala использует эту информацию для проверки типов во время компиляции, предотвращая ошибки:</p>\n\n<pre><code class=\"language-scala\">val numberOpt: Option[Int] = Option(1)\nval wordOpt: Option[Int] = Option(\"text\") // Ошибка компиляции!</code></pre>\n\n<h2 style=\"text-align:center;\">Тип Option</h2>\n\n<p><code>Option[A]</code> — это параметризованный тип, который представляет опциональное (необязательное) значение типа <code>A</code>. Это контейнер, который может содержать значение: <strong><code>Some(value)</code></strong>, или быть пустым:<strong><code>None</code></strong>.</p>\n\n<p>Упрощенно его можно представить его как:</p>\n\n<pre><code class=\"language-scala\">enum Option[A]:\n  case Some(value: A)\n  case None</code></pre>\n\n<p>Он имеет два значения:</p>\n\n<ul>\n\t<li><code>None</code> — значение отсутствует</li>\n\t<li><code>Some(value)</code> — значение <code>value</code></li>\n</ul>\n\n<h2 style=\"text-align:center;\">Создание Option</h2>\n\n<p>Существует несколько способов создать <code>Option</code>:</p>\n\n<pre><code class=\"language-scala\">// Явное создание\nval some: Option[Int] = Some(10)\nval none: Option[Int] = None\n\n// Из nullable значения\nval maybeNull: String = null\nval option: Option[String] = Option(maybeNull)  // None\n\nval notNull: String = \"Hello\"\nval option2: Option[String] = Option(notNull)   // Some(\"Hello\")\n\n//Условное создание\nval a = 1\nval b = 0\nval resOpt: Option[Int] = Option.when(b != 0)(a / b) // None\n</code></pre>\n\n<h2 style=\"text-align:center;\">Основные операции</h2>\n\n<ol>\n\t<li><strong><code>map</code></strong> — преобразование значения внутри Option</li>\n\t<li><strong><code>flatMap</code></strong> — преобразование с возвратом Option</li>\n\t<li><strong><code>filter</code></strong> — фильтрация значения</li>\n\t<li><strong><code>getOrElse</code></strong> — получение значения или значения по умолчанию</li>\n\t<li><strong><code>fold</code></strong> — обработка обоих случаев</li>\n\t<li><strong><code>orElse</code></strong> — альтернатива при None</li>\n</ol>\n\n<h2 style=\"text-align:center;\">Pattern Matching</h2>\n\n<pre><code class=\"language-scala\">def describe(opt: Option[Int]): String = \n  opt match\n    case Some(value) =&gt; s\"Значение: $value\"\n    case None =&gt; \"Значение отсутствует\"\n\nprintln(describe(Some(5)))  // Значение: 5\nprintln(describe(None))     // Значение отсутствует\n\n// Вложенный pattern matching\ndef processNested(opt: Option[Option[Int]]): String = \n  opt match\n    case Some(Some(value)) =&gt; s\"Вложенное значение: $value\"\n    case Some(None) =&gt; \"Внутреннее значение отсутствует\"\n    case None =&gt; \"Внешнее значение отсутствует\"\n</code></pre>\n\n<h2 style=\"text-align:center;\">Option как тип-сумма (Sum Type)</h2>\n\n<p><code>Option</code> является <strong>типом-суммой</strong>. Тип-сумма — это тип, который может принимать одну из нескольких альтернативных форм. В случае <code>Option</code> существует две альтернативы: <code>Some</code> или <code>None</code>.</p>\n\n<p>Математически это можно записать как:</p>\n\n<pre><code>Option[A] = Some(A) + None\n</code></pre>\n\n<p>Это означает, что значение типа <code>Option[Int]</code> может быть <strong>либо</strong> <code>Some(Int)</code>, <strong>либо</strong> <code>None</code> — третьего не дано. Такая структура противоположна типам-произведениям (product types), таким как кортежи или case-классы, которые содержат все свои компоненты одновременно.</p>\n\n<pre><code class=\"language-scala\">// Тип-сумма: ЛИБО Some, ЛИБО None\nval option1: Option[Int] = Some(5)\nval option2: Option[Int] = None\n\n// Тип-произведение: содержит И x, И y одновременно\ncase class Point(x: Int, y: Int)\nval point = Point(3, 4)\n</code></pre>\n\n<p>Тип-сумма заставляет нас явно обрабатывать каждый возможный вариант через <strong>pattern matching</strong>, что делает код безопаснее.</p>\n\n<h2 style=\"text-align:center;\">Option замена null</h2>\n\n<p>Рассмотрим проблему с <code>null</code>:</p>\n\n<pre><code class=\"language-scala\">val s: String = null  // компилируется, но s = null\nval res = s + 'a'     // NullPointerException в runtime!</code></pre>\n\n<p>Компилятор не помощник в таком случае. Нужно самостоятельно как-то контролировать возможность появления значения <code>null .</code></p>\n\n<p>Другой пример:</p>\n\n<pre><code class=\"language-scala\">// Плохо: использование null\ndef findAge(name: String): Int = \n  if name == \"Alice\" then 25\n  else null  // Ошибка компиляции! Int не может быть null\n\n// Хорошо: использование Option\ndef findAge(name: String): Option[Int] = \n  if name == \"Alice\" then Some(25)\n  else None\n</code></pre>\n\n<p>С <code>Option</code> система типов <strong>заставляет</strong> нас явно обработать случай отсутствия значения.</p>\n\n<p> </p>\n\n<p> </p>\n\n<h2> </h2>\n\n<table>\n\t<thead>\n\t\t<tr>\n\t\t\t<th> </th>\n\t\t\t<th> </th>\n\t\t\t<th> </th>\n\t\t</tr>\n\t</thead>\n\t<tbody>\n\t\t<tr>\n\t\t\t<td> </td>\n\t\t\t<td> </td>\n\t\t\t<td> </td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td> </td>\n\t\t\t<td> </td>\n\t\t\t<td> </td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td> </td>\n\t\t\t<td> </td>\n\t\t\t<td> </td>\n\t\t</tr>\n\t</tbody>\n</table>\n\n<h2> </h2>",
    "video" : null,
    "options" : {
      
    },
    "subtitle_files" : [
    ],
    "is_deprecated" : false
  },
  "name" : "text",
  "course_id" : 269026,
  "course_name" : " Система типов Scala 3",
  "exported_at" : "2026-01-10T10:36:34.6049591"
}