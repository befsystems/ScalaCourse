# Материал (Шаг 4)

## Информация о шаге

- **ID шага**: 9172863
- **Позиция**: 4
- **Тип**: text
- **Курс**:  Система типов Scala 3
- **Экспортирован**: 2026-01-10T10:36:34.6183487

## Содержание

# Примеры использования Option

## Извлечение значений

// getOrElse - самый безопасный способ
val age = Some(25).getOrElse(0) // 25
val missing = None.getOrElse(0) // 0

// orElse - возвращает альтернативный Option
val primary = None
val backup = Some(100)
val result = primary.orElse(backup) // Some(100)

// orNull - конвертация обратно в nullable (не рекомендуется)
val str: String = Some("hello").orNull // "hello"
val nullStr: String = None.orNull // null

## Проверка значений

// contains - проверка конкретного значения
val hasThree = Some(3).contains(3) // true
val hasFive = Some(3).contains(5) // false
val noneContains = None.contains(3) // false

// exists - проверка условия
val positive = Some(5).exists(_ > 0) // true
val negative = Some(-3).exists(_ > 0) // false
val noneExists = None.exists(_ > 0) // false

// forall - все элементы удовлетворяют условию
// Важно: для None всегда возвращает true!
val someForall = Some(5).forall(_ > 0) // true
val noneForall = None.forall(_ > 0) // true (!)

## Трансформация значений

// map - преобразование значения
val doubled = Some(5).map(_ * 2) // Some(10)
val length = Some("hello").map(_.length) // Some(5)

// flatMap - для функций, возвращающих Option
def half(n: Int): Option[Int] =
if n % 2 == 0 then Some(n / 2) else None

val result1 = Some(10).flatMap(half) // Some(5)
val result2 = Some(7).flatMap(half) // None
val result3 = None.flatMap(half) // None

// flatten - разворачивание вложенных Option
val nested = Some(Some(42))
val flat = nested.flatten // Some(42)

val noneNested = Some(None)
val flatNone = noneNested.flatten // None

// filter - условная фильтрация
val adult = Some(25).filter(_ >= 18) // Some(25)
val child = Some(12).filter(_ >= 18) // None

// filterNot - инверсия filter
val notAdult = Some(12).filterNot(_ >= 18) // Some(12)
val notChild = Some(25).filterNot(_ >= 18) // None

// collect - применение частичной функции
val result = Some(5).collect {
case x if x > 3 => x * 2
} // Some(10)

val filtered = Some(2).collect {
case x if x > 3 => x * 2
} // None

## Работа с побочными эффектами

// foreach - выполнение действия
Some(5).foreach(x => println(s"Значение: $x")) // печатает "Значение: 5"
None.foreach(x => println(s"Значение: $x")) // ничего не печатает

// fold - свёртка с начальным значением
val sum1 = Some(5).fold(0)(_ + 10) // 15
val sum2 = None.fold(0)(_ + 10) // 0

def describe(opt: Option[Int]): String =
opt.fold("Нет значения")(x => s"Значение: $x")

println(describe(Some(42))) // "Значение: 42"
println(describe(None)) // "Нет значения"

##  Комбинирование операций

def processAge(input: String): Option[String] =
Option(input)
.map(_.trim)
.filter(_.nonEmpty)
.flatMap(s => try Some(s.toInt) catch case _ => None)
.filter(age => age >= 0 && age <= 120)
.map(age => s"Возраст: $age лет")

println(processAge("25")) // Some(Возраст: 25 лет)
println(processAge("-5")) // None
println(processAge("abc")) // None
println(processAge("")) // None

## Безопасное деление

def safeDivide(a: Int, b: Int): Option[Double] =
if b == 0 then None else Some(a.toDouble / b)

val result1 = safeDivide(10, 2).getOrElse(0.0) // 5.0
val result2 = safeDivide(10, 0).getOrElse(0.0) // 0.0

// С обработкой через map
val formatted = safeDivide(10, 3).map(x => f"$x%.2f") // Some("3.33")

## Парсинг входных данных

def parsePositiveInt(s: String): Option[Int] =
try
val num = s.toInt
if num > 0 then Some(num) else None
catch
case _: NumberFormatException => None

val valid = parsePositiveInt("42") // Some(42)
val invalid = parsePositiveInt("-5") // None
val error = parsePositiveInt("abc") // None

## Поиск в коллекции

def findById(id: Int, users: Seq[(Int, String)]): Option[String] =
users.find(_._1 == id).map(_._2)

val users = Seq((1, "Alice"), (2, "Bob"), (3, "Charlie"))

val user1 = findById(2, users) // Some("Bob")
val user2 = findById(5, users) // None

// Использование результата
findById(2, users).foreach(name => println(s"Найден: $name"))

## Конфигурация с значениями по умолчанию

case class Config(
timeout: Option[Int],
maxRetries: Option[Int],
debug: Option[Boolean]
)

def applyDefaults(config: Config): Config =
Config(
timeout = config.timeout.orElse(Some(5000)),
maxRetries = config.maxRetries.orElse(Some(3)),
debug = config.debug.orElse(Some(false))
)

val userConfig = Config(Some(10000), None, Some(true))
val finalConfig = applyDefaults(userConfig)
// Config(Some(10000), Some(3), Some(true))

## Валидация данных

def validateEmail(email: String): Option[String] =
Option(email)
.map(_.trim)
.filter(_.nonEmpty)
.filter(_.contains("@"))
.filter(_.length >= 5)

val valid = validateEmail("user@example.com") // Some("user@example.com")
val invalid1 = validateEmail("") // None
val invalid2 = validateEmail("invalid") // None

## Цепочка вычислений

def increment(n: Int): Option[Int] = Some(n + 1)
def double(n: Int): Option[Int] = Some(n * 2)
def tooBig(n: Int): Option[Int] = if n > 100 then None else Some(n)

val result = Some(5)
.flatMap(increment) // Some(6)
.flatMap(double) // Some(12)
.flatMap(tooBig) // Some(12)

val overflow = Some(50)
.flatMap(increment) // Some(51)
.flatMap(double) // Some(102)
.flatMap(tooBig) // None

## Обработка множественных опциональных значений

case class Person(name: String, age: Option[Int], email: Option[String])

def createProfile(person: Person): String =
val ageStr = person.age.map(a => s", возраст: $a").getOrElse("")
val emailStr = person.email.map(e => s", email: $e").getOrElse("")
s"${person.name}$ageStr$emailStr"

val full = Person("Alice", Some(30), Some("alice@example.com"))
println(createProfile(full))
// Alice, возраст: 30, email: alice@example.com

val partial = Person("Bob", None, Some("bob@example.com"))
println(createProfile(partial))
// Bob, email: bob@example.com

## Комбинирование нескольких Option

### Используя `flatMap` и `map`

def calculateTotal(price: Option[Int], quantity: Option[Int], discount: Option[Int]): Option[Int] =
price.flatMap { p =>
quantity.flatMap { q =>
discount.map { d =>
(p * q) - d
}
}
}

### Используя pattern matching

def calculateTotal(price: Option[Int], quantity: Option[Int], discount: Option[Int]): Option[Int] =
(price, quantity, discount) match {
case (Some(p), Some(q), Some(d)) => Some((p * q) - d)
case _ => None
}

### Используя `zip`

def calculateTotal(price: Option[Int], quantity: Option[Int], discount: Option[Int]): Option[Int] =
price.zip(quantity).zip(discount).map { case ((p, q), d) => (p * q) - d }

## Ленивое вычисление альтернатив

def expensiveComputation(): Option[Int] =
println("Вычисление...")
Some(42)

// orElse вычисляет альтернативу только при необходимости
val result1 = Some(10).orElse(expensiveComputation())
// возвращает Some(10)

val result2 = None.orElse(expensiveComputation())
// Печатает "Вычисление...", возвращает Some(42)

## Антипаттерны и лучшие практики

### ❌ Избегайте

// Не используйте get без проверки
val value = option.get // Может выбросить исключение!

// Не используйте isDefined с последующим get
if option.isDefined then
val value = option.get
// ...

### ✅ Используйте

// Pattern matching
option match
case Some(value) => // используйте value
case None => // обработайте отсутствие

// getOrElse
val value = option.getOrElse(defaultValue)

// map/flatMap
option.map(value => // преобразуйте value)

// foreach для побочных эффектов
option.foreach(value => println(value))

---

### Полные данные JSON

<details>
<summary>Показать JSON данные</summary>

```json
{
  "name" : "text",
  "text" : "<h1 style=\"text-align:center;\">Примеры использования Option</h1>\n\n<h2 style=\"text-align:center;\">Извлечение значений</h2>\n\n<pre><code class=\"language-scala\">// getOrElse - самый безопасный способ\nval age = Some(25).getOrElse(0)  // 25\nval missing = None.getOrElse(0)  // 0\n\n// orElse - возвращает альтернативный Option\nval primary = None\nval backup = Some(100)\nval result = primary.orElse(backup)  // Some(100)\n\n// orNull - конвертация обратно в nullable (не рекомендуется)\nval str: String = Some(\"hello\").orNull  // \"hello\"\nval nullStr: String = None.orNull       // null\n</code></pre>\n\n<h2 style=\"text-align:center;\">Проверка значений</h2>\n\n<pre><code class=\"language-scala\">// contains - проверка конкретного значения\nval hasThree = Some(3).contains(3)  // true\nval hasFive = Some(3).contains(5)   // false\nval noneContains = None.contains(3) // false\n\n// exists - проверка условия\nval positive = Some(5).exists(_ &gt; 0)     // true\nval negative = Some(-3).exists(_ &gt; 0)    // false\nval noneExists = None.exists(_ &gt; 0)      // false\n\n// forall - все элементы удовлетворяют условию\n// Важно: для None всегда возвращает true!\nval someForall = Some(5).forall(_ &gt; 0)   // true\nval noneForall = None.forall(_ &gt; 0)      // true (!)\n</code></pre>\n\n<h2 style=\"text-align:center;\">Трансформация значений</h2>\n\n<pre><code class=\"language-scala\">// map - преобразование значения\nval doubled = Some(5).map(_ * 2)        // Some(10)\nval length = Some(\"hello\").map(_.length) // Some(5)\n\n// flatMap - для функций, возвращающих Option\ndef half(n: Int): Option[Int] = \n  if n % 2 == 0 then Some(n / 2) else None\n\nval result1 = Some(10).flatMap(half)  // Some(5)\nval result2 = Some(7).flatMap(half)   // None\nval result3 = None.flatMap(half)      // None\n\n// flatten - разворачивание вложенных Option\nval nested = Some(Some(42))\nval flat = nested.flatten  // Some(42)\n\nval noneNested = Some(None)\nval flatNone = noneNested.flatten  // None\n\n// filter - условная фильтрация\nval adult = Some(25).filter(_ &gt;= 18)    // Some(25)\nval child = Some(12).filter(_ &gt;= 18)    // None\n\n// filterNot - инверсия filter\nval notAdult = Some(12).filterNot(_ &gt;= 18)  // Some(12)\nval notChild = Some(25).filterNot(_ &gt;= 18)  // None\n\n// collect - применение частичной функции\nval result = Some(5).collect {\n  case x if x &gt; 3 =&gt; x * 2\n}  // Some(10)\n\nval filtered = Some(2).collect {\n  case x if x &gt; 3 =&gt; x * 2\n}  // None\n</code></pre>\n\n<h2 style=\"text-align:center;\">Работа с побочными эффектами</h2>\n\n<pre><code class=\"language-scala\">// foreach - выполнение действия\nSome(5).foreach(x =&gt; println(s\"Значение: $x\"))  // печатает \"Значение: 5\"\nNone.foreach(x =&gt; println(s\"Значение: $x\"))     // ничего не печатает\n\n// fold - свёртка с начальным значением\nval sum1 = Some(5).fold(0)(_ + 10)  // 15\nval sum2 = None.fold(0)(_ + 10)     // 0\n\ndef describe(opt: Option[Int]): String = \n  opt.fold(\"Нет значения\")(x =&gt; s\"Значение: $x\")\n\nprintln(describe(Some(42)))  // \"Значение: 42\"\nprintln(describe(None))      // \"Нет значения\"\n</code></pre>\n\n<h2 style=\"text-align:center;\"> Комбинирование операций</h2>\n\n<pre><code class=\"language-scala\">def processAge(input: String): Option[String] = \n  Option(input)\n    .map(_.trim)\n    .filter(_.nonEmpty)\n    .flatMap(s =&gt; try Some(s.toInt) catch case _ =&gt; None)\n    .filter(age =&gt; age &gt;= 0 &amp;&amp; age &lt;= 120)\n    .map(age =&gt; s\"Возраст: $age лет\")\n\nprintln(processAge(\"25\"))     // Some(Возраст: 25 лет)\nprintln(processAge(\"-5\"))     // None\nprintln(processAge(\"abc\"))    // None\nprintln(processAge(\"\"))       // None\n</code></pre>\n\n<h2 style=\"text-align:center;\">Безопасное деление</h2>\n\n<pre><code class=\"language-scala\">def safeDivide(a: Int, b: Int): Option[Double] = \n  if b == 0 then None else Some(a.toDouble / b)\n\nval result1 = safeDivide(10, 2).getOrElse(0.0)  // 5.0\nval result2 = safeDivide(10, 0).getOrElse(0.0)  // 0.0\n\n// С обработкой через map\nval formatted = safeDivide(10, 3).map(x =&gt; f\"$x%.2f\")  // Some(\"3.33\")\n</code></pre>\n\n<h2 style=\"text-align:center;\">Парсинг входных данных</h2>\n\n<pre><code class=\"language-scala\">def parsePositiveInt(s: String): Option[Int] = \n  try \n    val num = s.toInt\n    if num &gt; 0 then Some(num) else None\n  catch \n    case _: NumberFormatException =&gt; None\n\nval valid = parsePositiveInt(\"42\")    // Some(42)\nval invalid = parsePositiveInt(\"-5\")  // None\nval error = parsePositiveInt(\"abc\")   // None\n</code></pre>\n\n<h2 style=\"text-align:center;\">Поиск в коллекции</h2>\n\n<pre><code class=\"language-scala\">def findById(id: Int, users: Seq[(Int, String)]): Option[String] = \n  users.find(_._1 == id).map(_._2)\n\nval users = Seq((1, \"Alice\"), (2, \"Bob\"), (3, \"Charlie\"))\n\nval user1 = findById(2, users)  // Some(\"Bob\")\nval user2 = findById(5, users)  // None\n\n// Использование результата\nfindById(2, users).foreach(name =&gt; println(s\"Найден: $name\"))\n</code></pre>\n\n<h2 style=\"text-align:center;\">Конфигурация с значениями по умолчанию</h2>\n\n<pre><code class=\"language-scala\">case class Config(\n  timeout: Option[Int],\n  maxRetries: Option[Int],\n  debug: Option[Boolean]\n)\n\ndef applyDefaults(config: Config): Config = \n  Config(\n    timeout = config.timeout.orElse(Some(5000)),\n    maxRetries = config.maxRetries.orElse(Some(3)),\n    debug = config.debug.orElse(Some(false))\n  )\n\nval userConfig = Config(Some(10000), None, Some(true))\nval finalConfig = applyDefaults(userConfig)\n// Config(Some(10000), Some(3), Some(true))\n</code></pre>\n\n<h2 style=\"text-align:center;\">Валидация данных</h2>\n\n<pre><code class=\"language-scala\">def validateEmail(email: String): Option[String] = \n  Option(email)\n    .map(_.trim)\n    .filter(_.nonEmpty)\n    .filter(_.contains(\"@\"))\n    .filter(_.length &gt;= 5)\n\nval valid = validateEmail(\"user@example.com\")  // Some(\"user@example.com\")\nval invalid1 = validateEmail(\"\")               // None\nval invalid2 = validateEmail(\"invalid\")        // None\n</code></pre>\n\n<h2 style=\"text-align:center;\">Цепочка вычислений</h2>\n\n<pre><code class=\"language-scala\">def increment(n: Int): Option[Int] = Some(n + 1)\ndef double(n: Int): Option[Int] = Some(n * 2)\ndef tooBig(n: Int): Option[Int] = if n &gt; 100 then None else Some(n)\n\nval result = Some(5)\n  .flatMap(increment)  // Some(6)\n  .flatMap(double)     // Some(12)\n  .flatMap(tooBig)     // Some(12)\n\nval overflow = Some(50)\n  .flatMap(increment)  // Some(51)\n  .flatMap(double)     // Some(102)\n  .flatMap(tooBig)     // None\n</code></pre>\n\n<h2 style=\"text-align:center;\">Обработка множественных опциональных значений</h2>\n\n<pre><code class=\"language-scala\">case class Person(name: String, age: Option[Int], email: Option[String])\n\ndef createProfile(person: Person): String = \n  val ageStr = person.age.map(a =&gt; s\", возраст: $a\").getOrElse(\"\")\n  val emailStr = person.email.map(e =&gt; s\", email: $e\").getOrElse(\"\")\n  s\"${person.name}$ageStr$emailStr\"\n\nval full = Person(\"Alice\", Some(30), Some(\"alice@example.com\"))\nprintln(createProfile(full))  \n// Alice, возраст: 30, email: alice@example.com\n\nval partial = Person(\"Bob\", None, Some(\"bob@example.com\"))\nprintln(createProfile(partial))  \n// Bob, email: bob@example.com\n</code></pre>\n\n<h2 style=\"text-align:center;\">Комбинирование нескольких Option</h2>\n\n<h3>Используя <code>flatMap</code> и <code>map</code></h3>\n\n<pre><code class=\"language-scala\">def calculateTotal(price: Option[Int], quantity: Option[Int], discount: Option[Int]): Option[Int] = \n  price.flatMap { p =&gt;\n    quantity.flatMap { q =&gt;\n      discount.map { d =&gt;\n        (p * q) - d\n      }\n    }\n  }</code></pre>\n\n<h3>Используя pattern matching</h3>\n\n<pre><code class=\"language-scala\">def calculateTotal(price: Option[Int], quantity: Option[Int], discount: Option[Int]): Option[Int] = \n  (price, quantity, discount) match {\n    case (Some(p), Some(q), Some(d)) =&gt; Some((p * q) - d)\n    case _ =&gt; None\n  }</code></pre>\n\n<h3>Используя <code>zip</code></h3>\n\n<pre><code class=\"language-scala\">def calculateTotal(price: Option[Int], quantity: Option[Int], discount: Option[Int]): Option[Int] = \n  price.zip(quantity).zip(discount).map { case ((p, q), d) =&gt; (p * q) - d }</code></pre>\n\n<h2 style=\"text-align:center;\">Ленивое вычисление альтернатив</h2>\n\n<pre><code class=\"language-scala\">def expensiveComputation(): Option[Int] = \n  println(\"Вычисление...\")\n  Some(42)\n\n// orElse вычисляет альтернативу только при необходимости\nval result1 = Some(10).orElse(expensiveComputation())  \n// возвращает Some(10)\n\nval result2 = None.orElse(expensiveComputation())       \n// Печатает \"Вычисление...\", возвращает Some(42)\n</code></pre>\n\n<h2 style=\"text-align:center;\">Антипаттерны и лучшие практики</h2>\n\n<h3>❌ Избегайте</h3>\n\n<pre><code class=\"language-scala\">// Не используйте get без проверки\nval value = option.get  // Может выбросить исключение!\n\n// Не используйте isDefined с последующим get\nif option.isDefined then\n  val value = option.get\n  // ...\n</code></pre>\n\n<h3>✅ Используйте</h3>\n\n<pre><code class=\"language-scala\">// Pattern matching\noption match\n  case Some(value) =&gt; // используйте value\n  case None =&gt; // обработайте отсутствие\n\n// getOrElse\nval value = option.getOrElse(defaultValue)\n\n// map/flatMap\noption.map(value =&gt; // преобразуйте value)\n\n// foreach для побочных эффектов\noption.foreach(value =&gt; println(value))\n</code></pre>",
  "video" : null,
  "options" : {
    
  },
  "subtitle_files" : [
  ],
  "is_deprecated" : false
}
```

</details>
