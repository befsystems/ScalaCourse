{
  "step_id" : 9172863,
  "lesson_id" : 2141033,
  "position" : 4,
  "type" : "unknown",
  "block" : {
    "name" : "text",
    "text" : "<h1 style=\"text-align:center;\">Примеры использования Option</h1>\n\n<h2 style=\"text-align:center;\">Извлечение значений</h2>\n\n<pre><code class=\"language-scala\">// getOrElse - самый безопасный способ\nval age = Some(25).getOrElse(0)  // 25\nval missing = None.getOrElse(0)  // 0\n\n// orElse - возвращает альтернативный Option\nval primary = None\nval backup = Some(100)\nval result = primary.orElse(backup)  // Some(100)\n\n// orNull - конвертация обратно в nullable (не рекомендуется)\nval str: String = Some(\"hello\").orNull  // \"hello\"\nval nullStr: String = None.orNull       // null\n</code></pre>\n\n<h2 style=\"text-align:center;\">Проверка значений</h2>\n\n<pre><code class=\"language-scala\">// contains - проверка конкретного значения\nval hasThree = Some(3).contains(3)  // true\nval hasFive = Some(3).contains(5)   // false\nval noneContains = None.contains(3) // false\n\n// exists - проверка условия\nval positive = Some(5).exists(_ &gt; 0)     // true\nval negative = Some(-3).exists(_ &gt; 0)    // false\nval noneExists = None.exists(_ &gt; 0)      // false\n\n// forall - все элементы удовлетворяют условию\n// Важно: для None всегда возвращает true!\nval someForall = Some(5).forall(_ &gt; 0)   // true\nval noneForall = None.forall(_ &gt; 0)      // true (!)\n</code></pre>\n\n<h2 style=\"text-align:center;\">Трансформация значений</h2>\n\n<pre><code class=\"language-scala\">// map - преобразование значения\nval doubled = Some(5).map(_ * 2)        // Some(10)\nval length = Some(\"hello\").map(_.length) // Some(5)\n\n// flatMap - для функций, возвращающих Option\ndef half(n: Int): Option[Int] = \n  if n % 2 == 0 then Some(n / 2) else None\n\nval result1 = Some(10).flatMap(half)  // Some(5)\nval result2 = Some(7).flatMap(half)   // None\nval result3 = None.flatMap(half)      // None\n\n// flatten - разворачивание вложенных Option\nval nested = Some(Some(42))\nval flat = nested.flatten  // Some(42)\n\nval noneNested = Some(None)\nval flatNone = noneNested.flatten  // None\n\n// filter - условная фильтрация\nval adult = Some(25).filter(_ &gt;= 18)    // Some(25)\nval child = Some(12).filter(_ &gt;= 18)    // None\n\n// filterNot - инверсия filter\nval notAdult = Some(12).filterNot(_ &gt;= 18)  // Some(12)\nval notChild = Some(25).filterNot(_ &gt;= 18)  // None\n\n// collect - применение частичной функции\nval result = Some(5).collect {\n  case x if x &gt; 3 =&gt; x * 2\n}  // Some(10)\n\nval filtered = Some(2).collect {\n  case x if x &gt; 3 =&gt; x * 2\n}  // None\n</code></pre>\n\n<h2 style=\"text-align:center;\">Работа с побочными эффектами</h2>\n\n<pre><code class=\"language-scala\">// foreach - выполнение действия\nSome(5).foreach(x =&gt; println(s\"Значение: $x\"))  // печатает \"Значение: 5\"\nNone.foreach(x =&gt; println(s\"Значение: $x\"))     // ничего не печатает\n\n// fold - свёртка с начальным значением\nval sum1 = Some(5).fold(0)(_ + 10)  // 15\nval sum2 = None.fold(0)(_ + 10)     // 0\n\ndef describe(opt: Option[Int]): String = \n  opt.fold(\"Нет значения\")(x =&gt; s\"Значение: $x\")\n\nprintln(describe(Some(42)))  // \"Значение: 42\"\nprintln(describe(None))      // \"Нет значения\"\n</code></pre>\n\n<h2 style=\"text-align:center;\"> Комбинирование операций</h2>\n\n<pre><code class=\"language-scala\">def processAge(input: String): Option[String] = \n  Option(input)\n    .map(_.trim)\n    .filter(_.nonEmpty)\n    .flatMap(s =&gt; try Some(s.toInt) catch case _ =&gt; None)\n    .filter(age =&gt; age &gt;= 0 &amp;&amp; age &lt;= 120)\n    .map(age =&gt; s\"Возраст: $age лет\")\n\nprintln(processAge(\"25\"))     // Some(Возраст: 25 лет)\nprintln(processAge(\"-5\"))     // None\nprintln(processAge(\"abc\"))    // None\nprintln(processAge(\"\"))       // None\n</code></pre>\n\n<h2 style=\"text-align:center;\">Безопасное деление</h2>\n\n<pre><code class=\"language-scala\">def safeDivide(a: Int, b: Int): Option[Double] = \n  if b == 0 then None else Some(a.toDouble / b)\n\nval result1 = safeDivide(10, 2).getOrElse(0.0)  // 5.0\nval result2 = safeDivide(10, 0).getOrElse(0.0)  // 0.0\n\n// С обработкой через map\nval formatted = safeDivide(10, 3).map(x =&gt; f\"$x%.2f\")  // Some(\"3.33\")\n</code></pre>\n\n<h2 style=\"text-align:center;\">Парсинг входных данных</h2>\n\n<pre><code class=\"language-scala\">def parsePositiveInt(s: String): Option[Int] = \n  try \n    val num = s.toInt\n    if num &gt; 0 then Some(num) else None\n  catch \n    case _: NumberFormatException =&gt; None\n\nval valid = parsePositiveInt(\"42\")    // Some(42)\nval invalid = parsePositiveInt(\"-5\")  // None\nval error = parsePositiveInt(\"abc\")   // None\n</code></pre>\n\n<h2 style=\"text-align:center;\">Поиск в коллекции</h2>\n\n<pre><code class=\"language-scala\">def findById(id: Int, users: Seq[(Int, String)]): Option[String] = \n  users.find(_._1 == id).map(_._2)\n\nval users = Seq((1, \"Alice\"), (2, \"Bob\"), (3, \"Charlie\"))\n\nval user1 = findById(2, users)  // Some(\"Bob\")\nval user2 = findById(5, users)  // None\n\n// Использование результата\nfindById(2, users).foreach(name =&gt; println(s\"Найден: $name\"))\n</code></pre>\n\n<h2 style=\"text-align:center;\">Конфигурация с значениями по умолчанию</h2>\n\n<pre><code class=\"language-scala\">case class Config(\n  timeout: Option[Int],\n  maxRetries: Option[Int],\n  debug: Option[Boolean]\n)\n\ndef applyDefaults(config: Config): Config = \n  Config(\n    timeout = config.timeout.orElse(Some(5000)),\n    maxRetries = config.maxRetries.orElse(Some(3)),\n    debug = config.debug.orElse(Some(false))\n  )\n\nval userConfig = Config(Some(10000), None, Some(true))\nval finalConfig = applyDefaults(userConfig)\n// Config(Some(10000), Some(3), Some(true))\n</code></pre>\n\n<h2 style=\"text-align:center;\">Валидация данных</h2>\n\n<pre><code class=\"language-scala\">def validateEmail(email: String): Option[String] = \n  Option(email)\n    .map(_.trim)\n    .filter(_.nonEmpty)\n    .filter(_.contains(\"@\"))\n    .filter(_.length &gt;= 5)\n\nval valid = validateEmail(\"user@example.com\")  // Some(\"user@example.com\")\nval invalid1 = validateEmail(\"\")               // None\nval invalid2 = validateEmail(\"invalid\")        // None\n</code></pre>\n\n<h2 style=\"text-align:center;\">Цепочка вычислений</h2>\n\n<pre><code class=\"language-scala\">def increment(n: Int): Option[Int] = Some(n + 1)\ndef double(n: Int): Option[Int] = Some(n * 2)\ndef tooBig(n: Int): Option[Int] = if n &gt; 100 then None else Some(n)\n\nval result = Some(5)\n  .flatMap(increment)  // Some(6)\n  .flatMap(double)     // Some(12)\n  .flatMap(tooBig)     // Some(12)\n\nval overflow = Some(50)\n  .flatMap(increment)  // Some(51)\n  .flatMap(double)     // Some(102)\n  .flatMap(tooBig)     // None\n</code></pre>\n\n<h2 style=\"text-align:center;\">Обработка множественных опциональных значений</h2>\n\n<pre><code class=\"language-scala\">case class Person(name: String, age: Option[Int], email: Option[String])\n\ndef createProfile(person: Person): String = \n  val ageStr = person.age.map(a =&gt; s\", возраст: $a\").getOrElse(\"\")\n  val emailStr = person.email.map(e =&gt; s\", email: $e\").getOrElse(\"\")\n  s\"${person.name}$ageStr$emailStr\"\n\nval full = Person(\"Alice\", Some(30), Some(\"alice@example.com\"))\nprintln(createProfile(full))  \n// Alice, возраст: 30, email: alice@example.com\n\nval partial = Person(\"Bob\", None, Some(\"bob@example.com\"))\nprintln(createProfile(partial))  \n// Bob, email: bob@example.com\n</code></pre>\n\n<h2 style=\"text-align:center;\">Комбинирование нескольких Option</h2>\n\n<h3>Используя <code>flatMap</code> и <code>map</code></h3>\n\n<pre><code class=\"language-scala\">def calculateTotal(price: Option[Int], quantity: Option[Int], discount: Option[Int]): Option[Int] = \n  price.flatMap { p =&gt;\n    quantity.flatMap { q =&gt;\n      discount.map { d =&gt;\n        (p * q) - d\n      }\n    }\n  }</code></pre>\n\n<h3>Используя pattern matching</h3>\n\n<pre><code class=\"language-scala\">def calculateTotal(price: Option[Int], quantity: Option[Int], discount: Option[Int]): Option[Int] = \n  (price, quantity, discount) match {\n    case (Some(p), Some(q), Some(d)) =&gt; Some((p * q) - d)\n    case _ =&gt; None\n  }</code></pre>\n\n<h3>Используя <code>zip</code></h3>\n\n<pre><code class=\"language-scala\">def calculateTotal(price: Option[Int], quantity: Option[Int], discount: Option[Int]): Option[Int] = \n  price.zip(quantity).zip(discount).map { case ((p, q), d) =&gt; (p * q) - d }</code></pre>\n\n<h2 style=\"text-align:center;\">Ленивое вычисление альтернатив</h2>\n\n<pre><code class=\"language-scala\">def expensiveComputation(): Option[Int] = \n  println(\"Вычисление...\")\n  Some(42)\n\n// orElse вычисляет альтернативу только при необходимости\nval result1 = Some(10).orElse(expensiveComputation())  \n// возвращает Some(10)\n\nval result2 = None.orElse(expensiveComputation())       \n// Печатает \"Вычисление...\", возвращает Some(42)\n</code></pre>\n\n<h2 style=\"text-align:center;\">Антипаттерны и лучшие практики</h2>\n\n<h3>❌ Избегайте</h3>\n\n<pre><code class=\"language-scala\">// Не используйте get без проверки\nval value = option.get  // Может выбросить исключение!\n\n// Не используйте isDefined с последующим get\nif option.isDefined then\n  val value = option.get\n  // ...\n</code></pre>\n\n<h3>✅ Используйте</h3>\n\n<pre><code class=\"language-scala\">// Pattern matching\noption match\n  case Some(value) =&gt; // используйте value\n  case None =&gt; // обработайте отсутствие\n\n// getOrElse\nval value = option.getOrElse(defaultValue)\n\n// map/flatMap\noption.map(value =&gt; // преобразуйте value)\n\n// foreach для побочных эффектов\noption.foreach(value =&gt; println(value))\n</code></pre>",
    "video" : null,
    "options" : {
      
    },
    "subtitle_files" : [
    ],
    "is_deprecated" : false
  },
  "name" : "text",
  "course_id" : 269026,
  "course_name" : " Система типов Scala 3",
  "exported_at" : "2026-01-10T10:36:34.6168607"
}