{
  "step_id" : 9207632,
  "lesson_id" : 2151059,
  "position" : 1,
  "type" : "unknown",
  "block" : {
    "name" : "text",
    "text" : "<h1 style=\"text-align:center;\">Как программы научились красиво падать</h1>\n\n<p>1960-е годы. Программист вводит команду деления на ноль, и... компьютер просто зависает. Навсегда. Приходится идти к системному администратору (который выглядит страшнее, чем любая ошибка) и просить перезагрузить машину. В те времена ошибки обрабатывались примерно так: программа возвращала специальный код (обычно -1 или 0), и вы должны были после каждой операции проверять, не случилось ли чего. Код превращался в бесконечную пирамиду проверок:</p>\n\n<pre><code class=\"language-scala\">val result1 = readFile()\nif (result1 != -1) {\n  val result2 = parseData(result1)\n  if (result2 != -1) {\n    val result3 = saveToDatabase(result2)\n    if (result3 != -1) {\n      // Наконец-то реальная работа!\n    }\n  }\n}\n</code></pre>\n\n<p>Программисты чувствовали себя не инженерами, а параноиками, проверяющими каждый шаг.</p>\n\n<h2 style=\"text-align:center;\">Появление исключений (Exception)</h2>\n\n<p>В 1960-х в языке Lisp появилась первая идея \"нелокального выхода\" — способность выпрыгнуть из глубоко вложенного кода прямо наверх. Но настоящую революцию совершили разработчики языка PL/I в IBM. Они придумали концепцию \"условий\" (conditions) — предков современных исключений.</p>\n\n<p>Идея была гениально проста: если что-то пошло не так, не возвращай код ошибки — <em>выбрось</em> её, как горячую картошку! Пусть кто-то другой ловит. В 1970-х годах CLU от Барбары Лисков формализовал эту концепцию, а в 1980-х C++ с его <code>try-catch</code> сделал исключения мейнстримом.</p>\n\n<p>Программисты вздохнули с облегчением. Теперь код стал выглядеть так:</p>\n\n<pre><code class=\"language-scala\">try {\n  val data = readFile()\n  val parsed = parseData(data)\n  saveToDatabase(parsed)\n  // Просто пишем логику!\n} catch {\n  case e: IOException =&gt; println(\"Проблемы с файлом\")\n  case e: SQLException =&gt; println(\"База данных бунтует\")\n}\n</code></pre>\n\n<h2 style=\"text-align:center;\">Что такое исключение простыми словами</h2>\n\n<p>Представьте: вы готовите борщ по рецепту. Дошли до пункта \"добавить свеклу\", открыли холодильник — а свеклы нет! Обычный рецепт (обычная программа) в этот момент просто зависнет: \"Шаг 5: добавить свеклу... добавить свеклу... добавить свеклу...\"</p>\n\n<p><strong>Исключение</strong> (Exception) — это способ сказать: \"Стоп! Что-то пошло не так. Я не могу продолжать по плану\". Вместо зависания программа \"выбрасывает\" сигнал тревоги и ищет, кто готов с этим разобраться.</p>\n\n<pre><code class=\"language-scala\">// Программа идёт по плану\nprintln(\"Начинаем готовить\")\nprintln(\"Режем картошку\")\n// БАХ! Свеклы нет — выбрасываем исключение\nthrow new Exception(\"Свеклы нет в холодильнике!\")\nprintln(\"Это никогда не выполнится\")\n</code></pre>\n\n<h2 style=\"text-align:center;\">Анатомия try-catch: три кита обработки ошибок</h2>\n\n<p>Конструкция <code>try-catch</code> состоит из трёх частей, как светофор: <strong>try</strong> (попробуй), <strong>catch</strong> (поймай), <strong>finally</strong> (в любом случае).</p>\n\n<h3>1. Try — \"попробуй это\"</h3>\n\n<p>Блок <code>try</code> — это защищённая зона. Вы говорите программе: \"Попробуй выполнить этот код, но будь готов, что может пойти не так\".</p>\n\n<pre><code class=\"language-scala\">try {\n  val result = 10 / 0  // Опасная операция\n  println(result)\n}\n</code></pre>\n\n<p>Программа честно пытается разделить 10 на 0, понимает, что это невозможно, и <strong>выбрасывает</strong> исключение <code>ArithmeticException</code>. Это значение специального типа <code>ArithmeticException.</code></p>\n\n<h3>2. Catch — \"если что-то сломалось\"</h3>\n\n<p>Блок <code>catch</code> — это сеть безопасности. Здесь вы ловите исключения и решаете, что с ними делать.</p>\n\n<pre><code class=\"language-scala\">try {\n  val result = 10 / 0\n} catch {\n  case e: ArithmeticException =&gt; \n    println(\"Эй, на ноль делить нельзя!\")\n  case e: Exception =&gt; \n    println(\"Что-то другое сломалось\")\n}\n</code></pre>\n\n<p><strong>Pattern matching</strong> в Scala позволяет ловить разные типы исключений, как разные виды рыбы разными сетями.</p>\n\n<h3>3. Finally — \"в любом случае сделай это\"</h3>\n\n<p>Блок <code>finally</code> выполняется <strong>всегда</strong>: удалось выполнить код или нет, было исключение или не было.</p>\n\n<pre><code class=\"language-scala\">var file: FileReader = null\ntry {\n  file = new FileReader(\"data.txt\")\n  // читаем файл\n} catch {\n  case e: IOException =&gt; println(\"Файл не найден\")\n} finally {\n  if (file != null) file.close()  // Закроем файл в любом случае\n  println(\"Уборка завершена\")\n}\n</code></pre>\n\n<p><code>Finally</code> — это ваш помощник для уборки: закрыть файлы, освободить ресурсы, выключить свет.</p>\n\n<h2 style=\"text-align:center;\">Как это работает внутри: путешествие исключения</h2>\n\n<p>Когда выбрасывается исключение, происходит магия:</p>\n\n<ol>\n\t<li><strong>Выброс</strong>: Программа создаёт значение исключения (<code>типа ArithmeticException</code>, <code>IOException</code>, etc.) и выбрасывает его командой <strong><code>throw</code></strong></li>\n\t<li><strong>Разматывание стека</strong> (stack unwinding): Программа начинает \"всплывать\" назад по вызовам функций, как дайвер к поверхности</li>\n\t<li><strong>Поиск обработчика</strong>: На каждом уровне она проверяет: \"Есть тут <code>catch</code>?\"</li>\n\t<li><strong>Обработка</strong>: Первый подходящий <code>catch</code> ловит исключение</li>\n\t<li><strong>Продолжение</strong>: После <code>catch</code> (и <code>finally</code>) программа продолжает работу</li>\n</ol>\n\n<pre><code class=\"language-scala\">def level3(): Int = {\n  10 / 0  // Исключение выбрасывается здесь\n}\n\ndef level2(): Int = {\n  level3()  // Пролетает мимо\n}\n\ndef level1(): Unit = {\n  try {\n    level2()  // И мимо\n  } catch {\n    case e: ArithmeticException =&gt; \n      println(\"Поймал на верхнем уровне!\")  // Ловится здесь!\n  }\n}\n</code></pre>\n\n<h2 style=\"text-align:center;\">Типы исключений: иерархия катастроф</h2>\n\n<p>В Scala (как и в Java) исключения образуют семейное дерево:</p>\n\n<pre><code>Throwable (прадедушка всех ошибок)\n├── Error (серьёзные проблемы, обычно не ловим)\n│   └── OutOfMemoryError\n└── Exception (обычные ошибки, ловим эти)\n    ├── RuntimeException (непроверяемые)\n    │   ├── ArithmeticException\n    │   ├── NullPointerException\n    │   └── IndexOutOfBoundsException\n    └── IOException (проверяемые в Java)\n</code></pre>\n\n<p><strong>RuntimeException</strong> — самые частые гости: деление на ноль, обращение к <code>null</code>, выход за границы массива.</p>\n\n<h2 style=\"text-align:center;\">Практические примеры</h2>\n\n<h3>Пример 1: Безопасное преобразование строки в число</h3>\n\n<pre><code class=\"language-scala\">def safeParseInt(str: String): Option[Int] = {\n  try {\n    Some(str.toInt)\n  } catch {\n    case e: NumberFormatException =&gt; None\n  }\n}\n\nsafeParseInt(\"123\")   // Some(123)\nsafeParseInt(\"abc\")   // None — не паникуем, просто возвращаем None\n</code></pre>\n\n<h3>Пример 2: Работа с файлами</h3>\n\n<pre><code class=\"language-scala\">import scala.io.Source\n\ndef readFirstLine(filename: String): String = {\n  var source: Source = null\n  try {\n    source = Source.fromFile(filename)\n    source.getLines().next()\n  } catch {\n    case e: FileNotFoundException =&gt; \"Файл не найден\"\n    case e: IOException =&gt; \"Ошибка чтения\"\n  } finally {\n    if (source != null) source.close()\n  }\n}\n</code></pre>\n\n<h3>Пример 3: Множественная обработка</h3>\n\n<pre><code class=\"language-scala\">def processData(input: String): Unit = {\n  try {\n    val number = input.toInt\n    val result = 100 / number\n    println(s\"Результат: $result\")\n  } catch {\n    case e: NumberFormatException =&gt; \n      println(\"Это не число!\")\n    case e: ArithmeticException =&gt; \n      println(\"На ноль делить нельзя!\")\n    case e: Exception =&gt; \n      println(s\"Неожиданная ошибка: ${e.getMessage}\")\n  }\n}\n</code></pre>\n\n<h2 style=\"text-align:center;\">Важные правила</h2>\n\n<p><strong>1. Ловите конкретные исключения первыми</strong></p>\n\n<pre><code class=\"language-scala\">try {\n  // код\n} catch {\n  case e: FileNotFoundException =&gt; // Сначала специфичное\n  case e: IOException =&gt;           // Потом общее\n  case e: Exception =&gt;             // Самое общее в конце\n}\n</code></pre>\n\n<p><strong>2. Не глушите исключения</strong></p>\n\n<pre><code class=\"language-scala\">// ПЛОХО\ntry {\n  dangerousOperation()\n} catch {\n  case e: Exception =&gt; // молча проглотили ошибку\n}\n\n// ХОРОШО\ntry {\n  dangerousOperation()\n} catch {\n  case e: Exception =&gt; \n    logger.error(\"Ошибка в операции\", e)\n    throw e  // или обработайте осмысленно\n}\n</code></pre>\n\n<p><strong>3. Finally для критичной очистки</strong></p>\n\n<pre><code class=\"language-scala\">val lock = new ReentrantLock()\nlock.lock()\ntry {\n  // критичная секция\n} finally {\n  lock.unlock()  // Освободим блокировку в любом случае\n}\n</code></pre>\n\n<h2 style=\"text-align:center;\">Java и проверяемые исключения: хорошая идея?</h2>\n\n<p>В 1990-х Java решила быть умнее всех и изобрела <em>проверяемые исключения</em> (checked exceptions). Идея: компилятор заставит вас обработать все возможные ошибки. Звучит здорово!</p>\n\n<pre><code class=\"language-java\">public void readFile() throws IOException {\n  // компилятор не даст забыть об IOException\n}\n</code></pre>\n\n<p>Но программисты быстро поняли: это превратилось в кошмар. Каждый метод обрастал <code>throws</code> как ёлка игрушками. Люди начали писать <code>catch (Exception e) {}</code> — ловить всё и игнорировать. Хуже первоначальной проблемы!</p>\n\n<h2 style=\"text-align:center;\"> Scala входит в игру</h2>\n\n<p>Когда Мартин Одерски создавал Scala в начале 2000-х, он посмотрел на Java и сказал: \"Ребята, давайте без фанатизма\". Scala оставила исключения, но сделала их все <em>непроверяемыми</em>. Свобода!</p>\n\n<p>Но Scala предложила кое-что интереснее: функциональный подход к ошибкам через <code>Try</code>, <code>Either</code> и <code>Option</code>:</p>\n\n<pre><code class=\"language-scala\">def divide(a: Int, b: Int): Try[Int] = Try(a / b)\n\ndivide(10, 0) match {\n  case Success(result) =&gt; println(s\"Результат: $result\")\n  case Failure(exception) =&gt; println(\"Делить на ноль нельзя, математика не любит\")\n}\n</code></pre>\n\n<p>Ошибка стала не исключением, а <em>значением</em>. Вы можете передавать её, трансформировать, комбинировать. Это философия: ошибки — это нормально, они часть жизни.</p>\n\n<p>Современные языки вроде Rust вообще отказались от исключений в пользу типа <code>Result</code>. Go использует явное возвращение ошибок (привет из 1960-х, но без пирамид проверок). Scala балансирует между мирами: у вас есть исключения для совместимости с Java, но также мощные функциональные инструменты для элегантной обработки ошибок.</p>\n\n<p>Выбирайте свой стиль. Главное — не забывайте ловить ошибки. Или хотя бы красиво падать.</p>",
    "video" : null,
    "options" : {
      
    },
    "subtitle_files" : [
    ],
    "is_deprecated" : false
  },
  "name" : "text",
  "course_id" : 269026,
  "course_name" : " Система типов Scala 3",
  "exported_at" : "2026-01-10T10:36:24.1358134"
}