# Материал (Шаг 1)

## Информация о шаге

- **ID шага**: 9207632
- **Позиция**: 1
- **Тип**: text
- **Курс**:  Система типов Scala 3
- **Экспортирован**: 2026-01-10T10:36:24.1377966

## Содержание

# Как программы научились красиво падать

1960-е годы. Программист вводит команду деления на ноль, и... компьютер просто зависает. Навсегда. Приходится идти к системному администратору (который выглядит страшнее, чем любая ошибка) и просить перезагрузить машину. В те времена ошибки обрабатывались примерно так: программа возвращала специальный код (обычно -1 или 0), и вы должны были после каждой операции проверять, не случилось ли чего. Код превращался в бесконечную пирамиду проверок:

val result1 = readFile()
if (result1 != -1) {
val result2 = parseData(result1)
if (result2 != -1) {
val result3 = saveToDatabase(result2)
if (result3 != -1) {
// Наконец-то реальная работа!
}
}
}

Программисты чувствовали себя не инженерами, а параноиками, проверяющими каждый шаг.

## Появление исключений (Exception)

В 1960-х в языке Lisp появилась первая идея "нелокального выхода" — способность выпрыгнуть из глубоко вложенного кода прямо наверх. Но настоящую революцию совершили разработчики языка PL/I в IBM. Они придумали концепцию "условий" (conditions) — предков современных исключений.

Идея была гениально проста: если что-то пошло не так, не возвращай код ошибки — *выбрось* её, как горячую картошку! Пусть кто-то другой ловит. В 1970-х годах CLU от Барбары Лисков формализовал эту концепцию, а в 1980-х C++ с его `try-catch` сделал исключения мейнстримом.

Программисты вздохнули с облегчением. Теперь код стал выглядеть так:

try {
val data = readFile()
val parsed = parseData(data)
saveToDatabase(parsed)
// Просто пишем логику!
} catch {
case e: IOException => println("Проблемы с файлом")
case e: SQLException => println("База данных бунтует")
}

## Что такое исключение простыми словами

Представьте: вы готовите борщ по рецепту. Дошли до пункта "добавить свеклу", открыли холодильник — а свеклы нет! Обычный рецепт (обычная программа) в этот момент просто зависнет: "Шаг 5: добавить свеклу... добавить свеклу... добавить свеклу..."

**Исключение** (Exception) — это способ сказать: "Стоп! Что-то пошло не так. Я не могу продолжать по плану". Вместо зависания программа "выбрасывает" сигнал тревоги и ищет, кто готов с этим разобраться.

// Программа идёт по плану
println("Начинаем готовить")
println("Режем картошку")
// БАХ! Свеклы нет — выбрасываем исключение
throw new Exception("Свеклы нет в холодильнике!")
println("Это никогда не выполнится")

## Анатомия try-catch: три кита обработки ошибок

Конструкция `try-catch` состоит из трёх частей, как светофор: **try** (попробуй), **catch** (поймай), **finally** (в любом случае).

### 1. Try — "попробуй это"

Блок `try` — это защищённая зона. Вы говорите программе: "Попробуй выполнить этот код, но будь готов, что может пойти не так".

try {
val result = 10 / 0 // Опасная операция
println(result)
}

Программа честно пытается разделить 10 на 0, понимает, что это невозможно, и **выбрасывает** исключение `ArithmeticException`. Это значение специального типа `ArithmeticException.`

### 2. Catch — "если что-то сломалось"

Блок `catch` — это сеть безопасности. Здесь вы ловите исключения и решаете, что с ними делать.

try {
val result = 10 / 0
} catch {
case e: ArithmeticException =>
println("Эй, на ноль делить нельзя!")
case e: Exception =>
println("Что-то другое сломалось")
}

**Pattern matching** в Scala позволяет ловить разные типы исключений, как разные виды рыбы разными сетями.

### 3. Finally — "в любом случае сделай это"

Блок `finally` выполняется **всегда**: удалось выполнить код или нет, было исключение или не было.

var file: FileReader = null
try {
file = new FileReader("data.txt")
// читаем файл
} catch {
case e: IOException => println("Файл не найден")
} finally {
if (file != null) file.close() // Закроем файл в любом случае
println("Уборка завершена")
}

`Finally` — это ваш помощник для уборки: закрыть файлы, освободить ресурсы, выключить свет.

## Как это работает внутри: путешествие исключения

Когда выбрасывается исключение, происходит магия:

- **Выброс**: Программа создаёт значение исключения (`типа ArithmeticException`, `IOException`, etc.) и выбрасывает его командой **`throw`**

- **Разматывание стека** (stack unwinding): Программа начинает "всплывать" назад по вызовам функций, как дайвер к поверхности

- **Поиск обработчика**: На каждом уровне она проверяет: "Есть тут `catch`?"

- **Обработка**: Первый подходящий `catch` ловит исключение

- **Продолжение**: После `catch` (и `finally`) программа продолжает работу

def level3(): Int = {
10 / 0 // Исключение выбрасывается здесь
}

def level2(): Int = {
level3() // Пролетает мимо
}

def level1(): Unit = {
try {
level2() // И мимо
} catch {
case e: ArithmeticException =>
println("Поймал на верхнем уровне!") // Ловится здесь!
}
}

## Типы исключений: иерархия катастроф

В Scala (как и в Java) исключения образуют семейное дерево:

Throwable (прадедушка всех ошибок)
├── Error (серьёзные проблемы, обычно не ловим)
│ └── OutOfMemoryError
└── Exception (обычные ошибки, ловим эти)
├── RuntimeException (непроверяемые)
│ ├── ArithmeticException
│ ├── NullPointerException
│ └── IndexOutOfBoundsException
└── IOException (проверяемые в Java)

**RuntimeException** — самые частые гости: деление на ноль, обращение к `null`, выход за границы массива.

## Практические примеры

### Пример 1: Безопасное преобразование строки в число

def safeParseInt(str: String): Option[Int] = {
try {
Some(str.toInt)
} catch {
case e: NumberFormatException => None
}
}

safeParseInt("123") // Some(123)
safeParseInt("abc") // None — не паникуем, просто возвращаем None

### Пример 2: Работа с файлами

import scala.io.Source

def readFirstLine(filename: String): String = {
var source: Source = null
try {
source = Source.fromFile(filename)
source.getLines().next()
} catch {
case e: FileNotFoundException => "Файл не найден"
case e: IOException => "Ошибка чтения"
} finally {
if (source != null) source.close()
}
}

### Пример 3: Множественная обработка

def processData(input: String): Unit = {
try {
val number = input.toInt
val result = 100 / number
println(s"Результат: $result")
} catch {
case e: NumberFormatException =>
println("Это не число!")
case e: ArithmeticException =>
println("На ноль делить нельзя!")
case e: Exception =>
println(s"Неожиданная ошибка: ${e.getMessage}")
}
}

## Важные правила

**1. Ловите конкретные исключения первыми**

try {
// код
} catch {
case e: FileNotFoundException => // Сначала специфичное
case e: IOException => // Потом общее
case e: Exception => // Самое общее в конце
}

**2. Не глушите исключения**

// ПЛОХО
try {
dangerousOperation()
} catch {
case e: Exception => // молча проглотили ошибку
}

// ХОРОШО
try {
dangerousOperation()
} catch {
case e: Exception =>
logger.error("Ошибка в операции", e)
throw e // или обработайте осмысленно
}

**3. Finally для критичной очистки**

val lock = new ReentrantLock()
lock.lock()
try {
// критичная секция
} finally {
lock.unlock() // Освободим блокировку в любом случае
}

## Java и проверяемые исключения: хорошая идея?

В 1990-х Java решила быть умнее всех и изобрела *проверяемые исключения* (checked exceptions). Идея: компилятор заставит вас обработать все возможные ошибки. Звучит здорово!

public void readFile() throws IOException {
// компилятор не даст забыть об IOException
}

Но программисты быстро поняли: это превратилось в кошмар. Каждый метод обрастал `throws` как ёлка игрушками. Люди начали писать `catch (Exception e) {}` — ловить всё и игнорировать. Хуже первоначальной проблемы!

##  Scala входит в игру

Когда Мартин Одерски создавал Scala в начале 2000-х, он посмотрел на Java и сказал: "Ребята, давайте без фанатизма". Scala оставила исключения, но сделала их все *непроверяемыми*. Свобода!

Но Scala предложила кое-что интереснее: функциональный подход к ошибкам через `Try`, `Either` и `Option`:

def divide(a: Int, b: Int): Try[Int] = Try(a / b)

divide(10, 0) match {
case Success(result) => println(s"Результат: $result")
case Failure(exception) => println("Делить на ноль нельзя, математика не любит")
}

Ошибка стала не исключением, а *значением*. Вы можете передавать её, трансформировать, комбинировать. Это философия: ошибки — это нормально, они часть жизни.

Современные языки вроде Rust вообще отказались от исключений в пользу типа `Result`. Go использует явное возвращение ошибок (привет из 1960-х, но без пирамид проверок). Scala балансирует между мирами: у вас есть исключения для совместимости с Java, но также мощные функциональные инструменты для элегантной обработки ошибок.

Выбирайте свой стиль. Главное — не забывайте ловить ошибки. Или хотя бы красиво падать.

---

### Полные данные JSON

<details>
<summary>Показать JSON данные</summary>

```json
{
  "name" : "text",
  "text" : "<h1 style=\"text-align:center;\">Как программы научились красиво падать</h1>\n\n<p>1960-е годы. Программист вводит команду деления на ноль, и... компьютер просто зависает. Навсегда. Приходится идти к системному администратору (который выглядит страшнее, чем любая ошибка) и просить перезагрузить машину. В те времена ошибки обрабатывались примерно так: программа возвращала специальный код (обычно -1 или 0), и вы должны были после каждой операции проверять, не случилось ли чего. Код превращался в бесконечную пирамиду проверок:</p>\n\n<pre><code class=\"language-scala\">val result1 = readFile()\nif (result1 != -1) {\n  val result2 = parseData(result1)\n  if (result2 != -1) {\n    val result3 = saveToDatabase(result2)\n    if (result3 != -1) {\n      // Наконец-то реальная работа!\n    }\n  }\n}\n</code></pre>\n\n<p>Программисты чувствовали себя не инженерами, а параноиками, проверяющими каждый шаг.</p>\n\n<h2 style=\"text-align:center;\">Появление исключений (Exception)</h2>\n\n<p>В 1960-х в языке Lisp появилась первая идея \"нелокального выхода\" — способность выпрыгнуть из глубоко вложенного кода прямо наверх. Но настоящую революцию совершили разработчики языка PL/I в IBM. Они придумали концепцию \"условий\" (conditions) — предков современных исключений.</p>\n\n<p>Идея была гениально проста: если что-то пошло не так, не возвращай код ошибки — <em>выбрось</em> её, как горячую картошку! Пусть кто-то другой ловит. В 1970-х годах CLU от Барбары Лисков формализовал эту концепцию, а в 1980-х C++ с его <code>try-catch</code> сделал исключения мейнстримом.</p>\n\n<p>Программисты вздохнули с облегчением. Теперь код стал выглядеть так:</p>\n\n<pre><code class=\"language-scala\">try {\n  val data = readFile()\n  val parsed = parseData(data)\n  saveToDatabase(parsed)\n  // Просто пишем логику!\n} catch {\n  case e: IOException =&gt; println(\"Проблемы с файлом\")\n  case e: SQLException =&gt; println(\"База данных бунтует\")\n}\n</code></pre>\n\n<h2 style=\"text-align:center;\">Что такое исключение простыми словами</h2>\n\n<p>Представьте: вы готовите борщ по рецепту. Дошли до пункта \"добавить свеклу\", открыли холодильник — а свеклы нет! Обычный рецепт (обычная программа) в этот момент просто зависнет: \"Шаг 5: добавить свеклу... добавить свеклу... добавить свеклу...\"</p>\n\n<p><strong>Исключение</strong> (Exception) — это способ сказать: \"Стоп! Что-то пошло не так. Я не могу продолжать по плану\". Вместо зависания программа \"выбрасывает\" сигнал тревоги и ищет, кто готов с этим разобраться.</p>\n\n<pre><code class=\"language-scala\">// Программа идёт по плану\nprintln(\"Начинаем готовить\")\nprintln(\"Режем картошку\")\n// БАХ! Свеклы нет — выбрасываем исключение\nthrow new Exception(\"Свеклы нет в холодильнике!\")\nprintln(\"Это никогда не выполнится\")\n</code></pre>\n\n<h2 style=\"text-align:center;\">Анатомия try-catch: три кита обработки ошибок</h2>\n\n<p>Конструкция <code>try-catch</code> состоит из трёх частей, как светофор: <strong>try</strong> (попробуй), <strong>catch</strong> (поймай), <strong>finally</strong> (в любом случае).</p>\n\n<h3>1. Try — \"попробуй это\"</h3>\n\n<p>Блок <code>try</code> — это защищённая зона. Вы говорите программе: \"Попробуй выполнить этот код, но будь готов, что может пойти не так\".</p>\n\n<pre><code class=\"language-scala\">try {\n  val result = 10 / 0  // Опасная операция\n  println(result)\n}\n</code></pre>\n\n<p>Программа честно пытается разделить 10 на 0, понимает, что это невозможно, и <strong>выбрасывает</strong> исключение <code>ArithmeticException</code>. Это значение специального типа <code>ArithmeticException.</code></p>\n\n<h3>2. Catch — \"если что-то сломалось\"</h3>\n\n<p>Блок <code>catch</code> — это сеть безопасности. Здесь вы ловите исключения и решаете, что с ними делать.</p>\n\n<pre><code class=\"language-scala\">try {\n  val result = 10 / 0\n} catch {\n  case e: ArithmeticException =&gt; \n    println(\"Эй, на ноль делить нельзя!\")\n  case e: Exception =&gt; \n    println(\"Что-то другое сломалось\")\n}\n</code></pre>\n\n<p><strong>Pattern matching</strong> в Scala позволяет ловить разные типы исключений, как разные виды рыбы разными сетями.</p>\n\n<h3>3. Finally — \"в любом случае сделай это\"</h3>\n\n<p>Блок <code>finally</code> выполняется <strong>всегда</strong>: удалось выполнить код или нет, было исключение или не было.</p>\n\n<pre><code class=\"language-scala\">var file: FileReader = null\ntry {\n  file = new FileReader(\"data.txt\")\n  // читаем файл\n} catch {\n  case e: IOException =&gt; println(\"Файл не найден\")\n} finally {\n  if (file != null) file.close()  // Закроем файл в любом случае\n  println(\"Уборка завершена\")\n}\n</code></pre>\n\n<p><code>Finally</code> — это ваш помощник для уборки: закрыть файлы, освободить ресурсы, выключить свет.</p>\n\n<h2 style=\"text-align:center;\">Как это работает внутри: путешествие исключения</h2>\n\n<p>Когда выбрасывается исключение, происходит магия:</p>\n\n<ol>\n\t<li><strong>Выброс</strong>: Программа создаёт значение исключения (<code>типа ArithmeticException</code>, <code>IOException</code>, etc.) и выбрасывает его командой <strong><code>throw</code></strong></li>\n\t<li><strong>Разматывание стека</strong> (stack unwinding): Программа начинает \"всплывать\" назад по вызовам функций, как дайвер к поверхности</li>\n\t<li><strong>Поиск обработчика</strong>: На каждом уровне она проверяет: \"Есть тут <code>catch</code>?\"</li>\n\t<li><strong>Обработка</strong>: Первый подходящий <code>catch</code> ловит исключение</li>\n\t<li><strong>Продолжение</strong>: После <code>catch</code> (и <code>finally</code>) программа продолжает работу</li>\n</ol>\n\n<pre><code class=\"language-scala\">def level3(): Int = {\n  10 / 0  // Исключение выбрасывается здесь\n}\n\ndef level2(): Int = {\n  level3()  // Пролетает мимо\n}\n\ndef level1(): Unit = {\n  try {\n    level2()  // И мимо\n  } catch {\n    case e: ArithmeticException =&gt; \n      println(\"Поймал на верхнем уровне!\")  // Ловится здесь!\n  }\n}\n</code></pre>\n\n<h2 style=\"text-align:center;\">Типы исключений: иерархия катастроф</h2>\n\n<p>В Scala (как и в Java) исключения образуют семейное дерево:</p>\n\n<pre><code>Throwable (прадедушка всех ошибок)\n├── Error (серьёзные проблемы, обычно не ловим)\n│   └── OutOfMemoryError\n└── Exception (обычные ошибки, ловим эти)\n    ├── RuntimeException (непроверяемые)\n    │   ├── ArithmeticException\n    │   ├── NullPointerException\n    │   └── IndexOutOfBoundsException\n    └── IOException (проверяемые в Java)\n</code></pre>\n\n<p><strong>RuntimeException</strong> — самые частые гости: деление на ноль, обращение к <code>null</code>, выход за границы массива.</p>\n\n<h2 style=\"text-align:center;\">Практические примеры</h2>\n\n<h3>Пример 1: Безопасное преобразование строки в число</h3>\n\n<pre><code class=\"language-scala\">def safeParseInt(str: String): Option[Int] = {\n  try {\n    Some(str.toInt)\n  } catch {\n    case e: NumberFormatException =&gt; None\n  }\n}\n\nsafeParseInt(\"123\")   // Some(123)\nsafeParseInt(\"abc\")   // None — не паникуем, просто возвращаем None\n</code></pre>\n\n<h3>Пример 2: Работа с файлами</h3>\n\n<pre><code class=\"language-scala\">import scala.io.Source\n\ndef readFirstLine(filename: String): String = {\n  var source: Source = null\n  try {\n    source = Source.fromFile(filename)\n    source.getLines().next()\n  } catch {\n    case e: FileNotFoundException =&gt; \"Файл не найден\"\n    case e: IOException =&gt; \"Ошибка чтения\"\n  } finally {\n    if (source != null) source.close()\n  }\n}\n</code></pre>\n\n<h3>Пример 3: Множественная обработка</h3>\n\n<pre><code class=\"language-scala\">def processData(input: String): Unit = {\n  try {\n    val number = input.toInt\n    val result = 100 / number\n    println(s\"Результат: $result\")\n  } catch {\n    case e: NumberFormatException =&gt; \n      println(\"Это не число!\")\n    case e: ArithmeticException =&gt; \n      println(\"На ноль делить нельзя!\")\n    case e: Exception =&gt; \n      println(s\"Неожиданная ошибка: ${e.getMessage}\")\n  }\n}\n</code></pre>\n\n<h2 style=\"text-align:center;\">Важные правила</h2>\n\n<p><strong>1. Ловите конкретные исключения первыми</strong></p>\n\n<pre><code class=\"language-scala\">try {\n  // код\n} catch {\n  case e: FileNotFoundException =&gt; // Сначала специфичное\n  case e: IOException =&gt;           // Потом общее\n  case e: Exception =&gt;             // Самое общее в конце\n}\n</code></pre>\n\n<p><strong>2. Не глушите исключения</strong></p>\n\n<pre><code class=\"language-scala\">// ПЛОХО\ntry {\n  dangerousOperation()\n} catch {\n  case e: Exception =&gt; // молча проглотили ошибку\n}\n\n// ХОРОШО\ntry {\n  dangerousOperation()\n} catch {\n  case e: Exception =&gt; \n    logger.error(\"Ошибка в операции\", e)\n    throw e  // или обработайте осмысленно\n}\n</code></pre>\n\n<p><strong>3. Finally для критичной очистки</strong></p>\n\n<pre><code class=\"language-scala\">val lock = new ReentrantLock()\nlock.lock()\ntry {\n  // критичная секция\n} finally {\n  lock.unlock()  // Освободим блокировку в любом случае\n}\n</code></pre>\n\n<h2 style=\"text-align:center;\">Java и проверяемые исключения: хорошая идея?</h2>\n\n<p>В 1990-х Java решила быть умнее всех и изобрела <em>проверяемые исключения</em> (checked exceptions). Идея: компилятор заставит вас обработать все возможные ошибки. Звучит здорово!</p>\n\n<pre><code class=\"language-java\">public void readFile() throws IOException {\n  // компилятор не даст забыть об IOException\n}\n</code></pre>\n\n<p>Но программисты быстро поняли: это превратилось в кошмар. Каждый метод обрастал <code>throws</code> как ёлка игрушками. Люди начали писать <code>catch (Exception e) {}</code> — ловить всё и игнорировать. Хуже первоначальной проблемы!</p>\n\n<h2 style=\"text-align:center;\"> Scala входит в игру</h2>\n\n<p>Когда Мартин Одерски создавал Scala в начале 2000-х, он посмотрел на Java и сказал: \"Ребята, давайте без фанатизма\". Scala оставила исключения, но сделала их все <em>непроверяемыми</em>. Свобода!</p>\n\n<p>Но Scala предложила кое-что интереснее: функциональный подход к ошибкам через <code>Try</code>, <code>Either</code> и <code>Option</code>:</p>\n\n<pre><code class=\"language-scala\">def divide(a: Int, b: Int): Try[Int] = Try(a / b)\n\ndivide(10, 0) match {\n  case Success(result) =&gt; println(s\"Результат: $result\")\n  case Failure(exception) =&gt; println(\"Делить на ноль нельзя, математика не любит\")\n}\n</code></pre>\n\n<p>Ошибка стала не исключением, а <em>значением</em>. Вы можете передавать её, трансформировать, комбинировать. Это философия: ошибки — это нормально, они часть жизни.</p>\n\n<p>Современные языки вроде Rust вообще отказались от исключений в пользу типа <code>Result</code>. Go использует явное возвращение ошибок (привет из 1960-х, но без пирамид проверок). Scala балансирует между мирами: у вас есть исключения для совместимости с Java, но также мощные функциональные инструменты для элегантной обработки ошибок.</p>\n\n<p>Выбирайте свой стиль. Главное — не забывайте ловить ошибки. Или хотя бы красиво падать.</p>",
  "video" : null,
  "options" : {
    
  },
  "subtitle_files" : [
  ],
  "is_deprecated" : false
}
```

</details>
