{
  "step_id" : 7959688,
  "lesson_id" : 1911144,
  "position" : 3,
  "type" : "unknown",
  "block" : {
    "name" : "text",
    "text" : "<h1 style=\"text-align:center;\">Алгебра типов</h1>\n\n<p>Алгебра типов — это формальная математическая система, устанавливающая соответствие между типами данных и алгебраическими структурами. Типы рассматриваются как множества значений, а операции над типами соответствуют теоретико-множественным и алгебраическим операциям. Это позволяет применять математический аппарат для анализа, композиции и верификации типов в программировании.</p>\n\n<h2 style=\"text-align:center;\">Теоретические основы</h2>\n\n<h3 style=\"text-align:center;\">Математическая нотация</h3>\n\n<table>\n\t<thead>\n\t\t<tr>\n\t\t\t<th>Обозначение</th>\n\t\t\t<th>Значение</th>\n\t\t</tr>\n\t</thead>\n\t<tbody>\n\t\t<tr>\n\t\t\t<td><strong>A × B</strong></td>\n\t\t\t<td>Декартово произведение типов (Product type)</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td><strong>A + B</strong></td>\n\t\t\t<td>Дизъюнктное объединение типов (Sum type)</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td><strong>A ^ B</strong></td>\n\t\t\t<td>\"Экспоненциальный тип\"</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td><strong>A → B</strong></td>\n\t\t\t<td>Функциональный тип</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td><strong>A ∩ B</strong></td>\n\t\t\t<td>Пересечение типов (Intersection type)</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td><strong>A ∪ B</strong></td>\n\t\t\t<td>Объединение типов (Union type)</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td><strong>T ^ n</strong></td>\n\t\t\t<td>Гомогенное произведение типа T n раз</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td><strong>⊤</strong></td>\n\t\t\t<td>Top type (Any)</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td><strong>⊥</strong></td>\n\t\t\t<td>Bottom type (Nothing)</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td><strong>1</strong></td>\n\t\t\t<td>Unit type</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td><strong>0</strong></td>\n\t\t\t<td>Empty type (Nothing)</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td><strong>∞</strong></td>\n\t\t\t<td>Бесконечность</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td><strong>A ≅ B</strong></td>\n\t\t\t<td>Изоморфность типов</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td><strong>T, A, B</strong></td>\n\t\t\t<td>Перечень неких типов данных</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td><strong>|T|</strong></td>\n\t\t\t<td>Кардинальность типа T (количество возможных значений)</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td><strong>|A × B|</strong></td>\n\t\t\t<td>Кардинальность типа-произведения (число значений этого типа)</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td><strong>|A| × |B|</strong></td>\n\t\t\t<td>Произведение кардинальностей (обычное умножение чисел)</td>\n\t\t</tr>\n\t</tbody>\n</table>\n\n<h3 style=\"text-align:center;\"><strong>Типы как множества</strong></h3>\n\n<p>Каждый тип T представляет множество всех возможных значений этого типа. Например, тип <code>Boolean</code> представляет множество {true, false}.</p>\n\n<h3 style=\"text-align:center;\"><strong>Кардинальность типа</strong></h3>\n\n<p>Кардинальность (мощность) типа |T| — это количество различных значений, которые может принимать тип T. Кардинальность определяет \"размер\" типа и используется для вычисления кардинальности составных типов.</p>\n\n<h3 style=\"text-align:center;\"><strong>Изоморфизм типов</strong></h3>\n\n<p>Два типа изоморфны (A ≅ B), если их можно преобразовывать друг в друга без потери информации. Это означает, что они по сути одинаковые, просто записаны по-разному. Изоморфные типы имеют одинаковую кардинальность и взаимозаменяемы с точки зрения информационной ёмкости.</p>\n\n<h2 style=\"text-align:center;\">Атомарные типы алгебры</h2>\n\n<ol>\n\t<li><strong>Тип Any</strong> (<em>top type</em>) — верхушка типов\n\n\t<ul>\n\t\t<li>Обозначение: <code>∞, ⊤</code></li>\n\t\t<li>Кардинальность: |Any| = ∞</li>\n\t\t<li>Нейтральный элемент для пересечения: A ∩ Any ≅ A</li>\n\t\t<li>Поглощающий элемент для объединения: A ∪ Any ≅ Any</li>\n\t</ul>\n\t</li>\n\t<li><strong>Тип Nothing</strong> (<em>bottom type</em>) — конец типов\n\t<ul>\n\t\t<li>Обозначение: <code>0, ⊥</code></li>\n\t\t<li>Кардинальность: |Nothing| = 0</li>\n\t\t<li>Нейтральный элемент для суммы: A + Nothing ≅ A</li>\n\t\t<li>Нейтральный элемент для объединения: A | Nothing ≅ A</li>\n\t\t<li>Поглощающий элемент для произведения: A × Nothing ≅ Nothing</li>\n\t\t<li>Поглощающий элемент для пересечения: A ∩ Nothing ≅ Nothing</li>\n\t</ul>\n\t</li>\n\t<li><strong>Тип Unit</strong> — единичный тип\n\t<ul>\n\t\t<li>Обозначение: <code>1</code></li>\n\t\t<li>Значение:<code> ()</code></li>\n\t\t<li>Кардинальность: |Unit| = 1</li>\n\t\t<li>Нейтральный элемент для произведения: A × Unit ≅ A</li>\n\t</ul>\n\t</li>\n\t<li><strong>Тип Null</strong> — тип пустого значения (рудимент в алгебре типов)\n\t<ul>\n\t\t<li>Значение : <code>null</code></li>\n\t\t<li>Кардинальность: |Null| = 1</li>\n\t\t<li>Нейтральный элемент для произведения: A × Null ≅ A</li>\n\t\t<li>Изоморфен: <code>Null ≅ Unit</code></li>\n\t</ul>\n\t</li>\n</ol>\n\n<h2 style=\"text-align:center;\">Составные типы алгебры</h2>\n\n<p>Типы, операции над которыми соответствуют алгебраическим операциям.</p>\n\n<ol>\n\t<li><strong>Типы-произведения </strong>(<em>Product types, <code>A × B</code></em>) — типы, содержащие значения обоих типов одновременно, логическое \"И\"\n\n\t<ul>\n\t\t<li>Scala синтаксис: <strong><code>(A, B)</code></strong></li>\n\t\t<li>Кардинальность: <strong><code>|A × B| = |A| × |B|</code></strong></li>\n\t\t<li>Коммутативность:<strong><code> A × B ≅ B × A</code></strong></li>\n\t\t<li>Ассоциативность: <strong><code>(A × B) × C ≅ A × (B × C)</code></strong></li>\n\t\t<li>Нейтральный элемент: <strong><code>A × Unit ≅ A</code></strong></li>\n\t\t<li>Поглощающий элемент:<strong><code> A × Nothing ≅ Nothing</code></strong></li>\n\t\t<li>Представители:  <strong><code>case class, Tuple</code></strong></li>\n\t</ul>\n\t</li>\n\t<li><strong>Типы-гомогенные произведения</strong> (<em>Homogeneous Products, <code>T ^ n</code></em>) -- тип, содержащий значения одного типа несколько раз\n\t<ul>\n\t\t<li>Scala синтаксис: <strong><code>(T,  T,  T)</code></strong></li>\n\t\t<li>Кардинальность: <strong><code>|T ^ n| = |T| × |T| × ... × |T| = |T| ^ n</code></strong></li>\n\t\t<li>Для Array[T] с n элементами:<code><strong> |Array[T]| = |T|^n</strong></code></li>\n\t\t<li>Для String длины n: <strong><code>|String_n| = |Char|^n</code></strong></li>\n\t\t<li>Представители: <strong><code>Array, String</code></strong></li>\n\t</ul>\n\t</li>\n\t<li><strong>Суммарные типы</strong> (<em>Sum types, <code>A + B</code></em>) — типы, содержащие значения одного из типов, логическое \"ИЛИ\"\n\t<ul>\n\t\t<li>Scala cинтаксис : <strong><code>enum,</code>sealed trait</strong></li>\n\t\t<li>Кардинальность: <strong><code>|A + B| = |A| + |B|</code></strong></li>\n\t\t<li>Коммутативность: <strong><code>A + B ≅ B + A</code></strong></li>\n\t\t<li>Ассоциативность: <strong><code>(A + B) + C ≅ A + (B + C)</code></strong></li>\n\t\t<li>Нейтральный элемент: <strong><code>A + Nothing ≅ A</code></strong></li>\n\t\t<li>Дистрибутивность: <strong><code>A × (B + C) ≅ (A × B) + (A × C)</code></strong></li>\n\t\t<li>Представители: <strong><code>enum,</code>sealed trait</strong></li>\n\t</ul>\n\t</li>\n\t<li><strong>Экспоненциальные типы</strong> (<em>Exponential types, <code>A ^ B, A → B</code></em>) — типы отображения/преобразования из A в B\n\t<ul>\n\t\t<li>Scala cинтаксис : <strong><code>A =&gt; B</code></strong></li>\n\t\t<li>Кардинальность: <strong><code>|A → B| = |B| ^ |A|</code></strong></li>\n\t\t<li>Каррирование: <strong><code>(A × B) → C ≅ A → (B → C)</code></strong></li>\n\t\t<li>Экспонента произведения: <strong><code>A → (B × C) ≅ (A → B) × (A → C)</code></strong></li>\n\t\t<li>Экспонента суммы:<code> <strong>(A + B) → C ≅ (A → C) × (B → C)</strong></code></li>\n\t\t<li>Степень суммы: <strong><code>A → (B + C) ≠ (A → B) + (A → C)</code></strong> (в общем случае)</li>\n\t\t<li>Представители: <strong>Функции</strong></li>\n\t</ul>\n\t</li>\n\t<li><strong>Типы-пересечения</strong> (<em>Intersection types, <code>A ∩ B</code></em>) — тип, удовлетворяющий требованиям типов A и B \n\t<ul>\n\t\t<li>Scala cинтаксис : <strong><code>A &amp; B</code></strong></li>\n\t\t<li>Кардинальность: <strong><code>|A ∩ B| ≤ min(|A|, |B|)</code></strong></li>\n\t\t<li>Коммутативность: <strong><code>A &amp; B ≅ B &amp; A</code></strong></li>\n\t\t<li>Ассоциативность: <strong><code>(A &amp; B) &amp; C ≅ A &amp; (B &amp; C)</code></strong></li>\n\t\t<li>Идемпотентность: <strong><code>A &amp; A ≅ A</code></strong></li>\n\t\t<li>Нейтральный элемент:<code> <strong>A &amp; Any ≅ A</strong></code></li>\n\t\t<li>Поглощающий элемент: <strong><code>A &amp; Nothing ≅ Nothing</code></strong></li>\n\t\t<li>Представители: <strong><code>&amp;</code></strong></li>\n\t</ul>\n\t</li>\n\t<li><strong>Объединение типов</strong> (<em>Union types, <code>A ∪ B</code></em>) — тип, принимающий значения любого из типов\n\t<ul>\n\t\t<li>Scala cинтаксис : <strong><code>A | B</code></strong></li>\n\t\t<li>Кардинальность: <strong><code>|A ∪ B| ≤ |A| + |B|</code></strong></li>\n\t\t<li>Ассоциативность: <strong><code>(A ∪ B) ∪ C ≅ A ∪ (B ∪ C)</code></strong></li>\n\t\t<li>Идемпотентность:<code> <strong>A ∪ A ≅ A</strong></code></li>\n\t\t<li>Нейтральный элемент: <strong><code>A ∪ Nothing ≅ A</code></strong></li>\n\t\t<li>Поглощающий элемент: <strong><code>A ∪ Any ≅ Any</code></strong></li>\n\t\t<li>Представители: <strong><code>|</code></strong>\n\t\t<ul>\n\t\t</ul>\n\t\t</li>\n\t</ul>\n\t</li>\n</ol>\n\n<h2 style=\"text-align:center;\">Композиция составных типов</h2>\n\n<p>Ключевая идея алгебры типов — типы можно композировать для получения более сложных типов.</p>\n\n<h3>Принципы композиции:</h3>\n\n<ol>\n\t<li><strong>Замкнутость</strong>: Композиция типов создаёт новые корректные типы</li>\n\t<li><strong>Алгебраические законы сохраняются</strong>: Дистрибутивность, ассоциативность работают на всех уровнях</li>\n\t<li><strong>Модульность</strong>: Сложные типы можно разбить на простые компоненты</li>\n\t<li><strong>Рекурсия</strong>: Типы могут ссылаться на себя</li>\n\t<li><strong>Кардинальность композиции</strong>: |Composite| вычисляется через |Components|</li>\n</ol>\n\n<p><strong>Тип ADT </strong>— это результат композиции произведений и сумм.</p>\n\n<h2 style=\"text-align:center;\">Изоморфизм Карри-Ховарда</h2>\n\n<p>Изоморфизм Карри-Ховарда устанавливает соответствие между:</p>\n\n<ul>\n\t<li>Логическими утверждениями и типами</li>\n\t<li>Доказательствами и программами</li>\n\t<li>Упрощением доказательств и вычислением программ</li>\n</ul>\n\n<table>\n\t<thead>\n\t\t<tr>\n\t\t\t<th>Логика</th>\n\t\t\t<th>Типы</th>\n\t\t\t<th>Кардинальность</th>\n\t\t\t<th>Scala 3</th>\n\t\t</tr>\n\t</thead>\n\t<tbody>\n\t\t<tr>\n\t\t\t<td>⊤ (истина)</td>\n\t\t\t<td>Unit</td>\n\t\t\t<td>1</td>\n\t\t\t<td><code>()</code></td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>⊥ (ложь)</td>\n\t\t\t<td>Nothing</td>\n\t\t\t<td>0</td>\n\t\t\t<td>необитаем</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>A ∧ B (конъюнкция)</td>\n\t\t\t<td>A × B</td>\n\t\t\t<td>|A| × |B|</td>\n\t\t\t<td><code>(A, B)</code></td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>A ∨ B (дизъюнкция)</td>\n\t\t\t<td>A + B</td>\n\t\t\t<td>|A| + |B|</td>\n\t\t\t<td><code>enum</code></td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>A → B (импликация)</td>\n\t\t\t<td>A =&gt; B</td>\n\t\t\t<td>|B| ^ |A|</td>\n\t\t\t<td><code>A =&gt; B</code></td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>¬A (отрицание)</td>\n\t\t\t<td>A =&gt; Nothing</td>\n\t\t\t<td>0 ^ |A|</td>\n\t\t\t<td><code>A =&gt; Nothing</code></td>\n\t\t</tr>\n\t</tbody>\n</table>",
    "video" : null,
    "options" : {
      
    },
    "subtitle_files" : [
    ],
    "is_deprecated" : false
  },
  "name" : "text",
  "course_id" : 269026,
  "course_name" : " Система типов Scala 3",
  "exported_at" : "2026-01-10T10:36:15.6301301"
}