# Материал (Шаг 2)

## Информация о шаге

- **ID шага**: 8998625
- **Позиция**: 2
- **Тип**: text
- **Курс**:  Система типов Scala 3
- **Экспортирован**: 2026-01-10T10:36:16.6998235

## Содержание

# Базовые операции Case Class

Конструкция уже имеет в своем составе необходимые **базовые **операции типа (создание, декомпозиция, трансформация, сравнение). Обычно их достаточно для полноценной работы с такими типами данных.

case class Point(x: Double, y: Double) // Определение

val p1 = Point(3.0, 4.0) // Создание
val Point(x, y) = p1 // Деструктуризация
val p2 = p1.copy(x = 5.0) // Трансформация
val equal = p1 == Point(3.0, 4.0) // Сравнение по значению

### 1. Создание значения типа

case class User(id: Long, name: String)

val user = User(1, "Alice") // Вызов конструктора типа с аргументами для создания значения

**Философия операции:** "создание значения" = "вызов конструктора типа". Похоже на вызов специальной функции. И да такая функция имеется, называется apply. Но она скрыта, для красоты.

`val user = User.apply(1, "Alice") // apply - функция-конструктор значения типа.`

### 2. Операция `copy` — неизменяемые трансформации

case class Person(name: String, age: Int, city: String)

val alice = Person("Alice", 30, "New York")

// Создаем измененную копию
val older: Person = alice.copy(age = 31)
val moved: Person = alice.copy(city = "Boston")
val renamed: Person = alice.copy(name = "Alicia", age = 31)

// Оригинал не изменился
println(alice) // Person(Alice,30,New York)
println(older) // Person(Alice,31,New York)

**Философия операции:** Данные неизменяемы. Чтобы "изменить" значение, мы создаем новое значение с измененными полями.

### 3. Структурное равенство 

**Структурное равенство** — это сравнение объектов по их содержимому (значениям полей), а не по ссылке в памяти. 

case class Point(x: Int, y: Int)

val p1 = Point(10, 20)
val p2 = Point(10, 20)
val p3 = Point(10, 30)

println(p1 == p2) // true - одинаковые значения
println(p1 == p3) // false - разные значения
println(p1 eq p2) // false - разные объекты в памяти

**Философия операции:** Равенство определяется значением полей, а не местом в памяти. Два case class с одинаковыми полями — это **одно и то же значение**, как числа: `5 == 5`.

### 4. Операция `toString`  —  полное человекочитаемое представление значения

case class User(id: Long, name: String, email: String)

val user = User(1, "Alice", "alice@example.com")

println(user.toString) // User(1,Alice,alice@example.com)
println(user) // в данном случае можно явно не указывать toString

**Философия операции:** Представить значение в читаемом виде для отладки, логирования, вывод в REPL. 

### 5. Декомпозиция значения

case class Person(name: String, age: Int)

val person = Person("Alice", 30) // Создание значения из элемантов

val Person(n, a) = person // Декомпозиция значения на элементы
println(s"Name: $n, Age: $a")

**Философия:** Case class — это контейнер данных, который можно собирать и разбирать. Композиция и декомпозиция значения симметричны. За операцию декомпозиции отвечает операция` unapply`, которая вызываться неявно.

---

### Полные данные JSON

<details>
<summary>Показать JSON данные</summary>

```json
{
  "name" : "text",
  "text" : "<h1 style=\"text-align:center;\">Базовые операции Case Class</h1>\n\n<p>Конструкция уже имеет в своем составе необходимые <strong>базовые </strong>операции типа (создание, декомпозиция, трансформация, сравнение). Обычно их достаточно для полноценной работы с такими типами данных.</p>\n\n<pre><code class=\"language-scala\">case class Point(x: Double, y: Double) // Определение\n\nval p1 = Point(3.0, 4.0)               // Создание\nval Point(x, y) = p1                   // Деструктуризация\nval p2 = p1.copy(x = 5.0)              // Трансформация\nval equal = p1 == Point(3.0, 4.0)      // Сравнение по значению\n</code></pre>\n\n<h3>1. Создание значения типа</h3>\n\n<pre><code class=\"language-scala\">case class User(id: Long, name: String)\n\nval user = User(1, \"Alice\")  // Вызов конструктора типа с аргументами для создания значения\n</code></pre>\n\n<p><strong>Философия операции:</strong> \"создание значения\" = \"вызов конструктора типа\". Похоже на вызов специальной функции. И да такая функция имеется, называется apply. Но она скрыта, для красоты.</p>\n\n<pre><code class=\"language-scala\">val user = User.apply(1, \"Alice\") // apply - функция-конструктор значения типа.</code></pre>\n\n<h3>2. Операция <code>copy</code> — неизменяемые трансформации</h3>\n\n<pre><code class=\"language-scala\">case class Person(name: String, age: Int, city: String)\n\nval alice = Person(\"Alice\", 30, \"New York\")\n\n// Создаем измененную копию\nval older: Person = alice.copy(age = 31)\nval moved: Person = alice.copy(city = \"Boston\")\nval renamed: Person = alice.copy(name = \"Alicia\", age = 31)\n\n// Оригинал не изменился\nprintln(alice)  // Person(Alice,30,New York)\nprintln(older)  // Person(Alice,31,New York)\n</code></pre>\n\n<p><strong>Философия операции:</strong> Данные неизменяемы. Чтобы \"изменить\" значение, мы создаем новое значение с измененными полями.</p>\n\n<h3>3. Структурное равенство </h3>\n\n<p><strong>Структурное равенство</strong> — это сравнение объектов по их содержимому (значениям полей), а не по ссылке в памяти. </p>\n\n<pre><code class=\"language-scala\">case class Point(x: Int, y: Int)\n\nval p1 = Point(10, 20)\nval p2 = Point(10, 20)\nval p3 = Point(10, 30)\n\nprintln(p1 == p2)  // true  - одинаковые значения\nprintln(p1 == p3)  // false - разные значения\nprintln(p1 eq p2)  // false - разные объекты в памяти\n</code></pre>\n\n<p><strong>Философия операции:</strong> Равенство определяется значением полей, а не местом в памяти. Два case class с одинаковыми полями — это <strong>одно и то же значение</strong>, как числа: <code>5 == 5</code>.</p>\n\n<h3>4. Операция <code>toString</code>  —  полное человекочитаемое представление значения</h3>\n\n<pre><code class=\"language-scala\">case class User(id: Long, name: String, email: String)\n\nval user = User(1, \"Alice\", \"alice@example.com\")\n\nprintln(user.toString) // User(1,Alice,alice@example.com)\nprintln(user) // в данном случае можно явно не указывать toString</code></pre>\n\n<p><strong>Философия операции:</strong> Представить значение в читаемом виде для отладки, логирования, вывод в REPL. </p>\n\n<h3>5. Декомпозиция значения</h3>\n\n<pre><code class=\"language-scala\">case class Person(name: String, age: Int)\n\nval person = Person(\"Alice\", 30) // Создание значения из элемантов\n\nval Person(n, a) = person        // Декомпозиция значения на элементы\nprintln(s\"Name: $n, Age: $a\")\n\n</code></pre>\n\n<p><strong>Философия:</strong> Case class — это контейнер данных, который можно собирать и разбирать. Композиция и декомпозиция значения симметричны. За операцию декомпозиции отвечает операция<code> unapply</code>, которая вызываться неявно.</p>",
  "video" : null,
  "options" : {
    
  },
  "subtitle_files" : [
  ],
  "is_deprecated" : false
}
```

</details>
