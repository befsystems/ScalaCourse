{
  "step_id" : 9172212,
  "lesson_id" : 2140960,
  "position" : 3,
  "type" : "unknown",
  "block" : {
    "name" : "text",
    "text" : "<h1 style=\"text-align:center;\">Непрозрачные типы</h1>\n\n<p><strong>Непрозрачные типы</strong> (opaque types) позволяет создавать типобезопасные абстракции без накладных расходов на производительность.</p>\n\n<h2 style=\"text-align:center;\">Проблема, которую решают непрозрачные типы</h2>\n\n<h3>Проблема примитивной одержимости</h3>\n\n<p>Представьте, что вы разрабатываете систему для работы с пользователями:</p>\n\n<pre><code class=\"language-scala\">def sendEmail(userId: Int, email: String): Unit = {\n  // отправка email\n}\n\n// Легко перепутать порядок аргументов:\nsendEmail(\"user@example.com\", 42) // компилятор не заметит ошибку!\n</code></pre>\n\n<p>Проблема в том, что <code>Int</code> и <code>String</code> — слишком общие типы. Мы хотим различать <code>UserId</code> и обычный <code>Int</code>, а также <code>Email</code> и обычный <code>String</code>.</p>\n\n<h3>Традиционные решения и их недостатки</h3>\n\n<p><strong>Решение 1: Value Classes (Scala 2)</strong></p>\n\n<pre><code class=\"language-scala\">case class UserId(value: Int) extends AnyVal\ncase class Email(value: String) extends AnyVal\n\ndef sendEmail(userId: UserId, email: Email): Unit = {\n  // теперь типобезопасно!\n}\n</code></pre>\n\n<p>Недостатки:</p>\n\n<ul>\n\t<li>Не всегда гарантируется отсутствие boxing</li>\n\t<li>Ограничения на наследование и вложенность</li>\n\t<li>Всё ещё имеет runtime overhead в некоторых случаях</li>\n</ul>\n\n<p><strong>Решение 2: Обычные case классы</strong></p>\n\n<pre><code class=\"language-scala\">case class UserId(value: Int)\ncase class Email(value: String)\n</code></pre>\n\n<p>Недостатки:</p>\n\n<ul>\n\t<li>Гарантированный runtime overhead</li>\n\t<li>Каждое значение требует аллокации объекта</li>\n\t<li>Снижение производительности</li>\n</ul>\n\n<h2>Непрозрачные типы: Элегантное решение</h2>\n\n<h3>Базовый синтаксис</h3>\n\n<pre><code class=\"language-scala\">object UserDomain:\n  opaque type UserId = Int\n  opaque type Email = String\n  \n  object UserId:\n    def apply(value: Int): UserId = value\n    \n  object Email:\n    def apply(value: String): Email = value\n</code></pre>\n\n<h3>Ключевые свойства</h3>\n\n<p><strong>1. Абстракция снаружи</strong></p>\n\n<p>Вне области определения (scope) непрозрачный тип — это отдельный тип:</p>\n\n<pre><code class=\"language-scala\">import UserDomain.*\n\nval userId: UserId = UserId(42)\nval number: Int = 100\n\n// Ошибка компиляции:\n// val test: UserId = 100  // не скомпилируется!\n</code></pre>\n\n<p><strong>2. Прозрачность внутри</strong></p>\n\n<p>Внутри области определения непрозрачный тип эквивалентен базовому типу:</p>\n\n<pre><code class=\"language-scala\">object UserDomain:\n  opaque type UserId = Int\n  \n  object UserId:\n    def apply(value: Int): UserId = value\n    \n  extension (id: UserId)\n    def toInt: Int = id  // внутри scope UserId = Int\n    def increment: UserId = id + 1  // можем использовать как Int\n</code></pre>\n\n<p><strong>3. Нулевой runtime overhead</strong></p>\n\n<p>После компиляции непрозрачные типы полностью стираются — остаётся только базовый тип.</p>\n\n<h2>Практические примеры</h2>\n\n<h3>Пример 1: Система измерений</h3>\n\n<pre><code class=\"language-scala\">object Measurements:\n  opaque type Meters = Double\n  opaque type Seconds = Double\n  opaque type MetersPerSecond = Double\n  \n  object Meters:\n    def apply(value: Double): Meters = value\n    \n  object Seconds:\n    def apply(value: Double): Seconds = value\n    \n  object MetersPerSecond:\n    def apply(value: Double): MetersPerSecond = value\n  \n  extension (m: Meters)\n    def value: Double = m\n    def +(other: Meters): Meters = m + other\n    def /(s: Seconds): MetersPerSecond = m / s\n    \n  extension (s: Seconds)\n    def value: Double = s\n    \n  extension (mps: MetersPerSecond)\n    def value: Double = mps\n\n// Использование:\nimport Measurements.*\n\nval distance = Meters(100.0)\nval time = Seconds(10.0)\nval speed = distance / time  // type: MetersPerSecond\n\n// Ошибка компиляции - нельзя смешивать разные единицы:\n// val wrong = distance + time  // не скомпилируется!\n</code></pre>\n\n<h3>Пример 2: Валидация данных</h3>\n\n<pre><code class=\"language-scala\">object Validation:\n  opaque type PositiveInt = Int\n  \n  object PositiveInt:\n    def apply(value: Int): Option[PositiveInt] =\n      if value &gt; 0 then Some(value) else None\n      \n    def unsafe(value: Int): PositiveInt = value\n  \n  extension (p: PositiveInt)\n    def value: Int = p\n    def increment: PositiveInt = p + 1\n\n// Использование:\nimport Validation.*\n\nval maybeAge = PositiveInt(25)  // Some(25)\nval invalid = PositiveInt(-5)    // None\n\nmaybeAge match\n  case Some(age) =&gt;\n    println(age.value)  // 25\n    println(age.increment.value)  // 26\n  case None =&gt;\n    println(\"Invalid age\")\n</code></pre>\n\n<h3>Пример 3: Идентификаторы в разных контекстах</h3>\n\n<pre><code class=\"language-scala\">object Database:\n  opaque type OrderId = Long\n  opaque type CustomerId = Long\n  opaque type ProductId = Long\n  \n  object OrderId:\n    def apply(value: Long): OrderId = value\n    \n  object CustomerId:\n    def apply(value: Long): CustomerId = value\n    \n  object ProductId:\n    def apply(value: Long): ProductId = value\n  \n  extension (id: OrderId)\n    def value: Long = id\n    \n  extension (id: CustomerId)\n    def value: Long = id\n    \n  extension (id: ProductId)\n    def value: Long = id\n  \n  def getOrder(orderId: OrderId): String = \n    s\"Order #${orderId.value}\"\n    \n  def getCustomer(customerId: CustomerId): String =\n    s\"Customer #${customerId.value}\"\n\n// Использование:\nimport Database.*\n\nval order = OrderId(123L)\nval customer = CustomerId(456L)\n\nprintln(getOrder(order))      // OK\n// println(getOrder(customer)) // Ошибка компиляции!\n</code></pre>\n\n<h2>Расширенные возможности</h2>\n\n<h3>Extension методы</h3>\n\n<p>Extension методы позволяют добавлять функциональность к непрозрачным типам:</p>\n\n<pre><code class=\"language-scala\">object Temperature:\n  opaque type Celsius = Double\n  opaque type Fahrenheit = Double\n  \n  object Celsius:\n    def apply(value: Double): Celsius = value\n    \n  object Fahrenheit:\n    def apply(value: Double): Fahrenheit = value\n  \n  extension (c: Celsius)\n    def value: Double = c\n    def toFahrenheit: Fahrenheit = (c * 9.0 / 5.0) + 32.0\n    \n  extension (f: Fahrenheit)\n    def value: Double = f\n    def toCelsius: Celsius = (f - 32.0) * 5.0 / 9.0\n\n// Использование:\nimport Temperature.*\n\nval freezing = Celsius(0.0)\nval boiling = Celsius(100.0)\n\nprintln(freezing.toFahrenheit.value)  // 32.0\nprintln(boiling.toFahrenheit.value)   // 212.0\n</code></pre>\n\n<h3>Границы типов (Type Bounds)</h3>\n\n<p>Непрозрачные типы можно ограничивать:</p>\n\n<pre><code class=\"language-scala\">object Bounded:\n  opaque type Natural = Int\n  opaque type Percentage &lt;: Double = Double  // верхняя граница\n  \n  object Natural:\n    def apply(value: Int): Option[Natural] =\n      if value &gt;= 0 then Some(value) else None\n  \n  object Percentage:\n    def apply(value: Double): Option[Percentage] =\n      if value &gt;= 0.0 &amp;&amp; value &lt;= 100.0 then Some(value) else None\n  \n  extension (n: Natural)\n    def value: Int = n\n    \n  extension (p: Percentage)\n    def value: Double = p\n    \n  // Благодаря &lt;: Double можем использовать Percentage как Double\n  // в некоторых контекстах\n</code></pre>\n\n<h2>Сравнение подходов</h2>\n\n<table>\n\t<thead>\n\t\t<tr>\n\t\t\t<th>Характеристика</th>\n\t\t\t<th>Opaque Types</th>\n\t\t\t<th>Value Classes</th>\n\t\t\t<th>Case Classes</th>\n\t\t</tr>\n\t</thead>\n\t<tbody>\n\t\t<tr>\n\t\t\t<td>Runtime overhead</td>\n\t\t\t<td>Нет</td>\n\t\t\t<td>Минимальный*</td>\n\t\t\t<td>Есть</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>Типобезопасность</td>\n\t\t\t<td>Да</td>\n\t\t\t<td>Да</td>\n\t\t\t<td>Да</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>Ограничения</td>\n\t\t\t<td>Минимальные</td>\n\t\t\t<td>Есть</td>\n\t\t\t<td>Нет</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>Производительность</td>\n\t\t\t<td>Максимальная</td>\n\t\t\t<td>Высокая</td>\n\t\t\t<td>Средняя</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>Синтаксис</td>\n\t\t\t<td>Scala 3</td>\n\t\t\t<td>Scala 2/3</td>\n\t\t\t<td>Scala 2/3</td>\n\t\t</tr>\n\t</tbody>\n</table>\n\n<p>*Value classes могут иметь boxing в некоторых случаях</p>\n\n<h2>Лучшие практики</h2>\n\n<h3>1. Используйте объекты-компаньоны для конструкторов</h3>\n\n<pre><code class=\"language-scala\">object Domain:\n  opaque type Age = Int\n  \n  object Age:\n    def apply(value: Int): Option[Age] =\n      if value &gt;= 0 &amp;&amp; value &lt;= 150 then Some(value) else None\n</code></pre>\n\n<h3>2. Предоставляйте методы доступа через extension</h3>\n\n<pre><code class=\"language-scala\">object Domain:\n  opaque type UserId = Long\n  \n  extension (id: UserId)\n    def value: Long = id\n    def asString: String = s\"user_$id\"\n</code></pre>\n\n<h3>3. Группируйте связанные типы</h3>\n\n<pre><code class=\"language-scala\">object MoneyDomain:\n  opaque type Dollars = BigDecimal\n  opaque type Euros = BigDecimal\n  opaque type ExchangeRate = BigDecimal\n  \n  // конструкторы и extension методы\n</code></pre>\n\n<h3>4. Используйте валидацию при создании</h3>\n\n<pre><code class=\"language-scala\">object Email:\n  opaque type Email = String\n  \n  object Email:\n    def apply(value: String): Option[Email] =\n      if value.contains(\"@\") then Some(value) else None\n</code></pre>",
    "video" : null,
    "options" : {
      
    },
    "subtitle_files" : [
    ],
    "is_deprecated" : false
  },
  "name" : "text",
  "course_id" : 269026,
  "course_name" : " Система типов Scala 3",
  "exported_at" : "2026-01-10T10:36:23.0236463"
}