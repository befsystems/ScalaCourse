# Материал (Шаг 3)

## Информация о шаге

- **ID шага**: 9172212
- **Позиция**: 3
- **Тип**: text
- **Курс**:  Система типов Scala 3
- **Экспортирован**: 2026-01-10T10:36:23.0251347

## Содержание

# Непрозрачные типы

**Непрозрачные типы** (opaque types) позволяет создавать типобезопасные абстракции без накладных расходов на производительность.

## Проблема, которую решают непрозрачные типы

### Проблема примитивной одержимости

Представьте, что вы разрабатываете систему для работы с пользователями:

def sendEmail(userId: Int, email: String): Unit = {
// отправка email
}

// Легко перепутать порядок аргументов:
sendEmail("user@example.com", 42) // компилятор не заметит ошибку!

Проблема в том, что `Int` и `String` — слишком общие типы. Мы хотим различать `UserId` и обычный `Int`, а также `Email` и обычный `String`.

### Традиционные решения и их недостатки

**Решение 1: Value Classes (Scala 2)**

case class UserId(value: Int) extends AnyVal
case class Email(value: String) extends AnyVal

def sendEmail(userId: UserId, email: Email): Unit = {
// теперь типобезопасно!
}

Недостатки:

- Не всегда гарантируется отсутствие boxing

- Ограничения на наследование и вложенность

- Всё ещё имеет runtime overhead в некоторых случаях

**Решение 2: Обычные case классы**

case class UserId(value: Int)
case class Email(value: String)

Недостатки:

- Гарантированный runtime overhead

- Каждое значение требует аллокации объекта

- Снижение производительности

## Непрозрачные типы: Элегантное решение

### Базовый синтаксис

object UserDomain:
opaque type UserId = Int
opaque type Email = String

object UserId:
def apply(value: Int): UserId = value

object Email:
def apply(value: String): Email = value

### Ключевые свойства

**1. Абстракция снаружи**

Вне области определения (scope) непрозрачный тип — это отдельный тип:

import UserDomain.*

val userId: UserId = UserId(42)
val number: Int = 100

// Ошибка компиляции:
// val test: UserId = 100 // не скомпилируется!

**2. Прозрачность внутри**

Внутри области определения непрозрачный тип эквивалентен базовому типу:

object UserDomain:
opaque type UserId = Int

object UserId:
def apply(value: Int): UserId = value

extension (id: UserId)
def toInt: Int = id // внутри scope UserId = Int
def increment: UserId = id + 1 // можем использовать как Int

**3. Нулевой runtime overhead**

После компиляции непрозрачные типы полностью стираются — остаётся только базовый тип.

## Практические примеры

### Пример 1: Система измерений

object Measurements:
opaque type Meters = Double
opaque type Seconds = Double
opaque type MetersPerSecond = Double

object Meters:
def apply(value: Double): Meters = value

object Seconds:
def apply(value: Double): Seconds = value

object MetersPerSecond:
def apply(value: Double): MetersPerSecond = value

extension (m: Meters)
def value: Double = m
def +(other: Meters): Meters = m + other
def /(s: Seconds): MetersPerSecond = m / s

extension (s: Seconds)
def value: Double = s

extension (mps: MetersPerSecond)
def value: Double = mps

// Использование:
import Measurements.*

val distance = Meters(100.0)
val time = Seconds(10.0)
val speed = distance / time // type: MetersPerSecond

// Ошибка компиляции - нельзя смешивать разные единицы:
// val wrong = distance + time // не скомпилируется!

### Пример 2: Валидация данных

object Validation:
opaque type PositiveInt = Int

object PositiveInt:
def apply(value: Int): Option[PositiveInt] =
if value > 0 then Some(value) else None

def unsafe(value: Int): PositiveInt = value

extension (p: PositiveInt)
def value: Int = p
def increment: PositiveInt = p + 1

// Использование:
import Validation.*

val maybeAge = PositiveInt(25) // Some(25)
val invalid = PositiveInt(-5) // None

maybeAge match
case Some(age) =>
println(age.value) // 25
println(age.increment.value) // 26
case None =>
println("Invalid age")

### Пример 3: Идентификаторы в разных контекстах

object Database:
opaque type OrderId = Long
opaque type CustomerId = Long
opaque type ProductId = Long

object OrderId:
def apply(value: Long): OrderId = value

object CustomerId:
def apply(value: Long): CustomerId = value

object ProductId:
def apply(value: Long): ProductId = value

extension (id: OrderId)
def value: Long = id

extension (id: CustomerId)
def value: Long = id

extension (id: ProductId)
def value: Long = id

def getOrder(orderId: OrderId): String =
s"Order #${orderId.value}"

def getCustomer(customerId: CustomerId): String =
s"Customer #${customerId.value}"

// Использование:
import Database.*

val order = OrderId(123L)
val customer = CustomerId(456L)

println(getOrder(order)) // OK
// println(getOrder(customer)) // Ошибка компиляции!

## Расширенные возможности

### Extension методы

Extension методы позволяют добавлять функциональность к непрозрачным типам:

object Temperature:
opaque type Celsius = Double
opaque type Fahrenheit = Double

object Celsius:
def apply(value: Double): Celsius = value

object Fahrenheit:
def apply(value: Double): Fahrenheit = value

extension (c: Celsius)
def value: Double = c
def toFahrenheit: Fahrenheit = (c * 9.0 / 5.0) + 32.0

extension (f: Fahrenheit)
def value: Double = f
def toCelsius: Celsius = (f - 32.0) * 5.0 / 9.0

// Использование:
import Temperature.*

val freezing = Celsius(0.0)
val boiling = Celsius(100.0)

println(freezing.toFahrenheit.value) // 32.0
println(boiling.toFahrenheit.value) // 212.0

### Границы типов (Type Bounds)

Непрозрачные типы можно ограничивать:

object Bounded:
opaque type Natural = Int
opaque type Percentage <: Double = Double // верхняя граница

object Natural:
def apply(value: Int): Option[Natural] =
if value >= 0 then Some(value) else None

object Percentage:
def apply(value: Double): Option[Percentage] =
if value >= 0.0 && value <= 100.0 then Some(value) else None

extension (n: Natural)
def value: Int = n

extension (p: Percentage)
def value: Double = p

// Благодаря <: Double можем использовать Percentage как Double
// в некоторых контекстах

## Сравнение подходов

| Характеристика | Opaque Types | Value Classes | Case Classes |
| --- | --- | --- | --- |
| Runtime overhead | Нет | Минимальный* | Есть |
| Типобезопасность | Да | Да | Да |
| Ограничения | Минимальные | Есть | Нет |
| Производительность | Максимальная | Высокая | Средняя |
| Синтаксис | Scala 3 | Scala 2/3 | Scala 2/3 |

*Value classes могут иметь boxing в некоторых случаях

## Лучшие практики

### 1. Используйте объекты-компаньоны для конструкторов

object Domain:
opaque type Age = Int

object Age:
def apply(value: Int): Option[Age] =
if value >= 0 && value <= 150 then Some(value) else None

### 2. Предоставляйте методы доступа через extension

object Domain:
opaque type UserId = Long

extension (id: UserId)
def value: Long = id
def asString: String = s"user_$id"

### 3. Группируйте связанные типы

object MoneyDomain:
opaque type Dollars = BigDecimal
opaque type Euros = BigDecimal
opaque type ExchangeRate = BigDecimal

// конструкторы и extension методы

### 4. Используйте валидацию при создании

object Email:
opaque type Email = String

object Email:
def apply(value: String): Option[Email] =
if value.contains("@") then Some(value) else None

---

### Полные данные JSON

<details>
<summary>Показать JSON данные</summary>

```json
{
  "name" : "text",
  "text" : "<h1 style=\"text-align:center;\">Непрозрачные типы</h1>\n\n<p><strong>Непрозрачные типы</strong> (opaque types) позволяет создавать типобезопасные абстракции без накладных расходов на производительность.</p>\n\n<h2 style=\"text-align:center;\">Проблема, которую решают непрозрачные типы</h2>\n\n<h3>Проблема примитивной одержимости</h3>\n\n<p>Представьте, что вы разрабатываете систему для работы с пользователями:</p>\n\n<pre><code class=\"language-scala\">def sendEmail(userId: Int, email: String): Unit = {\n  // отправка email\n}\n\n// Легко перепутать порядок аргументов:\nsendEmail(\"user@example.com\", 42) // компилятор не заметит ошибку!\n</code></pre>\n\n<p>Проблема в том, что <code>Int</code> и <code>String</code> — слишком общие типы. Мы хотим различать <code>UserId</code> и обычный <code>Int</code>, а также <code>Email</code> и обычный <code>String</code>.</p>\n\n<h3>Традиционные решения и их недостатки</h3>\n\n<p><strong>Решение 1: Value Classes (Scala 2)</strong></p>\n\n<pre><code class=\"language-scala\">case class UserId(value: Int) extends AnyVal\ncase class Email(value: String) extends AnyVal\n\ndef sendEmail(userId: UserId, email: Email): Unit = {\n  // теперь типобезопасно!\n}\n</code></pre>\n\n<p>Недостатки:</p>\n\n<ul>\n\t<li>Не всегда гарантируется отсутствие boxing</li>\n\t<li>Ограничения на наследование и вложенность</li>\n\t<li>Всё ещё имеет runtime overhead в некоторых случаях</li>\n</ul>\n\n<p><strong>Решение 2: Обычные case классы</strong></p>\n\n<pre><code class=\"language-scala\">case class UserId(value: Int)\ncase class Email(value: String)\n</code></pre>\n\n<p>Недостатки:</p>\n\n<ul>\n\t<li>Гарантированный runtime overhead</li>\n\t<li>Каждое значение требует аллокации объекта</li>\n\t<li>Снижение производительности</li>\n</ul>\n\n<h2>Непрозрачные типы: Элегантное решение</h2>\n\n<h3>Базовый синтаксис</h3>\n\n<pre><code class=\"language-scala\">object UserDomain:\n  opaque type UserId = Int\n  opaque type Email = String\n  \n  object UserId:\n    def apply(value: Int): UserId = value\n    \n  object Email:\n    def apply(value: String): Email = value\n</code></pre>\n\n<h3>Ключевые свойства</h3>\n\n<p><strong>1. Абстракция снаружи</strong></p>\n\n<p>Вне области определения (scope) непрозрачный тип — это отдельный тип:</p>\n\n<pre><code class=\"language-scala\">import UserDomain.*\n\nval userId: UserId = UserId(42)\nval number: Int = 100\n\n// Ошибка компиляции:\n// val test: UserId = 100  // не скомпилируется!\n</code></pre>\n\n<p><strong>2. Прозрачность внутри</strong></p>\n\n<p>Внутри области определения непрозрачный тип эквивалентен базовому типу:</p>\n\n<pre><code class=\"language-scala\">object UserDomain:\n  opaque type UserId = Int\n  \n  object UserId:\n    def apply(value: Int): UserId = value\n    \n  extension (id: UserId)\n    def toInt: Int = id  // внутри scope UserId = Int\n    def increment: UserId = id + 1  // можем использовать как Int\n</code></pre>\n\n<p><strong>3. Нулевой runtime overhead</strong></p>\n\n<p>После компиляции непрозрачные типы полностью стираются — остаётся только базовый тип.</p>\n\n<h2>Практические примеры</h2>\n\n<h3>Пример 1: Система измерений</h3>\n\n<pre><code class=\"language-scala\">object Measurements:\n  opaque type Meters = Double\n  opaque type Seconds = Double\n  opaque type MetersPerSecond = Double\n  \n  object Meters:\n    def apply(value: Double): Meters = value\n    \n  object Seconds:\n    def apply(value: Double): Seconds = value\n    \n  object MetersPerSecond:\n    def apply(value: Double): MetersPerSecond = value\n  \n  extension (m: Meters)\n    def value: Double = m\n    def +(other: Meters): Meters = m + other\n    def /(s: Seconds): MetersPerSecond = m / s\n    \n  extension (s: Seconds)\n    def value: Double = s\n    \n  extension (mps: MetersPerSecond)\n    def value: Double = mps\n\n// Использование:\nimport Measurements.*\n\nval distance = Meters(100.0)\nval time = Seconds(10.0)\nval speed = distance / time  // type: MetersPerSecond\n\n// Ошибка компиляции - нельзя смешивать разные единицы:\n// val wrong = distance + time  // не скомпилируется!\n</code></pre>\n\n<h3>Пример 2: Валидация данных</h3>\n\n<pre><code class=\"language-scala\">object Validation:\n  opaque type PositiveInt = Int\n  \n  object PositiveInt:\n    def apply(value: Int): Option[PositiveInt] =\n      if value &gt; 0 then Some(value) else None\n      \n    def unsafe(value: Int): PositiveInt = value\n  \n  extension (p: PositiveInt)\n    def value: Int = p\n    def increment: PositiveInt = p + 1\n\n// Использование:\nimport Validation.*\n\nval maybeAge = PositiveInt(25)  // Some(25)\nval invalid = PositiveInt(-5)    // None\n\nmaybeAge match\n  case Some(age) =&gt;\n    println(age.value)  // 25\n    println(age.increment.value)  // 26\n  case None =&gt;\n    println(\"Invalid age\")\n</code></pre>\n\n<h3>Пример 3: Идентификаторы в разных контекстах</h3>\n\n<pre><code class=\"language-scala\">object Database:\n  opaque type OrderId = Long\n  opaque type CustomerId = Long\n  opaque type ProductId = Long\n  \n  object OrderId:\n    def apply(value: Long): OrderId = value\n    \n  object CustomerId:\n    def apply(value: Long): CustomerId = value\n    \n  object ProductId:\n    def apply(value: Long): ProductId = value\n  \n  extension (id: OrderId)\n    def value: Long = id\n    \n  extension (id: CustomerId)\n    def value: Long = id\n    \n  extension (id: ProductId)\n    def value: Long = id\n  \n  def getOrder(orderId: OrderId): String = \n    s\"Order #${orderId.value}\"\n    \n  def getCustomer(customerId: CustomerId): String =\n    s\"Customer #${customerId.value}\"\n\n// Использование:\nimport Database.*\n\nval order = OrderId(123L)\nval customer = CustomerId(456L)\n\nprintln(getOrder(order))      // OK\n// println(getOrder(customer)) // Ошибка компиляции!\n</code></pre>\n\n<h2>Расширенные возможности</h2>\n\n<h3>Extension методы</h3>\n\n<p>Extension методы позволяют добавлять функциональность к непрозрачным типам:</p>\n\n<pre><code class=\"language-scala\">object Temperature:\n  opaque type Celsius = Double\n  opaque type Fahrenheit = Double\n  \n  object Celsius:\n    def apply(value: Double): Celsius = value\n    \n  object Fahrenheit:\n    def apply(value: Double): Fahrenheit = value\n  \n  extension (c: Celsius)\n    def value: Double = c\n    def toFahrenheit: Fahrenheit = (c * 9.0 / 5.0) + 32.0\n    \n  extension (f: Fahrenheit)\n    def value: Double = f\n    def toCelsius: Celsius = (f - 32.0) * 5.0 / 9.0\n\n// Использование:\nimport Temperature.*\n\nval freezing = Celsius(0.0)\nval boiling = Celsius(100.0)\n\nprintln(freezing.toFahrenheit.value)  // 32.0\nprintln(boiling.toFahrenheit.value)   // 212.0\n</code></pre>\n\n<h3>Границы типов (Type Bounds)</h3>\n\n<p>Непрозрачные типы можно ограничивать:</p>\n\n<pre><code class=\"language-scala\">object Bounded:\n  opaque type Natural = Int\n  opaque type Percentage &lt;: Double = Double  // верхняя граница\n  \n  object Natural:\n    def apply(value: Int): Option[Natural] =\n      if value &gt;= 0 then Some(value) else None\n  \n  object Percentage:\n    def apply(value: Double): Option[Percentage] =\n      if value &gt;= 0.0 &amp;&amp; value &lt;= 100.0 then Some(value) else None\n  \n  extension (n: Natural)\n    def value: Int = n\n    \n  extension (p: Percentage)\n    def value: Double = p\n    \n  // Благодаря &lt;: Double можем использовать Percentage как Double\n  // в некоторых контекстах\n</code></pre>\n\n<h2>Сравнение подходов</h2>\n\n<table>\n\t<thead>\n\t\t<tr>\n\t\t\t<th>Характеристика</th>\n\t\t\t<th>Opaque Types</th>\n\t\t\t<th>Value Classes</th>\n\t\t\t<th>Case Classes</th>\n\t\t</tr>\n\t</thead>\n\t<tbody>\n\t\t<tr>\n\t\t\t<td>Runtime overhead</td>\n\t\t\t<td>Нет</td>\n\t\t\t<td>Минимальный*</td>\n\t\t\t<td>Есть</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>Типобезопасность</td>\n\t\t\t<td>Да</td>\n\t\t\t<td>Да</td>\n\t\t\t<td>Да</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>Ограничения</td>\n\t\t\t<td>Минимальные</td>\n\t\t\t<td>Есть</td>\n\t\t\t<td>Нет</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>Производительность</td>\n\t\t\t<td>Максимальная</td>\n\t\t\t<td>Высокая</td>\n\t\t\t<td>Средняя</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>Синтаксис</td>\n\t\t\t<td>Scala 3</td>\n\t\t\t<td>Scala 2/3</td>\n\t\t\t<td>Scala 2/3</td>\n\t\t</tr>\n\t</tbody>\n</table>\n\n<p>*Value classes могут иметь boxing в некоторых случаях</p>\n\n<h2>Лучшие практики</h2>\n\n<h3>1. Используйте объекты-компаньоны для конструкторов</h3>\n\n<pre><code class=\"language-scala\">object Domain:\n  opaque type Age = Int\n  \n  object Age:\n    def apply(value: Int): Option[Age] =\n      if value &gt;= 0 &amp;&amp; value &lt;= 150 then Some(value) else None\n</code></pre>\n\n<h3>2. Предоставляйте методы доступа через extension</h3>\n\n<pre><code class=\"language-scala\">object Domain:\n  opaque type UserId = Long\n  \n  extension (id: UserId)\n    def value: Long = id\n    def asString: String = s\"user_$id\"\n</code></pre>\n\n<h3>3. Группируйте связанные типы</h3>\n\n<pre><code class=\"language-scala\">object MoneyDomain:\n  opaque type Dollars = BigDecimal\n  opaque type Euros = BigDecimal\n  opaque type ExchangeRate = BigDecimal\n  \n  // конструкторы и extension методы\n</code></pre>\n\n<h3>4. Используйте валидацию при создании</h3>\n\n<pre><code class=\"language-scala\">object Email:\n  opaque type Email = String\n  \n  object Email:\n    def apply(value: String): Option[Email] =\n      if value.contains(\"@\") then Some(value) else None\n</code></pre>",
  "video" : null,
  "options" : {
    
  },
  "subtitle_files" : [
  ],
  "is_deprecated" : false
}
```

</details>
