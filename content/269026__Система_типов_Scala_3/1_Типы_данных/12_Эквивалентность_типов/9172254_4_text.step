{
  "step_id" : 9172254,
  "lesson_id" : 2140960,
  "position" : 4,
  "type" : "unknown",
  "block" : {
    "name" : "text",
    "text" : "<h1 style=\"text-align:center;\">Конструкции Type Aliases</h1>\n\n<h3>1. Простые Type Aliases (Simple Type Aliases)</h3>\n\n<p>Базовая форма — прозрачный синоним типа:</p>\n\n<pre><code class=\"language-scala\">// Простейшая форма\ntype UserId = Int\ntype UserName = String\n\n// Синоним сложного типа\ntype StringMap = Map[String, String]\ntype ErrorOr[T] = Either[String, T]\ntype Callback = () =&gt; Unit\n</code></pre>\n\n<h3>2. Параметризованные Type Aliases (Parameterized Type Aliases)</h3>\n\n<p>Type aliases с параметрами типа:</p>\n\n<pre><code class=\"language-scala\">// Один параметр\ntype Optional[T] = Option[T]\ntype Result[T] = Either[String, T]\n\n// Несколько параметров\ntype Pair[A, B] = (A, B)\ntype StringKeyMap[V] = Map[String, V]\n\n// С ковариантностью/контравариантностью\ntype Producer[+T] = () =&gt; T\ntype Consumer[-T] = T =&gt; Unit\n\n// Частичное применение типов\ntype IntMap[V] = Map[Int, V]\ntype StringToInt = Map[String, Int]\n</code></pre>\n\n<h3>3. Type Aliases с границами (Bounded Type Aliases)</h3>\n\n<p>Type aliases с ограничениями на параметры типа:</p>\n\n<pre><code class=\"language-scala\">// Верхняя граница (upper bound)\ntype NumericType[T &lt;: Number] = T\ntype ComparableList[T &lt;: Comparable[T]] = List[T]\n\n// Нижняя граница (lower bound)\ntype SuperString[T &gt;: String] = T\n\n// Контекстные границы (context bounds)\ntype Ordered[T: Ordering] = List[T]\ntype Showable[T: Show] = T\n\n// Множественные границы\ntype Serializable[T &lt;: java.io.Serializable with Cloneable] = T\n</code></pre>\n\n<h3>4. Opaque Type Aliases (Scala 3)</h3>\n\n<p>Непрозрачные синонимы с контролируемой видимостью:</p>\n\n<pre><code class=\"language-scala\">object Domain:\n  // Простой opaque type\n  opaque type UserId = Long\n  \n  // Opaque type с верхней границей\n  opaque type PositiveInt &lt;: Int = Int\n  \n  // Параметризованный opaque type\n  opaque type Wrapper[T] = T\n  \n  // Opaque type с валидацией\n  opaque type Email = String\n  \n  object Email:\n    def apply(s: String): Option[Email] =\n      if s.contains(\"@\") then Some(s) else None\n</code></pre>\n\n<h3>5. Abstract Type Members (Абстрактные члены типов)</h3>\n\n<p>Type aliases без определения (в traits/классах):</p>\n\n<pre><code class=\"language-scala\">// Абстрактный тип без определения\ntrait Container:\n  type Element  // абстрактный тип\n  def get: Element\n  def put(e: Element): Unit\n\n// Реализация\nclass IntContainer extends Container:\n  type Element = Int  // конкретизация\n  private var value: Int = 0\n  def get: Int = value\n  def put(e: Int): Unit = value = e\n\n// С границами\ntrait BoundedContainer:\n  type Element &lt;: Serializable\n  def get: Element\n\n// Семейство типов (type families)\ntrait Graph:\n  type Node\n  type Edge\n  def nodes: List[Node]\n  def edges: List[Edge]\n</code></pre>\n\n<h3>6. Path-Dependent Types (Зависимые от пути типы)</h3>\n\n<p>Type aliases, зависящие от экземпляра объекта:</p>\n\n<pre><code class=\"language-scala\">class Outer:\n  class Inner\n  type MyInner = Inner\n\nval outer1 = new Outer\nval outer2 = new Outer\n\n// Типы зависят от экземпляра\nval inner1: outer1.Inner = new outer1.Inner\nval inner2: outer2.Inner = new outer2.Inner\n\n// inner1 и inner2 имеют РАЗНЫЕ типы!\n// val x: outer1.Inner = inner2  // ОШИБКА!\n\n// Type alias тоже path-dependent\ntype Inner1 = outer1.MyInner\ntype Inner2 = outer2.MyInner\n// Inner1 ≠ Inner2\n</code></pre>\n\n<h3>7. Type Lambdas (Scala 3)</h3>\n\n<p>Lambda-выражения на уровне типов:</p>\n\n<pre><code class=\"language-scala\">// Старый синтаксис (Scala 2) - kind projector\ntype EitherString[A] = Either[String, A]\n\n// Новый синтаксис (Scala 3) - type lambda\ntype EitherString = [A] =&gt;&gt; Either[String, A]\n\n// Более сложные примеры\ntype Tuple2First = [A, B] =&gt;&gt; (A, B) match\n  case (a, _) =&gt; a\n\n// Частичное применение\ntype MapWithStringKey = [V] =&gt;&gt; Map[String, V]\n\n// Композиция типов\ntype Nested = [F[_], G[_], A] =&gt;&gt; F[G[A]]\n</code></pre>\n\n<h3>8. Match Types (Scala 3)</h3>\n\n<p>Type aliases с сопоставлением с образцом:</p>\n\n<pre><code class=\"language-scala\">// Базовый match type\ntype ElementType[T] = T match\n  case List[t] =&gt; t\n  case Array[t] =&gt; t\n  case Option[t] =&gt; t\n  case t =&gt; t\n\n// Примеры использования\ntype E1 = ElementType[List[Int]]     // Int\ntype E2 = ElementType[Array[String]] // String\ntype E3 = ElementType[Option[Double]]// Double\ntype E4 = ElementType[Boolean]       // Boolean\n\n// Рекурсивный match type\ntype Concat[A &lt;: Tuple, B &lt;: Tuple] = A match\n  case EmptyTuple =&gt; B\n  case h *: t =&gt; h *: Concat[t, B]\n\n// Head и Tail для tuple\ntype Head[T &lt;: Tuple] = T match\n  case h *: _ =&gt; h\n\ntype Tail[T &lt;: Tuple] = T match\n  case _ *: t =&gt; t\n\n// Применение\ntype T1 = Concat[(1, 2), (3, 4)]  // (1, 2, 3, 4)\ntype H = Head[(Int, String, Boolean)]  // Int\ntype T = Tail[(Int, String, Boolean)]  // (String, Boolean)\n</code></pre>\n\n<h3>9. Intersection и Union Types (Scala 3)</h3>\n\n<p>Type aliases для пересечений и объединений:</p>\n\n<pre><code class=\"language-scala\">// Intersection type (&amp;)\ntrait Readable:\n  def read(): String\n\ntrait Writable:\n  def write(s: String): Unit\n\ntype ReadWrite = Readable &amp; Writable\n\n// Union type (|)\ntype IntOrString = Int | String\ntype Nullable[T] = T | Null\n\n// Комбинации\ntype NumberLike = Int | Long | Double | Float\ntype JsonValue = String | Int | Boolean | Null | JsonObject | JsonArray\n\n// С параметрами\ntype Either3[A, B, C] = A | B | C\n</code></pre>\n\n<h3>10. Refined Types (Уточнённые типы)</h3>\n\n<p>Type aliases с уточнениями структуры:</p>\n\n<pre><code class=\"language-scala\">// Structural refinement\ntype PersonLike = {\n  def name: String\n  def age: Int\n}\n\n// С дополнительными методами\ntype Closeable = {\n  def close(): Unit\n}\n\ntype Resource = {\n  def open(): Unit\n  def close(): Unit\n  def isOpen: Boolean\n}\n\n// Использование\ndef closeResource(r: Closeable): Unit = r.close()\n\n// Может работать с любым объектом, у которого есть метод close()\n</code></pre>\n\n<h3>11. Higher-Kinded Types (Типы высших порядков)</h3>\n\n<p>Type aliases для type constructors:</p>\n\n<pre><code class=\"language-scala\">// Простой higher-kinded type\ntype Container[F[_]] = F[Int]\n\n// Примеры\ntype ListOfInt = Container[List]      // List[Int]\ntype OptionOfInt = Container[Option]  // Option[Int]\n\n// Более сложные\ntype Functor[F[_]] = [A, B] =&gt; (A =&gt; B) =&gt; F[A] =&gt; F[B]\n\n// Monad-подобные\ntype FlatMap[F[_]] = [A, B] =&gt; F[A] =&gt; (A =&gt; F[B]) =&gt; F[B]\n\n// Bi-functor\ntype Bifunctor[F[_, _]] = [A, B, C, D] =&gt; \n  (A =&gt; C) =&gt; (B =&gt; D) =&gt; F[A, B] =&gt; F[C, D]\n</code></pre>\n\n<h3>12. Existential Types (через Wildcards)</h3>\n\n<p>Type aliases с экзистенциальными типами:</p>\n\n<pre><code class=\"language-scala\">// Scala 3 использует wildcards вместо forSome\ntype AnyList = List[?]  // List любого типа\n\n// С границами\ntype ListOfComparable = List[? &lt;: Comparable[?]]\n\n// В параметрах\ntype GenericPair[T] = (T, ?)  // пара где второй элемент любого типа\n\n// Java interop\ntype JavaList = java.util.List[?]\n</code></pre>\n\n<h3>13. Type Aliases в Pattern Types (Scala 3)</h3>\n\n<p>Type aliases для паттернов:</p>\n\n<pre><code class=\"language-scala\">// Extractors как типы\ntype ExtractInt = { def unapply(x: Any): Option[Int] }\n\n// Singleton types\ntype Singleton42 = 42\ntype SingletonTrue = true\ntype SingletonHello = \"hello\"\n\n// Literal types\ntype Port = 80 | 443 | 8080\ntype Direction = \"north\" | \"south\" | \"east\" | \"west\"\n</code></pre>\n\n<h3>14. Infix Type Aliases (Scala 3)</h3>\n\n<p>Type aliases с инфиксной нотацией:</p>\n\n<pre><code class=\"language-scala\">// Определение инфиксного типа\ninfix type or[A, B] = A | B\ninfix type and[A, B] = A &amp; B\n\n// Использование\ntype IntOrString = Int or String\ntype ReadableAndWritable = Readable and Writable\n\n// Ассоциативность\ntype Complex = Int or String or Boolean\n// эквивалентно: Int | String | Boolean\n</code></pre>\n\n<h3>15. Context Function Types (Scala 3)</h3>\n\n<p>Type aliases для контекстных функций:</p>\n\n<pre><code class=\"language-scala\">// Контекстная функция\ntype Executable[T] = ExecutionContext ?=&gt; T\n\n// Множественные контексты\ntype Transactional[T] = (Database, Transaction) ?=&gt; T\n\n// С параметрами\ntype Reader[R, A] = R ?=&gt; A\n\n// Использование\ndef compute: Executable[Int] = summon[ExecutionContext].execute(42)\n</code></pre>\n\n<h2>Сравнительная таблица всех конструкций</h2>\n\n<table>\n\t<thead>\n\t\t<tr>\n\t\t\t<th>Конструкция</th>\n\t\t\t<th>Синтаксис</th>\n\t\t\t<th>Scala версия</th>\n\t\t\t<th>Прозрачность</th>\n\t\t\t<th>Use Case</th>\n\t\t</tr>\n\t</thead>\n\t<tbody>\n\t\t<tr>\n\t\t\t<td>Simple Alias</td>\n\t\t\t<td><code>type T = U</code></td>\n\t\t\t<td>2, 3</td>\n\t\t\t<td>Полная</td>\n\t\t\t<td>Упрощение сигнатур</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>Parameterized</td>\n\t\t\t<td><code>type F[T] = List[T]</code></td>\n\t\t\t<td>2, 3</td>\n\t\t\t<td>Полная</td>\n\t\t\t<td>Generic типы</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>Bounded</td>\n\t\t\t<td><code>type T[A &lt;: B] = ...</code></td>\n\t\t\t<td>2, 3</td>\n\t\t\t<td>Полная</td>\n\t\t\t<td>Ограничения</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>Opaque</td>\n\t\t\t<td><code>opaque type T = U</code></td>\n\t\t\t<td>3</td>\n\t\t\t<td>В scope</td>\n\t\t\t<td>Типобезопасность</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>Abstract</td>\n\t\t\t<td><code>type T</code></td>\n\t\t\t<td>2, 3</td>\n\t\t\t<td>N/A</td>\n\t\t\t<td>Абстракция</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>Path-dependent</td>\n\t\t\t<td><code>obj.Type</code></td>\n\t\t\t<td>2, 3</td>\n\t\t\t<td>Зависит</td>\n\t\t\t<td>Модульность</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>Type Lambda</td>\n\t\t\t<td><code>[A] =&gt;&gt; F[A]</code></td>\n\t\t\t<td>3</td>\n\t\t\t<td>Полная</td>\n\t\t\t<td>Higher-kinded</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>Match Type</td>\n\t\t\t<td><code>T match case ...</code></td>\n\t\t\t<td>3</td>\n\t\t\t<td>Полная</td>\n\t\t\t<td>Type-level logic</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>Intersection</td>\n\t\t\t<td><code>A &amp; B</code></td>\n\t\t\t<td>3</td>\n\t\t\t<td>Полная</td>\n\t\t\t<td>Множественные trait</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>Union</td>\n\t\t\t<td>`A</td>\n\t\t\t<td>B`</td>\n\t\t\t<td>3</td>\n\t\t\t<td>Полная</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>Refined</td>\n\t\t\t<td><code>{ def m: T }</code></td>\n\t\t\t<td>2, 3</td>\n\t\t\t<td>Полная</td>\n\t\t\t<td>Структурные типы</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>Infix</td>\n\t\t\t<td><code>infix type or[A,B]</code></td>\n\t\t\t<td>3</td>\n\t\t\t<td>Полная</td>\n\t\t\t<td>Читаемость</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>Context Function</td>\n\t\t\t<td><code>C ?=&gt; T</code></td>\n\t\t\t<td>3</td>\n\t\t\t<td>Полная</td>\n\t\t\t<td>Implicit context</td>\n\t\t</tr>\n\t</tbody>\n</table>\n\n<h2>Комплексный пример использования разных конструкций</h2>\n\n<pre><code class=\"language-scala\">// Scala 3\nobject TypeAliasShowcase:\n  \n  // 1. Simple alias\n  type UserId = Long\n  \n  // 2. Parameterized\n  type Result[T] = Either[String, T]\n  \n  // 3. Bounded\n  type NumericList[T &lt;: Number] = List[T]\n  \n  // 4. Opaque\n  opaque type Email = String\n  object Email:\n    def apply(s: String): Option[Email] =\n      if s.contains(\"@\") then Some(s) else None\n  \n  // 5. Abstract (в trait)\n  trait Repository:\n    type Entity\n    def save(e: Entity): Result[UserId]\n  \n  // 6. Type lambda\n  type StringMap = [V] =&gt;&gt; Map[String, V]\n  \n  // 7. Match type\n  type Unwrap[T] = T match\n    case Option[t] =&gt; t\n    case List[t] =&gt; t\n    case t =&gt; t\n  \n  // 8. Union type\n  type JsonPrimitive = String | Int | Boolean | Null\n  \n  // 9. Intersection type\n  trait Loggable:\n    def log(msg: String): Unit\n  \n  trait Closeable:\n    def close(): Unit\n  \n  type Resource = Loggable &amp; Closeable\n  \n  // 10. Higher-kinded\n  type Effect[F[_], A] = F[A]\n  \n  // 11. Infix\n  infix type or[A, B] = A | B\n  \n  // 12. Context function\n  type Transaction[T] = Database ?=&gt; T\n  \n  // Использование всего вместе\n  class UserRepository(using db: Database) extends Repository:\n    type Entity = User\n    \n    def save(user: Entity): Transaction[Result[UserId]] =\n      summon[Database].execute {\n        Right(UserId(user.id))\n      }\n  \n  case class User(id: Long, email: Email, name: String)\n  \n  trait Database:\n    def execute[T](query: =&gt; T): T\n\n// Примеры использования\nimport TypeAliasShowcase.*\n\n// Simple и opaque\nval userId: UserId = 123L\nval email: Option[Email] = Email(\"user@example.com\")\n\n// Result\nval result: Result[Int] = Right(42)\n\n// Union type\nval json: JsonPrimitive = \"hello\"\nval json2: JsonPrimitive = 42\nval json3: JsonPrimitive = null\n\n// Unwrap match type\ntype T1 = Unwrap[Option[Int]]  // Int\ntype T2 = Unwrap[List[String]] // String\ntype T3 = Unwrap[Double]       // Double\n</code></pre>\n\n<h2>Когда использовать каждую конструкцию</h2>\n\n<pre><code class=\"language-scala\">// Simple alias - упрощение имён\ntype Config = Map[String, String]\n\n// Parameterized - generic обёртки\ntype Validated[T] = Either[List[String], T]\n\n// Opaque - domain types с типобезопасностью\nopaque type Money = BigDecimal\n\n// Abstract - полиморфные компоненты\ntrait Container:\n  type Element\n  def get: Element\n\n// Match type - type-level вычисления\ntype Head[T &lt;: Tuple] = T match\n  case h *: _ =&gt; h\n\n// Union - альтернативные значения\ntype ID = Int | String\n\n// Intersection - композиция возможностей\ntype SaveableAndLoadable = Saveable &amp; Loadable\n</code></pre>",
    "video" : null,
    "options" : {
      
    },
    "subtitle_files" : [
    ],
    "is_deprecated" : false
  },
  "name" : "text",
  "course_id" : 269026,
  "course_name" : " Система типов Scala 3",
  "exported_at" : "2026-01-10T10:36:23.0310867"
}