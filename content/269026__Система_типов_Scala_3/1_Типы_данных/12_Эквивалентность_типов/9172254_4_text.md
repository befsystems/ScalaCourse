# Материал (Шаг 4)

## Информация о шаге

- **ID шага**: 9172254
- **Позиция**: 4
- **Тип**: text
- **Курс**:  Система типов Scala 3
- **Экспортирован**: 2026-01-10T10:36:23.0325743

## Содержание

# Конструкции Type Aliases

### 1. Простые Type Aliases (Simple Type Aliases)

Базовая форма — прозрачный синоним типа:

// Простейшая форма
type UserId = Int
type UserName = String

// Синоним сложного типа
type StringMap = Map[String, String]
type ErrorOr[T] = Either[String, T]
type Callback = () => Unit

### 2. Параметризованные Type Aliases (Parameterized Type Aliases)

Type aliases с параметрами типа:

// Один параметр
type Optional[T] = Option[T]
type Result[T] = Either[String, T]

// Несколько параметров
type Pair[A, B] = (A, B)
type StringKeyMap[V] = Map[String, V]

// С ковариантностью/контравариантностью
type Producer[+T] = () => T
type Consumer[-T] = T => Unit

// Частичное применение типов
type IntMap[V] = Map[Int, V]
type StringToInt = Map[String, Int]

### 3. Type Aliases с границами (Bounded Type Aliases)

Type aliases с ограничениями на параметры типа:

// Верхняя граница (upper bound)
type NumericType[T <: Number] = T
type ComparableList[T <: Comparable[T]] = List[T]

// Нижняя граница (lower bound)
type SuperString[T >: String] = T

// Контекстные границы (context bounds)
type Ordered[T: Ordering] = List[T]
type Showable[T: Show] = T

// Множественные границы
type Serializable[T <: java.io.Serializable with Cloneable] = T

### 4. Opaque Type Aliases (Scala 3)

Непрозрачные синонимы с контролируемой видимостью:

object Domain:
// Простой opaque type
opaque type UserId = Long

// Opaque type с верхней границей
opaque type PositiveInt <: Int = Int

// Параметризованный opaque type
opaque type Wrapper[T] = T

// Opaque type с валидацией
opaque type Email = String

object Email:
def apply(s: String): Option[Email] =
if s.contains("@") then Some(s) else None

### 5. Abstract Type Members (Абстрактные члены типов)

Type aliases без определения (в traits/классах):

// Абстрактный тип без определения
trait Container:
type Element // абстрактный тип
def get: Element
def put(e: Element): Unit

// Реализация
class IntContainer extends Container:
type Element = Int // конкретизация
private var value: Int = 0
def get: Int = value
def put(e: Int): Unit = value = e

// С границами
trait BoundedContainer:
type Element <: Serializable
def get: Element

// Семейство типов (type families)
trait Graph:
type Node
type Edge
def nodes: List[Node]
def edges: List[Edge]

### 6. Path-Dependent Types (Зависимые от пути типы)

Type aliases, зависящие от экземпляра объекта:

class Outer:
class Inner
type MyInner = Inner

val outer1 = new Outer
val outer2 = new Outer

// Типы зависят от экземпляра
val inner1: outer1.Inner = new outer1.Inner
val inner2: outer2.Inner = new outer2.Inner

// inner1 и inner2 имеют РАЗНЫЕ типы!
// val x: outer1.Inner = inner2 // ОШИБКА!

// Type alias тоже path-dependent
type Inner1 = outer1.MyInner
type Inner2 = outer2.MyInner
// Inner1 ≠ Inner2

### 7. Type Lambdas (Scala 3)

Lambda-выражения на уровне типов:

// Старый синтаксис (Scala 2) - kind projector
type EitherString[A] = Either[String, A]

// Новый синтаксис (Scala 3) - type lambda
type EitherString = [A] =>> Either[String, A]

// Более сложные примеры
type Tuple2First = [A, B] =>> (A, B) match
case (a, _) => a

// Частичное применение
type MapWithStringKey = [V] =>> Map[String, V]

// Композиция типов
type Nested = [F[_], G[_], A] =>> F[G[A]]

### 8. Match Types (Scala 3)

Type aliases с сопоставлением с образцом:

// Базовый match type
type ElementType[T] = T match
case List[t] => t
case Array[t] => t
case Option[t] => t
case t => t

// Примеры использования
type E1 = ElementType[List[Int]] // Int
type E2 = ElementType[Array[String]] // String
type E3 = ElementType[Option[Double]]// Double
type E4 = ElementType[Boolean] // Boolean

// Рекурсивный match type
type Concat[A <: Tuple, B <: Tuple] = A match
case EmptyTuple => B
case h *: t => h *: Concat[t, B]

// Head и Tail для tuple
type Head[T <: Tuple] = T match
case h *: _ => h

type Tail[T <: Tuple] = T match
case _ *: t => t

// Применение
type T1 = Concat[(1, 2), (3, 4)] // (1, 2, 3, 4)
type H = Head[(Int, String, Boolean)] // Int
type T = Tail[(Int, String, Boolean)] // (String, Boolean)

### 9. Intersection и Union Types (Scala 3)

Type aliases для пересечений и объединений:

// Intersection type (&)
trait Readable:
def read(): String

trait Writable:
def write(s: String): Unit

type ReadWrite = Readable & Writable

// Union type (|)
type IntOrString = Int | String
type Nullable[T] = T | Null

// Комбинации
type NumberLike = Int | Long | Double | Float
type JsonValue = String | Int | Boolean | Null | JsonObject | JsonArray

// С параметрами
type Either3[A, B, C] = A | B | C

### 10. Refined Types (Уточнённые типы)

Type aliases с уточнениями структуры:

// Structural refinement
type PersonLike = {
def name: String
def age: Int
}

// С дополнительными методами
type Closeable = {
def close(): Unit
}

type Resource = {
def open(): Unit
def close(): Unit
def isOpen: Boolean
}

// Использование
def closeResource(r: Closeable): Unit = r.close()

// Может работать с любым объектом, у которого есть метод close()

### 11. Higher-Kinded Types (Типы высших порядков)

Type aliases для type constructors:

// Простой higher-kinded type
type Container[F[_]] = F[Int]

// Примеры
type ListOfInt = Container[List] // List[Int]
type OptionOfInt = Container[Option] // Option[Int]

// Более сложные
type Functor[F[_]] = [A, B] => (A => B) => F[A] => F[B]

// Monad-подобные
type FlatMap[F[_]] = [A, B] => F[A] => (A => F[B]) => F[B]

// Bi-functor
type Bifunctor[F[_, _]] = [A, B, C, D] =>
(A => C) => (B => D) => F[A, B] => F[C, D]

### 12. Existential Types (через Wildcards)

Type aliases с экзистенциальными типами:

// Scala 3 использует wildcards вместо forSome
type AnyList = List[?] // List любого типа

// С границами
type ListOfComparable = List[? <: Comparable[?]]

// В параметрах
type GenericPair[T] = (T, ?) // пара где второй элемент любого типа

// Java interop
type JavaList = java.util.List[?]

### 13. Type Aliases в Pattern Types (Scala 3)

Type aliases для паттернов:

// Extractors как типы
type ExtractInt = { def unapply(x: Any): Option[Int] }

// Singleton types
type Singleton42 = 42
type SingletonTrue = true
type SingletonHello = "hello"

// Literal types
type Port = 80 | 443 | 8080
type Direction = "north" | "south" | "east" | "west"

### 14. Infix Type Aliases (Scala 3)

Type aliases с инфиксной нотацией:

// Определение инфиксного типа
infix type or[A, B] = A | B
infix type and[A, B] = A & B

// Использование
type IntOrString = Int or String
type ReadableAndWritable = Readable and Writable

// Ассоциативность
type Complex = Int or String or Boolean
// эквивалентно: Int | String | Boolean

### 15. Context Function Types (Scala 3)

Type aliases для контекстных функций:

// Контекстная функция
type Executable[T] = ExecutionContext ?=> T

// Множественные контексты
type Transactional[T] = (Database, Transaction) ?=> T

// С параметрами
type Reader[R, A] = R ?=> A

// Использование
def compute: Executable[Int] = summon[ExecutionContext].execute(42)

## Сравнительная таблица всех конструкций

| Конструкция | Синтаксис | Scala версия | Прозрачность | Use Case |
| --- | --- | --- | --- | --- |
| Simple Alias | `type T = U` | 2, 3 | Полная | Упрощение сигнатур |
| Parameterized | `type F[T] = List[T]` | 2, 3 | Полная | Generic типы |
| Bounded | `type T[A > F[A]` | 3 | Полная | Higher-kinded |
| Match Type | `T match case ...` | 3 | Полная | Type-level logic |
| Intersection | `A & B` | 3 | Полная | Множественные trait |
| Union | `A | B` | 3 | Полная |
| Refined | `{ def m: T }` | 2, 3 | Полная | Структурные типы |
| Infix | `infix type or[A,B]` | 3 | Полная | Читаемость |
| Context Function | `C ?=> T` | 3 | Полная | Implicit context |

## Комплексный пример использования разных конструкций

// Scala 3
object TypeAliasShowcase:

// 1. Simple alias
type UserId = Long

// 2. Parameterized
type Result[T] = Either[String, T]

// 3. Bounded
type NumericList[T <: Number] = List[T]

// 4. Opaque
opaque type Email = String
object Email:
def apply(s: String): Option[Email] =
if s.contains("@") then Some(s) else None

// 5. Abstract (в trait)
trait Repository:
type Entity
def save(e: Entity): Result[UserId]

// 6. Type lambda
type StringMap = [V] =>> Map[String, V]

// 7. Match type
type Unwrap[T] = T match
case Option[t] => t
case List[t] => t
case t => t

// 8. Union type
type JsonPrimitive = String | Int | Boolean | Null

// 9. Intersection type
trait Loggable:
def log(msg: String): Unit

trait Closeable:
def close(): Unit

type Resource = Loggable & Closeable

// 10. Higher-kinded
type Effect[F[_], A] = F[A]

// 11. Infix
infix type or[A, B] = A | B

// 12. Context function
type Transaction[T] = Database ?=> T

// Использование всего вместе
class UserRepository(using db: Database) extends Repository:
type Entity = User

def save(user: Entity): Transaction[Result[UserId]] =
summon[Database].execute {
Right(UserId(user.id))
}

case class User(id: Long, email: Email, name: String)

trait Database:
def execute[T](query: => T): T

// Примеры использования
import TypeAliasShowcase.*

// Simple и opaque
val userId: UserId = 123L
val email: Option[Email] = Email("user@example.com")

// Result
val result: Result[Int] = Right(42)

// Union type
val json: JsonPrimitive = "hello"
val json2: JsonPrimitive = 42
val json3: JsonPrimitive = null

// Unwrap match type
type T1 = Unwrap[Option[Int]] // Int
type T2 = Unwrap[List[String]] // String
type T3 = Unwrap[Double] // Double

## Когда использовать каждую конструкцию

// Simple alias - упрощение имён
type Config = Map[String, String]

// Parameterized - generic обёртки
type Validated[T] = Either[List[String], T]

// Opaque - domain types с типобезопасностью
opaque type Money = BigDecimal

// Abstract - полиморфные компоненты
trait Container:
type Element
def get: Element

// Match type - type-level вычисления
type Head[T <: Tuple] = T match
case h *: _ => h

// Union - альтернативные значения
type ID = Int | String

// Intersection - композиция возможностей
type SaveableAndLoadable = Saveable & Loadable

---

### Полные данные JSON

<details>
<summary>Показать JSON данные</summary>

```json
{
  "name" : "text",
  "text" : "<h1 style=\"text-align:center;\">Конструкции Type Aliases</h1>\n\n<h3>1. Простые Type Aliases (Simple Type Aliases)</h3>\n\n<p>Базовая форма — прозрачный синоним типа:</p>\n\n<pre><code class=\"language-scala\">// Простейшая форма\ntype UserId = Int\ntype UserName = String\n\n// Синоним сложного типа\ntype StringMap = Map[String, String]\ntype ErrorOr[T] = Either[String, T]\ntype Callback = () =&gt; Unit\n</code></pre>\n\n<h3>2. Параметризованные Type Aliases (Parameterized Type Aliases)</h3>\n\n<p>Type aliases с параметрами типа:</p>\n\n<pre><code class=\"language-scala\">// Один параметр\ntype Optional[T] = Option[T]\ntype Result[T] = Either[String, T]\n\n// Несколько параметров\ntype Pair[A, B] = (A, B)\ntype StringKeyMap[V] = Map[String, V]\n\n// С ковариантностью/контравариантностью\ntype Producer[+T] = () =&gt; T\ntype Consumer[-T] = T =&gt; Unit\n\n// Частичное применение типов\ntype IntMap[V] = Map[Int, V]\ntype StringToInt = Map[String, Int]\n</code></pre>\n\n<h3>3. Type Aliases с границами (Bounded Type Aliases)</h3>\n\n<p>Type aliases с ограничениями на параметры типа:</p>\n\n<pre><code class=\"language-scala\">// Верхняя граница (upper bound)\ntype NumericType[T &lt;: Number] = T\ntype ComparableList[T &lt;: Comparable[T]] = List[T]\n\n// Нижняя граница (lower bound)\ntype SuperString[T &gt;: String] = T\n\n// Контекстные границы (context bounds)\ntype Ordered[T: Ordering] = List[T]\ntype Showable[T: Show] = T\n\n// Множественные границы\ntype Serializable[T &lt;: java.io.Serializable with Cloneable] = T\n</code></pre>\n\n<h3>4. Opaque Type Aliases (Scala 3)</h3>\n\n<p>Непрозрачные синонимы с контролируемой видимостью:</p>\n\n<pre><code class=\"language-scala\">object Domain:\n  // Простой opaque type\n  opaque type UserId = Long\n  \n  // Opaque type с верхней границей\n  opaque type PositiveInt &lt;: Int = Int\n  \n  // Параметризованный opaque type\n  opaque type Wrapper[T] = T\n  \n  // Opaque type с валидацией\n  opaque type Email = String\n  \n  object Email:\n    def apply(s: String): Option[Email] =\n      if s.contains(\"@\") then Some(s) else None\n</code></pre>\n\n<h3>5. Abstract Type Members (Абстрактные члены типов)</h3>\n\n<p>Type aliases без определения (в traits/классах):</p>\n\n<pre><code class=\"language-scala\">// Абстрактный тип без определения\ntrait Container:\n  type Element  // абстрактный тип\n  def get: Element\n  def put(e: Element): Unit\n\n// Реализация\nclass IntContainer extends Container:\n  type Element = Int  // конкретизация\n  private var value: Int = 0\n  def get: Int = value\n  def put(e: Int): Unit = value = e\n\n// С границами\ntrait BoundedContainer:\n  type Element &lt;: Serializable\n  def get: Element\n\n// Семейство типов (type families)\ntrait Graph:\n  type Node\n  type Edge\n  def nodes: List[Node]\n  def edges: List[Edge]\n</code></pre>\n\n<h3>6. Path-Dependent Types (Зависимые от пути типы)</h3>\n\n<p>Type aliases, зависящие от экземпляра объекта:</p>\n\n<pre><code class=\"language-scala\">class Outer:\n  class Inner\n  type MyInner = Inner\n\nval outer1 = new Outer\nval outer2 = new Outer\n\n// Типы зависят от экземпляра\nval inner1: outer1.Inner = new outer1.Inner\nval inner2: outer2.Inner = new outer2.Inner\n\n// inner1 и inner2 имеют РАЗНЫЕ типы!\n// val x: outer1.Inner = inner2  // ОШИБКА!\n\n// Type alias тоже path-dependent\ntype Inner1 = outer1.MyInner\ntype Inner2 = outer2.MyInner\n// Inner1 ≠ Inner2\n</code></pre>\n\n<h3>7. Type Lambdas (Scala 3)</h3>\n\n<p>Lambda-выражения на уровне типов:</p>\n\n<pre><code class=\"language-scala\">// Старый синтаксис (Scala 2) - kind projector\ntype EitherString[A] = Either[String, A]\n\n// Новый синтаксис (Scala 3) - type lambda\ntype EitherString = [A] =&gt;&gt; Either[String, A]\n\n// Более сложные примеры\ntype Tuple2First = [A, B] =&gt;&gt; (A, B) match\n  case (a, _) =&gt; a\n\n// Частичное применение\ntype MapWithStringKey = [V] =&gt;&gt; Map[String, V]\n\n// Композиция типов\ntype Nested = [F[_], G[_], A] =&gt;&gt; F[G[A]]\n</code></pre>\n\n<h3>8. Match Types (Scala 3)</h3>\n\n<p>Type aliases с сопоставлением с образцом:</p>\n\n<pre><code class=\"language-scala\">// Базовый match type\ntype ElementType[T] = T match\n  case List[t] =&gt; t\n  case Array[t] =&gt; t\n  case Option[t] =&gt; t\n  case t =&gt; t\n\n// Примеры использования\ntype E1 = ElementType[List[Int]]     // Int\ntype E2 = ElementType[Array[String]] // String\ntype E3 = ElementType[Option[Double]]// Double\ntype E4 = ElementType[Boolean]       // Boolean\n\n// Рекурсивный match type\ntype Concat[A &lt;: Tuple, B &lt;: Tuple] = A match\n  case EmptyTuple =&gt; B\n  case h *: t =&gt; h *: Concat[t, B]\n\n// Head и Tail для tuple\ntype Head[T &lt;: Tuple] = T match\n  case h *: _ =&gt; h\n\ntype Tail[T &lt;: Tuple] = T match\n  case _ *: t =&gt; t\n\n// Применение\ntype T1 = Concat[(1, 2), (3, 4)]  // (1, 2, 3, 4)\ntype H = Head[(Int, String, Boolean)]  // Int\ntype T = Tail[(Int, String, Boolean)]  // (String, Boolean)\n</code></pre>\n\n<h3>9. Intersection и Union Types (Scala 3)</h3>\n\n<p>Type aliases для пересечений и объединений:</p>\n\n<pre><code class=\"language-scala\">// Intersection type (&amp;)\ntrait Readable:\n  def read(): String\n\ntrait Writable:\n  def write(s: String): Unit\n\ntype ReadWrite = Readable &amp; Writable\n\n// Union type (|)\ntype IntOrString = Int | String\ntype Nullable[T] = T | Null\n\n// Комбинации\ntype NumberLike = Int | Long | Double | Float\ntype JsonValue = String | Int | Boolean | Null | JsonObject | JsonArray\n\n// С параметрами\ntype Either3[A, B, C] = A | B | C\n</code></pre>\n\n<h3>10. Refined Types (Уточнённые типы)</h3>\n\n<p>Type aliases с уточнениями структуры:</p>\n\n<pre><code class=\"language-scala\">// Structural refinement\ntype PersonLike = {\n  def name: String\n  def age: Int\n}\n\n// С дополнительными методами\ntype Closeable = {\n  def close(): Unit\n}\n\ntype Resource = {\n  def open(): Unit\n  def close(): Unit\n  def isOpen: Boolean\n}\n\n// Использование\ndef closeResource(r: Closeable): Unit = r.close()\n\n// Может работать с любым объектом, у которого есть метод close()\n</code></pre>\n\n<h3>11. Higher-Kinded Types (Типы высших порядков)</h3>\n\n<p>Type aliases для type constructors:</p>\n\n<pre><code class=\"language-scala\">// Простой higher-kinded type\ntype Container[F[_]] = F[Int]\n\n// Примеры\ntype ListOfInt = Container[List]      // List[Int]\ntype OptionOfInt = Container[Option]  // Option[Int]\n\n// Более сложные\ntype Functor[F[_]] = [A, B] =&gt; (A =&gt; B) =&gt; F[A] =&gt; F[B]\n\n// Monad-подобные\ntype FlatMap[F[_]] = [A, B] =&gt; F[A] =&gt; (A =&gt; F[B]) =&gt; F[B]\n\n// Bi-functor\ntype Bifunctor[F[_, _]] = [A, B, C, D] =&gt; \n  (A =&gt; C) =&gt; (B =&gt; D) =&gt; F[A, B] =&gt; F[C, D]\n</code></pre>\n\n<h3>12. Existential Types (через Wildcards)</h3>\n\n<p>Type aliases с экзистенциальными типами:</p>\n\n<pre><code class=\"language-scala\">// Scala 3 использует wildcards вместо forSome\ntype AnyList = List[?]  // List любого типа\n\n// С границами\ntype ListOfComparable = List[? &lt;: Comparable[?]]\n\n// В параметрах\ntype GenericPair[T] = (T, ?)  // пара где второй элемент любого типа\n\n// Java interop\ntype JavaList = java.util.List[?]\n</code></pre>\n\n<h3>13. Type Aliases в Pattern Types (Scala 3)</h3>\n\n<p>Type aliases для паттернов:</p>\n\n<pre><code class=\"language-scala\">// Extractors как типы\ntype ExtractInt = { def unapply(x: Any): Option[Int] }\n\n// Singleton types\ntype Singleton42 = 42\ntype SingletonTrue = true\ntype SingletonHello = \"hello\"\n\n// Literal types\ntype Port = 80 | 443 | 8080\ntype Direction = \"north\" | \"south\" | \"east\" | \"west\"\n</code></pre>\n\n<h3>14. Infix Type Aliases (Scala 3)</h3>\n\n<p>Type aliases с инфиксной нотацией:</p>\n\n<pre><code class=\"language-scala\">// Определение инфиксного типа\ninfix type or[A, B] = A | B\ninfix type and[A, B] = A &amp; B\n\n// Использование\ntype IntOrString = Int or String\ntype ReadableAndWritable = Readable and Writable\n\n// Ассоциативность\ntype Complex = Int or String or Boolean\n// эквивалентно: Int | String | Boolean\n</code></pre>\n\n<h3>15. Context Function Types (Scala 3)</h3>\n\n<p>Type aliases для контекстных функций:</p>\n\n<pre><code class=\"language-scala\">// Контекстная функция\ntype Executable[T] = ExecutionContext ?=&gt; T\n\n// Множественные контексты\ntype Transactional[T] = (Database, Transaction) ?=&gt; T\n\n// С параметрами\ntype Reader[R, A] = R ?=&gt; A\n\n// Использование\ndef compute: Executable[Int] = summon[ExecutionContext].execute(42)\n</code></pre>\n\n<h2>Сравнительная таблица всех конструкций</h2>\n\n<table>\n\t<thead>\n\t\t<tr>\n\t\t\t<th>Конструкция</th>\n\t\t\t<th>Синтаксис</th>\n\t\t\t<th>Scala версия</th>\n\t\t\t<th>Прозрачность</th>\n\t\t\t<th>Use Case</th>\n\t\t</tr>\n\t</thead>\n\t<tbody>\n\t\t<tr>\n\t\t\t<td>Simple Alias</td>\n\t\t\t<td><code>type T = U</code></td>\n\t\t\t<td>2, 3</td>\n\t\t\t<td>Полная</td>\n\t\t\t<td>Упрощение сигнатур</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>Parameterized</td>\n\t\t\t<td><code>type F[T] = List[T]</code></td>\n\t\t\t<td>2, 3</td>\n\t\t\t<td>Полная</td>\n\t\t\t<td>Generic типы</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>Bounded</td>\n\t\t\t<td><code>type T[A &lt;: B] = ...</code></td>\n\t\t\t<td>2, 3</td>\n\t\t\t<td>Полная</td>\n\t\t\t<td>Ограничения</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>Opaque</td>\n\t\t\t<td><code>opaque type T = U</code></td>\n\t\t\t<td>3</td>\n\t\t\t<td>В scope</td>\n\t\t\t<td>Типобезопасность</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>Abstract</td>\n\t\t\t<td><code>type T</code></td>\n\t\t\t<td>2, 3</td>\n\t\t\t<td>N/A</td>\n\t\t\t<td>Абстракция</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>Path-dependent</td>\n\t\t\t<td><code>obj.Type</code></td>\n\t\t\t<td>2, 3</td>\n\t\t\t<td>Зависит</td>\n\t\t\t<td>Модульность</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>Type Lambda</td>\n\t\t\t<td><code>[A] =&gt;&gt; F[A]</code></td>\n\t\t\t<td>3</td>\n\t\t\t<td>Полная</td>\n\t\t\t<td>Higher-kinded</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>Match Type</td>\n\t\t\t<td><code>T match case ...</code></td>\n\t\t\t<td>3</td>\n\t\t\t<td>Полная</td>\n\t\t\t<td>Type-level logic</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>Intersection</td>\n\t\t\t<td><code>A &amp; B</code></td>\n\t\t\t<td>3</td>\n\t\t\t<td>Полная</td>\n\t\t\t<td>Множественные trait</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>Union</td>\n\t\t\t<td>`A</td>\n\t\t\t<td>B`</td>\n\t\t\t<td>3</td>\n\t\t\t<td>Полная</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>Refined</td>\n\t\t\t<td><code>{ def m: T }</code></td>\n\t\t\t<td>2, 3</td>\n\t\t\t<td>Полная</td>\n\t\t\t<td>Структурные типы</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>Infix</td>\n\t\t\t<td><code>infix type or[A,B]</code></td>\n\t\t\t<td>3</td>\n\t\t\t<td>Полная</td>\n\t\t\t<td>Читаемость</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>Context Function</td>\n\t\t\t<td><code>C ?=&gt; T</code></td>\n\t\t\t<td>3</td>\n\t\t\t<td>Полная</td>\n\t\t\t<td>Implicit context</td>\n\t\t</tr>\n\t</tbody>\n</table>\n\n<h2>Комплексный пример использования разных конструкций</h2>\n\n<pre><code class=\"language-scala\">// Scala 3\nobject TypeAliasShowcase:\n  \n  // 1. Simple alias\n  type UserId = Long\n  \n  // 2. Parameterized\n  type Result[T] = Either[String, T]\n  \n  // 3. Bounded\n  type NumericList[T &lt;: Number] = List[T]\n  \n  // 4. Opaque\n  opaque type Email = String\n  object Email:\n    def apply(s: String): Option[Email] =\n      if s.contains(\"@\") then Some(s) else None\n  \n  // 5. Abstract (в trait)\n  trait Repository:\n    type Entity\n    def save(e: Entity): Result[UserId]\n  \n  // 6. Type lambda\n  type StringMap = [V] =&gt;&gt; Map[String, V]\n  \n  // 7. Match type\n  type Unwrap[T] = T match\n    case Option[t] =&gt; t\n    case List[t] =&gt; t\n    case t =&gt; t\n  \n  // 8. Union type\n  type JsonPrimitive = String | Int | Boolean | Null\n  \n  // 9. Intersection type\n  trait Loggable:\n    def log(msg: String): Unit\n  \n  trait Closeable:\n    def close(): Unit\n  \n  type Resource = Loggable &amp; Closeable\n  \n  // 10. Higher-kinded\n  type Effect[F[_], A] = F[A]\n  \n  // 11. Infix\n  infix type or[A, B] = A | B\n  \n  // 12. Context function\n  type Transaction[T] = Database ?=&gt; T\n  \n  // Использование всего вместе\n  class UserRepository(using db: Database) extends Repository:\n    type Entity = User\n    \n    def save(user: Entity): Transaction[Result[UserId]] =\n      summon[Database].execute {\n        Right(UserId(user.id))\n      }\n  \n  case class User(id: Long, email: Email, name: String)\n  \n  trait Database:\n    def execute[T](query: =&gt; T): T\n\n// Примеры использования\nimport TypeAliasShowcase.*\n\n// Simple и opaque\nval userId: UserId = 123L\nval email: Option[Email] = Email(\"user@example.com\")\n\n// Result\nval result: Result[Int] = Right(42)\n\n// Union type\nval json: JsonPrimitive = \"hello\"\nval json2: JsonPrimitive = 42\nval json3: JsonPrimitive = null\n\n// Unwrap match type\ntype T1 = Unwrap[Option[Int]]  // Int\ntype T2 = Unwrap[List[String]] // String\ntype T3 = Unwrap[Double]       // Double\n</code></pre>\n\n<h2>Когда использовать каждую конструкцию</h2>\n\n<pre><code class=\"language-scala\">// Simple alias - упрощение имён\ntype Config = Map[String, String]\n\n// Parameterized - generic обёртки\ntype Validated[T] = Either[List[String], T]\n\n// Opaque - domain types с типобезопасностью\nopaque type Money = BigDecimal\n\n// Abstract - полиморфные компоненты\ntrait Container:\n  type Element\n  def get: Element\n\n// Match type - type-level вычисления\ntype Head[T &lt;: Tuple] = T match\n  case h *: _ =&gt; h\n\n// Union - альтернативные значения\ntype ID = Int | String\n\n// Intersection - композиция возможностей\ntype SaveableAndLoadable = Saveable &amp; Loadable\n</code></pre>",
  "video" : null,
  "options" : {
    
  },
  "subtitle_files" : [
  ],
  "is_deprecated" : false
}
```

</details>
