{
  "step_id" : 9172315,
  "lesson_id" : 2140960,
  "position" : 2,
  "type" : "unknown",
  "block" : {
    "name" : "text",
    "text" : "<h1 style=\"text-align:center;\">Иерархия отношений между типами</h1>\n\n<h3>1. <strong>Равенство типов (Type Equality)</strong></h3>\n\n<p>Самое строгое отношение — типы <strong>идентичны</strong>:</p>\n\n<pre><code class=\"language-scala\">// Синтаксическое равенство\ntype A = Int\ntype B = Int\n// A ≡ B (буквально один и тот же тип)\n\n// Определяющее равенство (definitional equality)\ntype UserId = Int\n// UserId ≡ Int (по определению)\n</code></pre>\n\n<p><strong>Свойства</strong>: рефлексивность, симметричность, транзитивность</p>\n\n<h3>2. <strong>Эквивалентность типов (Type Equivalence)</strong></h3>\n\n<p>Типы <strong>взаимозаменяемы</strong> в контексте:</p>\n\n<pre><code class=\"language-scala\">// Структурная эквивалентность\ntype A = Int\ntype B = Int\n// A ~ B (эквивалентны структурно)\n\n// Номинальная эквивалентность (opaque types)\nopaque type UserId = Int\n// UserId ~scope Int (внутри scope)\n// UserId ≁ Int (снаружи scope)\n</code></pre>\n\n<p><strong>Свойства</strong>: рефлексивность, симметричность, транзитивность <strong>Мощность</strong>: |A| = |B|</p>\n\n<h3>3. <strong>Изоморфизм типов (Type Isomorphism)</strong></h3>\n\n<p>Типы имеют <strong>взаимно-обратные преобразования</strong>:</p>\n\n<pre><code class=\"language-scala\">// A ≅ B если существуют:\n// f: A → B\n// g: B → A\n// f ∘ g = id_B\n// g ∘ f = id_A\n\n// Пример: (A, B) ≅ (B, A)\ndef swap[A, B](p: (A, B)): (B, A) = (p._2, p._1)\ndef unswap[A, B](p: (B, A)): (A, B) = (p._2, p._1)\n</code></pre>\n\n<p><strong>Свойства</strong>: рефлексивность, симметричность, транзитивность <strong>Мощность</strong>: |A| = |B|</p>\n\n<h3>4. <strong>Подтипирование (Subtyping)</strong></h3>\n\n<p>Один тип является <strong>специализацией</strong> другого:</p>\n\n<pre><code class=\"language-scala\">// A &lt;: B (A подтип B)\ntrait Animal\nclass Dog extends Animal\n// Dog &lt;: Animal\n\n// Принцип подстановки Лисков\ndef process(animal: Animal): Unit = ???\nval dog: Dog = new Dog\nprocess(dog) // OK, Dog &lt;: Animal\n</code></pre>\n\n<p><strong>Свойства</strong>: рефлексивность, транзитивность, <strong>НЕ симметричность</strong> <strong>Мощность</strong>: |A| ≤ |B| (обычно |A| &lt; |B|)</p>\n\n<h3>5. <strong>Гомоморфизм (Homomorphism)</strong></h3>\n\n<p>Отображение, <strong>сохраняющее структуру</strong>:</p>\n\n<pre><code class=\"language-scala\">// Функтор — гомоморфизм между категориями\ntrait Functor[F[_]]:\n  def map[A, B](fa: F[A])(f: A =&gt; B): F[B]\n\n// Сохраняет композицию:\n// map(fa)(f ∘ g) = map(map(fa)(f))(g)\n\n// Сохраняет идентичность:\n// map(fa)(id) = fa\n</code></pre>\n\n<p><strong>Свойства</strong>: сохранение операций <strong>Мощность</strong>: может изменяться</p>\n\n<h3>6. <strong>Инъекция (Injection / Monomorphism)</strong></h3>\n\n<p>Отображение <strong>один-к-одному</strong> (без коллизий):</p>\n\n<pre><code class=\"language-scala\">// f: A → B инъективна если\n// f(x) = f(y) ⟹ x = y\n\n// Пример: refined types\nopaque type PositiveInt = Int\n\nobject PositiveInt:\n  def apply(n: Int): Option[PositiveInt] =\n    if n &gt; 0 then Some(n) else None\n\n// PositiveInt ↪ Int (инъекция, но не сюръекция)\n</code></pre>\n\n<p><strong>Свойства</strong>: нет коллизий <strong>Мощность</strong>: |A| ≤ |B|</p>\n\n<h3>7. <strong>Сюръекция (Surjection / Epimorphism)</strong></h3>\n\n<p>Отображение <strong>на весь образ</strong> (покрывает весь B):</p>\n\n<pre><code class=\"language-scala\">// f: A → B сюръективна если\n// ∀b ∈ B, ∃a ∈ A: f(a) = b\n\n// Пример: проекция\ndef projectFirst[A, B](p: (A, B)): A = p._1\n\n// (A, B) ↠ A (сюръекция)\n// Каждый элемент A достижим\n</code></pre>\n\n<p><strong>Свойства</strong>: полное покрытие <strong>Мощность</strong>: |A| ≥ |B|</p>\n\n<h3>8. <strong>Биекция (Bijection)</strong></h3>\n\n<p>Отображение, которое <strong>и инъекция, и сюръекция</strong>:</p>\n\n<pre><code class=\"language-scala\">// f: A → B биективна если\n// 1. f инъективна (один-к-одному)\n// 2. f сюръективна (покрывает весь B)\n\n// Биекция = изоморфизм в Set\n\ndef swap[A, B](p: (A, B)): (B, A) = (p._2, p._1)\n// Биекция: каждая пара (A,B) уникально мапится в (B,A)\n</code></pre>\n\n<p><strong>Свойства</strong>: взаимно-однозначное соответствие <strong>Мощность</strong>: |A| = |B|</p>\n\n<h2 style=\"text-align:center;\">Диаграмма отношений</h2>\n\n<pre><code>Равенство (=)\n    ↓ (более слабое)\nЭквивалентность (~)\n    ↓\nИзоморфизм (≅)\n    ↓\nБиекция (взаимно-однозначное)\n    ↓\nИнъекция (↪) ←→ Сюръекция (↠)\n    ↓           ↓\nГомоморфизм (сохранение структуры)\n    ↓\nПодтипирование (&lt;:)\n</code></pre>\n\n<h2 style=\"text-align:center;\">Сравнительная таблица</h2>\n\n<table>\n\t<thead>\n\t\t<tr>\n\t\t\t<th>Отношение</th>\n\t\t\t<th>Обратимо</th>\n\t\t\t<th>Мощность</th>\n\t\t\t<th>Пример в Scala</th>\n\t\t</tr>\n\t</thead>\n\t<tbody>\n\t\t<tr>\n\t\t\t<td>Равенство</td>\n\t\t\t<td>Да</td>\n\t\t\t<td>|A| = |B|</td>\n\t\t\t<td><code>type A = Int; type B = Int</code></td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>Эквивалентность</td>\n\t\t\t<td>Да</td>\n\t\t\t<td>|A| = |B|</td>\n\t\t\t<td><code>type UserId = Int</code></td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>Изоморфизм</td>\n\t\t\t<td>Да</td>\n\t\t\t<td>|A| = |B|</td>\n\t\t\t<td><code>(A,B) ≅ (B,A)</code></td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>Биекция</td>\n\t\t\t<td>Да</td>\n\t\t\t<td>|A| = |B|</td>\n\t\t\t<td><code>swap: (A,B) → (B,A)</code></td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>Инъекция</td>\n\t\t\t<td>Нет</td>\n\t\t\t<td>|A| ≤ |B|</td>\n\t\t\t<td><code>PositiveInt ↪ Int</code></td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>Сюръекция</td>\n\t\t\t<td>Нет</td>\n\t\t\t<td>|A| ≥ |B|</td>\n\t\t\t<td><code>(A,B) ↠ A</code></td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>Гомоморфизм</td>\n\t\t\t<td>Нет</td>\n\t\t\t<td>Любая</td>\n\t\t\t<td><code>map: F[A] → F[B]</code></td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>Подтипирование</td>\n\t\t\t<td>Нет</td>\n\t\t\t<td>|A| ≤ |B|</td>\n\t\t\t<td><code>Dog &lt;: Animal</code></td>\n\t\t</tr>\n\t</tbody>\n</table>\n\n<h2 style=\"text-align:center;\">Детальное сравнение</h2>\n\n<h3>Равенство vs Эквивалентность vs Изоморфизм</h3>\n\n<pre><code class=\"language-scala\">object Comparison:\n  \n  // 1. РАВЕНСТВО (definitional equality)\n  type A = Int\n  type B = Int\n  // A ≡ B (один и тот же тип, разные имена)\n  // Компилятор видит их как идентичные\n  \n  // 2. ЭКВИВАЛЕНТНОСТЬ (structural/nominal)\n  type UserId = Long\n  type OrderId = Long\n  // UserId ~ Long, OrderId ~ Long (структурная эквивалентность)\n  // UserId ~ OrderId (транзитивность)\n  // Компилятор считает их взаимозаменяемыми\n  \n  // 3. ИЗОМОРФИЗМ\n  case class Wrapper(value: Int)\n  // Wrapper ≅ Int (изоморфны, но не эквивалентны)\n  // Нужно явное преобразование:\n  def wrap(i: Int): Wrapper = Wrapper(i)\n  def unwrap(w: Wrapper): Int = w.value\n  // wrap ∘ unwrap = id, unwrap ∘ wrap = id\n</code></pre>\n\n<h3>Изоморфизм vs Подтипирование</h3>\n\n<pre><code class=\"language-scala\">object IsoVsSub:\n  \n  // ИЗОМОРФИЗМ (симметричное отношение)\n  // (A, B) ≅ (B, A)\n  def swap[A, B](p: (A, B)): (B, A) = (p._2, p._1)\n  def unswap[A, B](p: (B, A)): (A, B) = (p._2, p._1)\n  // Обратимо в обе стороны\n  \n  // ПОДТИПИРОВАНИЕ (асимметричное отношение)\n  trait Animal\n  class Dog extends Animal\n  // Dog &lt;: Animal\n  // НО НЕ Animal &lt;: Dog\n  \n  def upcast(dog: Dog): Animal = dog  // OK\n  // def downcast(animal: Animal): Dog = animal  // ОШИБКА!\n  // Необратимо без runtime проверки\n</code></pre>\n\n<h3>Инъекция vs Сюръекция vs Биекция</h3>\n\n<pre><code class=\"language-scala\">object Jections:\n  \n  // ИНЪЕКЦИЯ (один-к-одному, может быть не на всё)\n  def positive(n: Int): Option[Int] =\n    if n &gt; 0 then Some(n) else None\n  // Int → Option[Int]\n  // Каждый положительный Int мапится уникально\n  // Но не все Option[Int] достижимы (None недостижим)\n  \n  // СЮРЪЕКЦИЯ (покрывает всё, может быть много-к-одному)\n  def abs(n: Int): Int = n.abs\n  // Int → Int\n  // Каждый неотрицательный Int достижим\n  // Но abs(-5) = abs(5) = 5 (коллизия)\n  \n  // БИЕКЦИЯ (один-к-одному И покрывает всё)\n  def negate(n: Int): Int = -n\n  // Int → Int\n  // Каждый Int мапится уникально\n  // И каждый Int достижим\n  // negate(negate(n)) = n (обратимо)\n</code></pre>\n\n<h2 style=\"text-align:center;\">Специальные отношения</h2>\n\n<h3>9. <strong>Гомотопическая эквивалентность (Homotopy Equivalence)</strong></h3>\n\n<p>Из гомотопической теории типов (HoTT):</p>\n\n<pre><code class=\"language-scala\">// Два типа гомотопически эквивалентны если существуют:\n// f: A → B, g: B → A\n// И гомотопии (path/равенства):\n// H: f ∘ g ~ id_B\n// K: g ∘ f ~ id_A\n\n// Это \"слабее\" изоморфизма — учитывает пути между элементами\n</code></pre>\n\n<h3>10. <strong>Конгруэнтность (Congruence)</strong></h3>\n\n<p>Сохранение отношений при применении функций:</p>\n\n<pre><code class=\"language-scala\">// Если A ~ B, то F[A] ~ F[B]\ntype UserId = Int\ntype OrderId = Int\n\n// UserId ~ OrderId ⟹\n// List[UserId] ~ List[OrderId]\n// Option[UserId] ~ Option[OrderId]\n</code></pre>\n\n<h3>11. <strong>Ко-/Контравариантность</strong></h3>\n\n<p>Направление отношений при преобразовании:</p>\n\n<pre><code class=\"language-scala\">// Ковариантность: F[A] &lt;: F[B] если A &lt;: B\ntrait Producer[+A]  // ковариантен\n\n// Контравариантность: F[B] &lt;: F[A] если A &lt;: B\ntrait Consumer[-A]  // контравариантен\n\n// Инвариантность: нет связи\ntrait Invariant[A]  // инвариантен\n</code></pre>\n\n<h2 style=\"text-align:center;\">Практическое применение</h2>\n\n<pre><code class=\"language-scala\">object RealWorld:\n  \n  // Равенство — для простых синонимов\n  type JSON = String\n  type Config = Map[String, String]\n  \n  // Эквивалентность — через type alias\n  type UserId = Long\n  \n  // Изоморфизм — через opaque type\n  opaque type Email = String\n  object Email:\n    def apply(s: String): Option[Email] =\n      if s.contains(\"@\") then Some(s) else None\n    extension (e: Email)\n      def value: String = e\n  \n  // Подтипирование — через наследование\n  trait Repository[T]\n  class UserRepository extends Repository[User]\n  \n  // Инъекция — refined types\n  opaque type PositiveInt = Int\n  object PositiveInt:\n    def apply(n: Int): Option[PositiveInt] =\n      if n &gt; 0 then Some(n) else None\n  \n  // Гомоморфизм — функторы\n  extension [F[_]: Functor, A, B](fa: F[A])\n    def map(f: A =&gt; B): F[B] = summon[Functor[F]].map(fa)(f)\n</code></pre>",
    "video" : null,
    "options" : {
      
    },
    "subtitle_files" : [
    ],
    "is_deprecated" : false
  },
  "name" : "text",
  "course_id" : 269026,
  "course_name" : " Система типов Scala 3",
  "exported_at" : "2026-01-10T10:36:23.0152128"
}