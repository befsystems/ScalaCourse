# Материал (Шаг 2)

## Информация о шаге

- **ID шага**: 9172315
- **Позиция**: 2
- **Тип**: text
- **Курс**:  Система типов Scala 3
- **Экспортирован**: 2026-01-10T10:36:23.0167

## Содержание

# Иерархия отношений между типами

### 1. **Равенство типов (Type Equality)**

Самое строгое отношение — типы **идентичны**:

// Синтаксическое равенство
type A = Int
type B = Int
// A ≡ B (буквально один и тот же тип)

// Определяющее равенство (definitional equality)
type UserId = Int
// UserId ≡ Int (по определению)

**Свойства**: рефлексивность, симметричность, транзитивность

### 2. **Эквивалентность типов (Type Equivalence)**

Типы **взаимозаменяемы** в контексте:

// Структурная эквивалентность
type A = Int
type B = Int
// A ~ B (эквивалентны структурно)

// Номинальная эквивалентность (opaque types)
opaque type UserId = Int
// UserId ~scope Int (внутри scope)
// UserId ≁ Int (снаружи scope)

**Свойства**: рефлексивность, симметричность, транзитивность **Мощность**: |A| = |B|

### 3. **Изоморфизм типов (Type Isomorphism)**

Типы имеют **взаимно-обратные преобразования**:

// A ≅ B если существуют:
// f: A → B
// g: B → A
// f ∘ g = id_B
// g ∘ f = id_A

// Пример: (A, B) ≅ (B, A)
def swap[A, B](p: (A, B)): (B, A) = (p._2, p._1)
def unswap[A, B](p: (B, A)): (A, B) = (p._2, p._1)

**Свойства**: рефлексивность, симметричность, транзитивность **Мощность**: |A| = |B|

### 4. **Подтипирование (Subtyping)**

Один тип является **специализацией** другого:

// A <: B (A подтип B)
trait Animal
class Dog extends Animal
// Dog <: Animal

// Принцип подстановки Лисков
def process(animal: Animal): Unit = ???
val dog: Dog = new Dog
process(dog) // OK, Dog <: Animal

**Свойства**: рефлексивность, транзитивность, **НЕ симметричность** **Мощность**: |A| ≤ |B| (обычно |A| < |B|)

### 5. **Гомоморфизм (Homomorphism)**

Отображение, **сохраняющее структуру**:

// Функтор — гомоморфизм между категориями
trait Functor[F[_]]:
def map[A, B](fa: F[A])(f: A => B): F[B]

// Сохраняет композицию:
// map(fa)(f ∘ g) = map(map(fa)(f))(g)

// Сохраняет идентичность:
// map(fa)(id) = fa

**Свойства**: сохранение операций **Мощность**: может изменяться

### 6. **Инъекция (Injection / Monomorphism)**

Отображение **один-к-одному** (без коллизий):

// f: A → B инъективна если
// f(x) = f(y) ⟹ x = y

// Пример: refined types
opaque type PositiveInt = Int

object PositiveInt:
def apply(n: Int): Option[PositiveInt] =
if n > 0 then Some(n) else None

// PositiveInt ↪ Int (инъекция, но не сюръекция)

**Свойства**: нет коллизий **Мощность**: |A| ≤ |B|

### 7. **Сюръекция (Surjection / Epimorphism)**

Отображение **на весь образ** (покрывает весь B):

// f: A → B сюръективна если
// ∀b ∈ B, ∃a ∈ A: f(a) = b

// Пример: проекция
def projectFirst[A, B](p: (A, B)): A = p._1

// (A, B) ↠ A (сюръекция)
// Каждый элемент A достижим

**Свойства**: полное покрытие **Мощность**: |A| ≥ |B|

### 8. **Биекция (Bijection)**

Отображение, которое **и инъекция, и сюръекция**:

// f: A → B биективна если
// 1. f инъективна (один-к-одному)
// 2. f сюръективна (покрывает весь B)

// Биекция = изоморфизм в Set

def swap[A, B](p: (A, B)): (B, A) = (p._2, p._1)
// Биекция: каждая пара (A,B) уникально мапится в (B,A)

**Свойства**: взаимно-однозначное соответствие **Мощность**: |A| = |B|

## Диаграмма отношений

Равенство (=)
↓ (более слабое)
Эквивалентность (~)
↓
Изоморфизм (≅)
↓
Биекция (взаимно-однозначное)
↓
Инъекция (↪) ←→ Сюръекция (↠)
↓ ↓
Гомоморфизм (сохранение структуры)
↓
Подтипирование (<:)

## Сравнительная таблица

| Отношение | Обратимо | Мощность | Пример в Scala |
| --- | --- | --- | --- |
| Равенство | Да | |A| = |B| | `type A = Int; type B = Int` |
| Эквивалентность | Да | |A| = |B| | `type UserId = Int` |
| Изоморфизм | Да | |A| = |B| | `(A,B) ≅ (B,A)` |
| Биекция | Да | |A| = |B| | `swap: (A,B) → (B,A)` |
| Инъекция | Нет | |A| ≤ |B| | `PositiveInt ↪ Int` |
| Сюръекция | Нет | |A| ≥ |B| | `(A,B) ↠ A` |
| Гомоморфизм | Нет | Любая | `map: F[A] → F[B]` |
| Подтипирование | Нет | |A| ≤ |B| | `Dog object Comparison:

// 1. РАВЕНСТВО (definitional equality)
type A = Int
type B = Int
// A ≡ B (один и тот же тип, разные имена)
// Компилятор видит их как идентичные

// 2. ЭКВИВАЛЕНТНОСТЬ (structural/nominal)
type UserId = Long
type OrderId = Long
// UserId ~ Long, OrderId ~ Long (структурная эквивалентность)
// UserId ~ OrderId (транзитивность)
// Компилятор считает их взаимозаменяемыми

// 3. ИЗОМОРФИЗМ
case class Wrapper(value: Int)
// Wrapper ≅ Int (изоморфны, но не эквивалентны)
// Нужно явное преобразование:
def wrap(i: Int): Wrapper = Wrapper(i)
def unwrap(w: Wrapper): Int = w.value
// wrap ∘ unwrap = id, unwrap ∘ wrap = id

### Изоморфизм vs Подтипирование

object IsoVsSub:

// ИЗОМОРФИЗМ (симметричное отношение)
// (A, B) ≅ (B, A)
def swap[A, B](p: (A, B)): (B, A) = (p._2, p._1)
def unswap[A, B](p: (B, A)): (A, B) = (p._2, p._1)
// Обратимо в обе стороны

// ПОДТИПИРОВАНИЕ (асимметричное отношение)
trait Animal
class Dog extends Animal
// Dog <: Animal
// НО НЕ Animal <: Dog

def upcast(dog: Dog): Animal = dog // OK
// def downcast(animal: Animal): Dog = animal // ОШИБКА!
// Необратимо без runtime проверки

### Инъекция vs Сюръекция vs Биекция

object Jections:

// ИНЪЕКЦИЯ (один-к-одному, может быть не на всё)
def positive(n: Int): Option[Int] =
if n > 0 then Some(n) else None
// Int → Option[Int]
// Каждый положительный Int мапится уникально
// Но не все Option[Int] достижимы (None недостижим)

// СЮРЪЕКЦИЯ (покрывает всё, может быть много-к-одному)
def abs(n: Int): Int = n.abs
// Int → Int
// Каждый неотрицательный Int достижим
// Но abs(-5) = abs(5) = 5 (коллизия)

// БИЕКЦИЯ (один-к-одному И покрывает всё)
def negate(n: Int): Int = -n
// Int → Int
// Каждый Int мапится уникально
// И каждый Int достижим
// negate(negate(n)) = n (обратимо)

## Специальные отношения

### 9. **Гомотопическая эквивалентность (Homotopy Equivalence)**

Из гомотопической теории типов (HoTT):

// Два типа гомотопически эквивалентны если существуют:
// f: A → B, g: B → A
// И гомотопии (path/равенства):
// H: f ∘ g ~ id_B
// K: g ∘ f ~ id_A

// Это "слабее" изоморфизма — учитывает пути между элементами

### 10. **Конгруэнтность (Congruence)**

Сохранение отношений при применении функций:

// Если A ~ B, то F[A] ~ F[B]
type UserId = Int
type OrderId = Int

// UserId ~ OrderId ⟹
// List[UserId] ~ List[OrderId]
// Option[UserId] ~ Option[OrderId]

### 11. **Ко-/Контравариантность**

Направление отношений при преобразовании:

// Ковариантность: F[A] <: F[B] если A <: B
trait Producer[+A] // ковариантен

// Контравариантность: F[B] <: F[A] если A <: B
trait Consumer[-A] // контравариантен

// Инвариантность: нет связи
trait Invariant[A] // инвариантен

## Практическое применение

object RealWorld:

// Равенство — для простых синонимов
type JSON = String
type Config = Map[String, String]

// Эквивалентность — через type alias
type UserId = Long

// Изоморфизм — через opaque type
opaque type Email = String
object Email:
def apply(s: String): Option[Email] =
if s.contains("@") then Some(s) else None
extension (e: Email)
def value: String = e

// Подтипирование — через наследование
trait Repository[T]
class UserRepository extends Repository[User]

// Инъекция — refined types
opaque type PositiveInt = Int
object PositiveInt:
def apply(n: Int): Option[PositiveInt] =
if n > 0 then Some(n) else None

// Гомоморфизм — функторы
extension [F[_]: Functor, A, B](fa: F[A])
def map(f: A => B): F[B] = summon[Functor[F]].map(fa)(f)

---

### Полные данные JSON

<details>
<summary>Показать JSON данные</summary>

```json
{
  "name" : "text",
  "text" : "<h1 style=\"text-align:center;\">Иерархия отношений между типами</h1>\n\n<h3>1. <strong>Равенство типов (Type Equality)</strong></h3>\n\n<p>Самое строгое отношение — типы <strong>идентичны</strong>:</p>\n\n<pre><code class=\"language-scala\">// Синтаксическое равенство\ntype A = Int\ntype B = Int\n// A ≡ B (буквально один и тот же тип)\n\n// Определяющее равенство (definitional equality)\ntype UserId = Int\n// UserId ≡ Int (по определению)\n</code></pre>\n\n<p><strong>Свойства</strong>: рефлексивность, симметричность, транзитивность</p>\n\n<h3>2. <strong>Эквивалентность типов (Type Equivalence)</strong></h3>\n\n<p>Типы <strong>взаимозаменяемы</strong> в контексте:</p>\n\n<pre><code class=\"language-scala\">// Структурная эквивалентность\ntype A = Int\ntype B = Int\n// A ~ B (эквивалентны структурно)\n\n// Номинальная эквивалентность (opaque types)\nopaque type UserId = Int\n// UserId ~scope Int (внутри scope)\n// UserId ≁ Int (снаружи scope)\n</code></pre>\n\n<p><strong>Свойства</strong>: рефлексивность, симметричность, транзитивность <strong>Мощность</strong>: |A| = |B|</p>\n\n<h3>3. <strong>Изоморфизм типов (Type Isomorphism)</strong></h3>\n\n<p>Типы имеют <strong>взаимно-обратные преобразования</strong>:</p>\n\n<pre><code class=\"language-scala\">// A ≅ B если существуют:\n// f: A → B\n// g: B → A\n// f ∘ g = id_B\n// g ∘ f = id_A\n\n// Пример: (A, B) ≅ (B, A)\ndef swap[A, B](p: (A, B)): (B, A) = (p._2, p._1)\ndef unswap[A, B](p: (B, A)): (A, B) = (p._2, p._1)\n</code></pre>\n\n<p><strong>Свойства</strong>: рефлексивность, симметричность, транзитивность <strong>Мощность</strong>: |A| = |B|</p>\n\n<h3>4. <strong>Подтипирование (Subtyping)</strong></h3>\n\n<p>Один тип является <strong>специализацией</strong> другого:</p>\n\n<pre><code class=\"language-scala\">// A &lt;: B (A подтип B)\ntrait Animal\nclass Dog extends Animal\n// Dog &lt;: Animal\n\n// Принцип подстановки Лисков\ndef process(animal: Animal): Unit = ???\nval dog: Dog = new Dog\nprocess(dog) // OK, Dog &lt;: Animal\n</code></pre>\n\n<p><strong>Свойства</strong>: рефлексивность, транзитивность, <strong>НЕ симметричность</strong> <strong>Мощность</strong>: |A| ≤ |B| (обычно |A| &lt; |B|)</p>\n\n<h3>5. <strong>Гомоморфизм (Homomorphism)</strong></h3>\n\n<p>Отображение, <strong>сохраняющее структуру</strong>:</p>\n\n<pre><code class=\"language-scala\">// Функтор — гомоморфизм между категориями\ntrait Functor[F[_]]:\n  def map[A, B](fa: F[A])(f: A =&gt; B): F[B]\n\n// Сохраняет композицию:\n// map(fa)(f ∘ g) = map(map(fa)(f))(g)\n\n// Сохраняет идентичность:\n// map(fa)(id) = fa\n</code></pre>\n\n<p><strong>Свойства</strong>: сохранение операций <strong>Мощность</strong>: может изменяться</p>\n\n<h3>6. <strong>Инъекция (Injection / Monomorphism)</strong></h3>\n\n<p>Отображение <strong>один-к-одному</strong> (без коллизий):</p>\n\n<pre><code class=\"language-scala\">// f: A → B инъективна если\n// f(x) = f(y) ⟹ x = y\n\n// Пример: refined types\nopaque type PositiveInt = Int\n\nobject PositiveInt:\n  def apply(n: Int): Option[PositiveInt] =\n    if n &gt; 0 then Some(n) else None\n\n// PositiveInt ↪ Int (инъекция, но не сюръекция)\n</code></pre>\n\n<p><strong>Свойства</strong>: нет коллизий <strong>Мощность</strong>: |A| ≤ |B|</p>\n\n<h3>7. <strong>Сюръекция (Surjection / Epimorphism)</strong></h3>\n\n<p>Отображение <strong>на весь образ</strong> (покрывает весь B):</p>\n\n<pre><code class=\"language-scala\">// f: A → B сюръективна если\n// ∀b ∈ B, ∃a ∈ A: f(a) = b\n\n// Пример: проекция\ndef projectFirst[A, B](p: (A, B)): A = p._1\n\n// (A, B) ↠ A (сюръекция)\n// Каждый элемент A достижим\n</code></pre>\n\n<p><strong>Свойства</strong>: полное покрытие <strong>Мощность</strong>: |A| ≥ |B|</p>\n\n<h3>8. <strong>Биекция (Bijection)</strong></h3>\n\n<p>Отображение, которое <strong>и инъекция, и сюръекция</strong>:</p>\n\n<pre><code class=\"language-scala\">// f: A → B биективна если\n// 1. f инъективна (один-к-одному)\n// 2. f сюръективна (покрывает весь B)\n\n// Биекция = изоморфизм в Set\n\ndef swap[A, B](p: (A, B)): (B, A) = (p._2, p._1)\n// Биекция: каждая пара (A,B) уникально мапится в (B,A)\n</code></pre>\n\n<p><strong>Свойства</strong>: взаимно-однозначное соответствие <strong>Мощность</strong>: |A| = |B|</p>\n\n<h2 style=\"text-align:center;\">Диаграмма отношений</h2>\n\n<pre><code>Равенство (=)\n    ↓ (более слабое)\nЭквивалентность (~)\n    ↓\nИзоморфизм (≅)\n    ↓\nБиекция (взаимно-однозначное)\n    ↓\nИнъекция (↪) ←→ Сюръекция (↠)\n    ↓           ↓\nГомоморфизм (сохранение структуры)\n    ↓\nПодтипирование (&lt;:)\n</code></pre>\n\n<h2 style=\"text-align:center;\">Сравнительная таблица</h2>\n\n<table>\n\t<thead>\n\t\t<tr>\n\t\t\t<th>Отношение</th>\n\t\t\t<th>Обратимо</th>\n\t\t\t<th>Мощность</th>\n\t\t\t<th>Пример в Scala</th>\n\t\t</tr>\n\t</thead>\n\t<tbody>\n\t\t<tr>\n\t\t\t<td>Равенство</td>\n\t\t\t<td>Да</td>\n\t\t\t<td>|A| = |B|</td>\n\t\t\t<td><code>type A = Int; type B = Int</code></td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>Эквивалентность</td>\n\t\t\t<td>Да</td>\n\t\t\t<td>|A| = |B|</td>\n\t\t\t<td><code>type UserId = Int</code></td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>Изоморфизм</td>\n\t\t\t<td>Да</td>\n\t\t\t<td>|A| = |B|</td>\n\t\t\t<td><code>(A,B) ≅ (B,A)</code></td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>Биекция</td>\n\t\t\t<td>Да</td>\n\t\t\t<td>|A| = |B|</td>\n\t\t\t<td><code>swap: (A,B) → (B,A)</code></td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>Инъекция</td>\n\t\t\t<td>Нет</td>\n\t\t\t<td>|A| ≤ |B|</td>\n\t\t\t<td><code>PositiveInt ↪ Int</code></td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>Сюръекция</td>\n\t\t\t<td>Нет</td>\n\t\t\t<td>|A| ≥ |B|</td>\n\t\t\t<td><code>(A,B) ↠ A</code></td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>Гомоморфизм</td>\n\t\t\t<td>Нет</td>\n\t\t\t<td>Любая</td>\n\t\t\t<td><code>map: F[A] → F[B]</code></td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>Подтипирование</td>\n\t\t\t<td>Нет</td>\n\t\t\t<td>|A| ≤ |B|</td>\n\t\t\t<td><code>Dog &lt;: Animal</code></td>\n\t\t</tr>\n\t</tbody>\n</table>\n\n<h2 style=\"text-align:center;\">Детальное сравнение</h2>\n\n<h3>Равенство vs Эквивалентность vs Изоморфизм</h3>\n\n<pre><code class=\"language-scala\">object Comparison:\n  \n  // 1. РАВЕНСТВО (definitional equality)\n  type A = Int\n  type B = Int\n  // A ≡ B (один и тот же тип, разные имена)\n  // Компилятор видит их как идентичные\n  \n  // 2. ЭКВИВАЛЕНТНОСТЬ (structural/nominal)\n  type UserId = Long\n  type OrderId = Long\n  // UserId ~ Long, OrderId ~ Long (структурная эквивалентность)\n  // UserId ~ OrderId (транзитивность)\n  // Компилятор считает их взаимозаменяемыми\n  \n  // 3. ИЗОМОРФИЗМ\n  case class Wrapper(value: Int)\n  // Wrapper ≅ Int (изоморфны, но не эквивалентны)\n  // Нужно явное преобразование:\n  def wrap(i: Int): Wrapper = Wrapper(i)\n  def unwrap(w: Wrapper): Int = w.value\n  // wrap ∘ unwrap = id, unwrap ∘ wrap = id\n</code></pre>\n\n<h3>Изоморфизм vs Подтипирование</h3>\n\n<pre><code class=\"language-scala\">object IsoVsSub:\n  \n  // ИЗОМОРФИЗМ (симметричное отношение)\n  // (A, B) ≅ (B, A)\n  def swap[A, B](p: (A, B)): (B, A) = (p._2, p._1)\n  def unswap[A, B](p: (B, A)): (A, B) = (p._2, p._1)\n  // Обратимо в обе стороны\n  \n  // ПОДТИПИРОВАНИЕ (асимметричное отношение)\n  trait Animal\n  class Dog extends Animal\n  // Dog &lt;: Animal\n  // НО НЕ Animal &lt;: Dog\n  \n  def upcast(dog: Dog): Animal = dog  // OK\n  // def downcast(animal: Animal): Dog = animal  // ОШИБКА!\n  // Необратимо без runtime проверки\n</code></pre>\n\n<h3>Инъекция vs Сюръекция vs Биекция</h3>\n\n<pre><code class=\"language-scala\">object Jections:\n  \n  // ИНЪЕКЦИЯ (один-к-одному, может быть не на всё)\n  def positive(n: Int): Option[Int] =\n    if n &gt; 0 then Some(n) else None\n  // Int → Option[Int]\n  // Каждый положительный Int мапится уникально\n  // Но не все Option[Int] достижимы (None недостижим)\n  \n  // СЮРЪЕКЦИЯ (покрывает всё, может быть много-к-одному)\n  def abs(n: Int): Int = n.abs\n  // Int → Int\n  // Каждый неотрицательный Int достижим\n  // Но abs(-5) = abs(5) = 5 (коллизия)\n  \n  // БИЕКЦИЯ (один-к-одному И покрывает всё)\n  def negate(n: Int): Int = -n\n  // Int → Int\n  // Каждый Int мапится уникально\n  // И каждый Int достижим\n  // negate(negate(n)) = n (обратимо)\n</code></pre>\n\n<h2 style=\"text-align:center;\">Специальные отношения</h2>\n\n<h3>9. <strong>Гомотопическая эквивалентность (Homotopy Equivalence)</strong></h3>\n\n<p>Из гомотопической теории типов (HoTT):</p>\n\n<pre><code class=\"language-scala\">// Два типа гомотопически эквивалентны если существуют:\n// f: A → B, g: B → A\n// И гомотопии (path/равенства):\n// H: f ∘ g ~ id_B\n// K: g ∘ f ~ id_A\n\n// Это \"слабее\" изоморфизма — учитывает пути между элементами\n</code></pre>\n\n<h3>10. <strong>Конгруэнтность (Congruence)</strong></h3>\n\n<p>Сохранение отношений при применении функций:</p>\n\n<pre><code class=\"language-scala\">// Если A ~ B, то F[A] ~ F[B]\ntype UserId = Int\ntype OrderId = Int\n\n// UserId ~ OrderId ⟹\n// List[UserId] ~ List[OrderId]\n// Option[UserId] ~ Option[OrderId]\n</code></pre>\n\n<h3>11. <strong>Ко-/Контравариантность</strong></h3>\n\n<p>Направление отношений при преобразовании:</p>\n\n<pre><code class=\"language-scala\">// Ковариантность: F[A] &lt;: F[B] если A &lt;: B\ntrait Producer[+A]  // ковариантен\n\n// Контравариантность: F[B] &lt;: F[A] если A &lt;: B\ntrait Consumer[-A]  // контравариантен\n\n// Инвариантность: нет связи\ntrait Invariant[A]  // инвариантен\n</code></pre>\n\n<h2 style=\"text-align:center;\">Практическое применение</h2>\n\n<pre><code class=\"language-scala\">object RealWorld:\n  \n  // Равенство — для простых синонимов\n  type JSON = String\n  type Config = Map[String, String]\n  \n  // Эквивалентность — через type alias\n  type UserId = Long\n  \n  // Изоморфизм — через opaque type\n  opaque type Email = String\n  object Email:\n    def apply(s: String): Option[Email] =\n      if s.contains(\"@\") then Some(s) else None\n    extension (e: Email)\n      def value: String = e\n  \n  // Подтипирование — через наследование\n  trait Repository[T]\n  class UserRepository extends Repository[User]\n  \n  // Инъекция — refined types\n  opaque type PositiveInt = Int\n  object PositiveInt:\n    def apply(n: Int): Option[PositiveInt] =\n      if n &gt; 0 then Some(n) else None\n  \n  // Гомоморфизм — функторы\n  extension [F[_]: Functor, A, B](fa: F[A])\n    def map(f: A =&gt; B): F[B] = summon[Functor[F]].map(fa)(f)\n</code></pre>",
  "video" : null,
  "options" : {
    
  },
  "subtitle_files" : [
  ],
  "is_deprecated" : false
}
```

</details>
