{
  "step_id" : 9229992,
  "lesson_id" : 2158595,
  "position" : 1,
  "type" : "unknown",
  "block" : {
    "name" : "text",
    "text" : "<h1 style=\"text-align:center;\">For-Comprehension</h1>\n\n<p>For-comprehension — это синтаксическая конструкция в Scala, которая позволяет работать с монадическими типами данных в императивном стиле. Под капотом for-comprehension транслируется компилятором в цепочку вызовов методов <code>map</code>, <code>flatMap</code>, <code>withFilter</code> и <code>foreach</code>.</p>\n\n<h2>Базовый синтаксис</h2>\n\n<p>For-comprehension состоит из ключевого слова <code>for</code>, за которым следуют генераторы в фигурных скобках или круглых скобках, и тела выражения после <code>yield</code>:</p>\n\n<pre><code class=\"language-scala\">val result = for {\n  x &lt;- expression1\n  y &lt;- expression2\n} yield transformation\n</code></pre>\n\n<h2>Работа с Option</h2>\n\n<p>Option — идеальный тип для первого знакомства с for-comprehension, так как он представляет вычисление, которое может завершиться успехом (Some) или неудачей (None).</p>\n\n<h3>Простой пример</h3>\n\n<pre><code class=\"language-scala\">val maybeNumber: Option[Int] = Some(5)\nval maybeDouble: Option[Int] = Some(10)\n\nval result = for {\n  x &lt;- maybeNumber\n  y &lt;- maybeDouble\n} yield x + y\n\n// result: Option[Int] = Some(15)\n</code></pre>\n\n<h3>Обработка отсутствующих значений</h3>\n\n<pre><code class=\"language-scala\">val present: Option[Int] = Some(42)\nval absent: Option[Int] = None\n\nval result = for {\n  x &lt;- present\n  y &lt;- absent\n} yield x + y\n\n// result: Option[Int] = None\n</code></pre>\n\n<p>Если хотя бы один из Option содержит None, весь результат будет None.</p>\n\n<h3>Фильтрация значений</h3>\n\n<pre><code class=\"language-scala\">val number: Option[Int] = Some(7)\n\nval result = for {\n  x &lt;- number\n  if x &gt; 5\n} yield x * 2\n\n// result: Option[Int] = Some(14)\n\nval filtered = for {\n  x &lt;- number\n  if x &gt; 10\n} yield x * 2\n\n// filtered: Option[Int] = None\n</code></pre>\n\n<h2>Работа со списками</h2>\n\n<p>For-comprehension особенно мощен при работе с коллекциями, позволяя выражать сложные трансформации декларативно.</p>\n\n<h3>Простое преобразование</h3>\n\n<pre><code class=\"language-scala\">val numbers = List(1, 2, 3, 4, 5)\n\nval doubled = for {\n  n &lt;- numbers\n} yield n * 2\n\n// doubled: List[Int] = List(2, 4, 6, 8, 10)\n</code></pre>\n\n<h3>Декартово произведение</h3>\n\n<pre><code class=\"language-scala\">val numbers = List(1, 2, 3)\nval letters = List(10, 20)\n\nval combinations = for {\n  n &lt;- numbers\n  l &lt;- letters\n} yield n + l\n\n// combinations: List[Int] = List(11, 21, 12, 22, 13, 23)\n</code></pre>\n\n<h3>Фильтрация с условиями</h3>\n\n<pre><code class=\"language-scala\">val numbers = List(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)\n\nval evenSquares = for {\n  n &lt;- numbers\n  if n % 2 == 0\n} yield n * n\n\n// evenSquares: List[Int] = List(4, 16, 36, 64, 100)\n</code></pre>\n\n<h3>Множественные условия</h3>\n\n<pre><code class=\"language-scala\">val numbers = List(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)\n\nval filtered = for {\n  n &lt;- numbers\n  if n % 2 == 0\n  if n &gt; 4\n} yield n\n\n// filtered: List[Int] = List(6, 8, 10)\n</code></pre>\n\n<h2>Работа с Either</h2>\n\n<p>Either представляет вычисление, которое может вернуть либо ошибку (Left), либо успешный результат (Right).</p>\n\n<h3>Базовое использование</h3>\n\n<pre><code class=\"language-scala\">val rightValue: Either[String, Int] = Right(42)\nval anotherRight: Either[String, Int] = Right(8)\n\nval result = for {\n  x &lt;- rightValue\n  y &lt;- anotherRight\n} yield x + y\n\n// result: Either[String, Int] = Right(50)\n</code></pre>\n\n<h3>Обработка ошибок</h3>\n\n<pre><code class=\"language-scala\">val success: Either[String, Int] = Right(10)\nval failure: Either[String, Int] = Left(\"Ошибка!\")\n\nval result = for {\n  x &lt;- success\n  y &lt;- failure\n} yield x + y\n\n// result: Either[String, Int] = Left(\"Ошибка!\")\n</code></pre>\n\n<h3>Валидация с условиями</h3>\n\n<pre><code class=\"language-scala\">def divide(a: Int, b: Int): Either[String, Int] =\n  if b == 0 then Left(\"Деление на ноль\")\n  else Right(a / b)\n\nval calculation = for {\n  x &lt;- divide(10, 2)\n  y &lt;- divide(20, 4)\n} yield x + y\n\n// calculation: Either[String, Int] = Right(10)\n\nval failed = for {\n  x &lt;- divide(10, 2)\n  y &lt;- divide(20, 0)\n} yield x + y\n\n// failed: Either[String, Int] = Left(\"Деление на ноль\")\n</code></pre>\n\n<h2>Локальные переменные</h2>\n\n<p>В for-comprehension можно определять промежуточные значения без использования генератора:</p>\n\n<pre><code class=\"language-scala\">val numbers = List(1, 2, 3, 4, 5)\n\nval result = for {\n  n &lt;- numbers\n  squared = n * n\n  doubled = squared * 2\n} yield doubled\n\n// result: List[Int] = List(2, 8, 18, 32, 50)\n</code></pre>\n\n<p>С Option:</p>\n\n<pre><code class=\"language-scala\">val maybeNumber = Some(5)\n\nval result = for {\n  n &lt;- maybeNumber\n  doubled = n * 2\n  tripled = n * 3\n} yield doubled + tripled\n\n// result: Option[Int] = Some(25)\n</code></pre>\n\n<h2>Десугаризация: что происходит под капотом</h2>\n\n<p>Компилятор Scala транслирует for-comprehension в вызовы методов.</p>\n\n<h3>Простая трансформация</h3>\n\n<pre><code class=\"language-scala\">// Исходный код\nfor {\n  x &lt;- List(1, 2, 3)\n} yield x * 2\n\n// Транслируется в\nList(1, 2, 3).map(x =&gt; x * 2)\n</code></pre>\n\n<h3>Вложенные генераторы</h3>\n\n<pre><code class=\"language-scala\">// Исходный код\nfor {\n  x &lt;- List(1, 2)\n  y &lt;- List(10, 20)\n} yield x + y\n\n// Транслируется в\nList(1, 2).flatMap(x =&gt; \n  List(10, 20).map(y =&gt; x + y)\n)\n</code></pre>\n\n<h3>С условиями</h3>\n\n<pre><code class=\"language-scala\">// Исходный код\nfor {\n  x &lt;- List(1, 2, 3, 4)\n  if x % 2 == 0\n} yield x * 2\n\n// Транслируется в\nList(1, 2, 3, 4)\n  .withFilter(x =&gt; x % 2 == 0)\n  .map(x =&gt; x * 2)\n</code></pre>\n\n<h3>Без yield</h3>\n\n<p>Если не используется <code>yield</code>, вызывается метод <code>foreach</code>:</p>\n\n<pre><code class=\"language-scala\">// Исходный код\nfor {\n  x &lt;- List(1, 2, 3)\n} println(x)\n\n// Транслируется в\nList(1, 2, 3).foreach(x =&gt; println(x))\n</code></pre>\n\n<h2>Практические примеры</h2>\n\n<h3>Пример 1: Комбинации чисел</h3>\n\n<pre><code class=\"language-scala\">val result = for {\n  x &lt;- List(1, 2, 3)\n  y &lt;- List(4, 5)\n  sum = x + y\n  if sum &gt; 5\n} yield sum\n\n// result: List[Int] = List(6, 7, 6, 7, 7, 8)\n</code></pre>\n\n<h3>Пример 2: Цепочка Optional вычислений</h3>\n\n<pre><code class=\"language-scala\">def toInt(s: String): Option[Int] =\n  try Some(s.toInt)\n  catch case _ =&gt; None\n\nval input1 = \"42\"\nval input2 = \"10\"\n\nval result = for {\n  x &lt;- toInt(input1)\n  y &lt;- toInt(input2)\n  if x &gt; 0 &amp;&amp; y &gt; 0\n} yield x + y\n\n// result: Option[Int] = Some(52)\n</code></pre>\n\n<h3>Пример 3: Валидация данных</h3>\n\n<pre><code class=\"language-scala\">def validateAge(age: Int): Either[String, Int] =\n  if age &gt;= 0 &amp;&amp; age &lt;= 120 then Right(age)\n  else Left(s\"Некорректный возраст: $age\")\n\ndef validateScore(score: Int): Either[String, Int] =\n  if score &gt;= 0 &amp;&amp; score &lt;= 100 then Right(score)\n  else Left(s\"Некорректный балл: $score\")\n\nval validation = for {\n  age &lt;- validateAge(25)\n  score &lt;- validateScore(85)\n} yield (age, score)\n\n// validation: Either[String, (Int, Int)] = Right((25, 85))\n</code></pre>\n\n<h2>Советы и лучшие практики</h2>\n\n<ol>\n\t<li>\n\t<p><strong>Используйте for-comprehension для улучшения читаемости</strong> — когда есть несколько вложенных map/flatMap, for-comprehension делает код более понятным.</p>\n\t</li>\n\t<li>\n\t<p><strong>Избегайте излишней вложенности</strong> — если for-comprehension становится слишком сложным, разбейте его на несколько меньших функций.</p>\n\t</li>\n\t<li>\n\t<p><strong>Помните о типах</strong> — все генераторы должны работать с типами, которые поддерживают map/flatMap (монады).</p>\n\t</li>\n\t<li>\n\t<p><strong>Используйте локальные переменные</strong> — они делают код более выразительным и позволяют избежать повторных вычислений.</p>\n\t</li>\n\t<li>\n\t<p><strong>Условия применяйте разумно</strong> — помните, что withFilter может влиять на производительность при работе с большими коллекциями.</p>\n\t</li>\n</ol>\n\n<h2>Заключение</h2>\n\n<p>For-comprehension — это мощная абстракция в Scala, которая позволяет писать чистый, декларативный код для работы с монадическими типами. Понимание того, как for-comprehension транслируется в вызовы методов, помогает лучше понять функциональное программирование в целом и эффективно использовать этот инструмент в повседневной разработке.</p>",
    "video" : null,
    "options" : {
      
    },
    "subtitle_files" : [
    ],
    "is_deprecated" : false
  },
  "name" : "text",
  "course_id" : 269026,
  "course_name" : " Система типов Scala 3",
  "exported_at" : "2026-01-10T10:36:14.4230435"
}