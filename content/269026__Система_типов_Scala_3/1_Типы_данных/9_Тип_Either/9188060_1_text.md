# Материал (Шаг 1)

## Информация о шаге

- **ID шага**: 9188060
- **Позиция**: 1
- **Тип**: text
- **Курс**:  Система типов Scala 3
- **Экспортирован**: 2026-01-10T10:36:33.3101856

## Содержание

# Когда жизнь предлагает два пути

Представьте: вы пишете функцию поиска пользователя. Ищете сначала в кеше, потом в базе данных. Из какого источника результат? User из кеша или User из базы — как различить? И это важно для логирования, метрик, оптимизации.

Или другой пример: функция возвращает либо готовый результат вычислений, либо токен для отложенного выполнения.

Встречайте **`Either`** — тип, который говорит: "У меня для тебя вариант А или вариант Б, оба полноценные, просто разные, один левый, другой правый".

## Но подождите...

Хотя исторически **`Either`** действительно задумывался как симметричный тип "одно или другое", в современной Scala он эволюционировал. После Scala 2.12 Either де-факто стал инструментом обработки ошибок с **right-bias** семантикой. `**Left**` = ошибка, `**Right**` = успех. Это практичное соглашение победило математическую чистоту.

И знаете что? **`Either`** теперь закрывает нишу, которую не покрывают Option и Try: **типизированные ошибки с композицией**.

## Наследие Haskell

Either пришёл в Scala из функционального программирования, где подобные типы существуют десятилетиями. В Haskell он появился ещё в 90-х. Идея проста: есть два возможных сценария, и оба одинаково валидны. Не "что-то или ничего" (Option), не "успех или крах" (Try), а "вариант А или вариант Б".

В ранних версиях Scala **`Either`** был, скажем так, неудобным подростком. У него не было предпочтений: **`Left `**и `**Right**` были равноправны. Никакого **`map`**, никакого **`flatMap`**. Хотите обработать успешный случай? Извольте проверять вручную. Программисты морщились и писали костыли.

## Революция в Scala 2.12

Всё изменилось, когда Either повзрослел. Сообщество договорилось: давайте считать **`Right`** "правильным" (каламбур в английском: right = правый и правильный), а **`Left`** — "левым", то есть ошибочным. Внезапно Either стал **`right-biased`**: **`map `**работает с **`Right`**, игнорируя **`Left`**. Это сделало его мощным инструментом для обработки ошибок.

## Забавная история: спор о сторонах

В сообществе долго шла священная война: что класть в Left, что в Right? Математики настаивали на нейтральности: Either должен быть симметричным! Практики огрызались: нам нужна однозначность!

Один программист на Stack Overflow предложил революционное решение: "Давайте добавим третий вариант — Middle — для неопределённости". Сообщество дружно проигнорировало идею, но мем "Either с тремя состояниями" ещё годами гулял по форумам.

## Когда Either бьёт всех

**Композиция ошибок**. Представьте: вы валидируете форму регистрации. Email, пароль, возраст — у каждого свой тип ошибки. `**Try**` свалит всё в одну кучу `**Throwable**`. `**Option**` скажет только "что-то не так". А **`Either`** позволит собрать список конкретных проблем:

Either[ValidationError, User]
Either[NetworkTimeout | ParseError, Data]

Это не просто "что-то пошло не так", это контракт в типах.

## Когда Left — это не ошибка

**Маршрутизация запросов**. Публичное API идёт налево, внутреннее направо. Оба требуют аутентификации, просто разной.

**Источники данных**. Кеш слева (быстро, может устареть), база справа (медленно, всегда свежее). Выбираете стратегию в зависимости от ситуации.

**A/B тестирование**. Группа А получает старый алгоритм, группа Б — новый. **`Either[OldResult, NewResult] `**позволяет сравнивать результаты.

**Форматы данных**. XML слева, JSON справа. Оба парсятся, просто разными парсерами.

## Railway-oriented programming

Неважно, что у вас слева — ошибки или альтернативный путь. `**Either**` моделирует железную дорогу с развилкой. Каждая функция — стрелка. Попали на левый путь? Так и останетесь, пока явно не переключите.

Это работает для ошибок: первый сбой останавливает цепочку. Но работает и для маршрутизации: выбрали путь А, остаётесь на нём до явного решения.

## Композиция: сила в гибкости

**`Either`** легко трансформируется. **`swap`** меняет стороны местами — вдруг вам нужен **left-biased** поток. **`merge`** объединяет, если типы совпадают. `**fold**` обрабатывает оба случая явно.

Библиотеки расширяют возможности. Cats добавляет `**Validated**` — Either, который накапливает все "левые" значения вместо короткого замыкания. Для валидации форм, где нужны все ошибки сразу.

## Тёмная сторона

Either требует дисциплины: нужно договориться о типе ошибок в команде, иначе получите `**Either[Any, Any]**` — возврат в каменный век. Также `**Either**` честен до жестокости. Он заставляет вас явно признать: да, тут надо в любом случае выбирать. 

## Современность: экосистема

Сегодня `**Either**` — фундамент библиотек вроде Cats и ZIO. `**Validated**` из Cats накапливает все ошибки вместо короткого замыкания. `**EitherT**` оборачивает **`Either`** в монаду для работы с **`Future`**. Появились специализированные типы ошибок вроде **`NonEmptyList`**, чтобы гарантировать: если **`Left`**, то там точно есть хотя бы одна ошибка.

## Философия выбора

По сути, **`Either`** — это философское утверждение: мир **бинарен **в конкретный момент, но оба варианта имеют равное право на существование. Не "что-то или пустота", не "успех или хаос", а "вариант А или вариант Б", оба со своим типом, своей семантикой.

Scala 3 сохранил Either почти без изменений — знак того, что тип созрел. Он закрывает нишу, которую не могут закрыть Option и Try: нишу осознанного, типизированного, композируемого ветвления логики. И делает это красиво.

Но никто не помешает вам самим выбрать, что такое **лево**, и что такое **право**. 

---

### Полные данные JSON

<details>
<summary>Показать JSON данные</summary>

```json
{
  "name" : "text",
  "text" : "<h1 style=\"text-align:center;\">Когда жизнь предлагает два пути</h1>\n\n<p>Представьте: вы пишете функцию поиска пользователя. Ищете сначала в кеше, потом в базе данных. Из какого источника результат? User из кеша или User из базы — как различить? И это важно для логирования, метрик, оптимизации.</p>\n\n<p>Или другой пример: функция возвращает либо готовый результат вычислений, либо токен для отложенного выполнения.</p>\n\n<p>Встречайте <strong><code>Either</code></strong> — тип, который говорит: \"У меня для тебя вариант А или вариант Б, оба полноценные, просто разные, один левый, другой правый\".</p>\n\n<h2 style=\"text-align:center;\">Но подождите...</h2>\n\n<p>Хотя исторически <strong><code>Either</code></strong> действительно задумывался как симметричный тип \"одно или другое\", в современной Scala он эволюционировал. После Scala 2.12 Either де-факто стал инструментом обработки ошибок с <strong>right-bias</strong> семантикой. <code><strong>Left</strong></code> = ошибка, <code><strong>Right</strong></code> = успех. Это практичное соглашение победило математическую чистоту.</p>\n\n<p>И знаете что? <strong><code>Either</code></strong> теперь закрывает нишу, которую не покрывают Option и Try: <strong>типизированные ошибки с композицией</strong>.</p>\n\n<h2 style=\"text-align:center;\">Наследие Haskell</h2>\n\n<p>Either пришёл в Scala из функционального программирования, где подобные типы существуют десятилетиями. В Haskell он появился ещё в 90-х. Идея проста: есть два возможных сценария, и оба одинаково валидны. Не \"что-то или ничего\" (Option), не \"успех или крах\" (Try), а \"вариант А или вариант Б\".</p>\n\n<p>В ранних версиях Scala <strong><code>Either</code></strong> был, скажем так, неудобным подростком. У него не было предпочтений: <strong><code>Left </code></strong>и <code><strong>Right</strong></code> были равноправны. Никакого <strong><code>map</code></strong>, никакого <strong><code>flatMap</code></strong>. Хотите обработать успешный случай? Извольте проверять вручную. Программисты морщились и писали костыли.</p>\n\n<h2 style=\"text-align:center;\">Революция в Scala 2.12</h2>\n\n<p>Всё изменилось, когда Either повзрослел. Сообщество договорилось: давайте считать <strong><code>Right</code></strong> \"правильным\" (каламбур в английском: right = правый и правильный), а <strong><code>Left</code></strong> — \"левым\", то есть ошибочным. Внезапно Either стал <strong><code>right-biased</code></strong>: <strong><code>map </code></strong>работает с <strong><code>Right</code></strong>, игнорируя <strong><code>Left</code></strong>. Это сделало его мощным инструментом для обработки ошибок.</p>\n\n<h2 style=\"text-align:center;\">Забавная история: спор о сторонах</h2>\n\n<p>В сообществе долго шла священная война: что класть в Left, что в Right? Математики настаивали на нейтральности: Either должен быть симметричным! Практики огрызались: нам нужна однозначность!</p>\n\n<p>Один программист на Stack Overflow предложил революционное решение: \"Давайте добавим третий вариант — Middle — для неопределённости\". Сообщество дружно проигнорировало идею, но мем \"Either с тремя состояниями\" ещё годами гулял по форумам.</p>\n\n<h2 style=\"text-align:center;\">Когда Either бьёт всех</h2>\n\n<p><strong>Композиция ошибок</strong>. Представьте: вы валидируете форму регистрации. Email, пароль, возраст — у каждого свой тип ошибки. <code><strong>Try</strong></code> свалит всё в одну кучу <code><strong>Throwable</strong></code>. <code><strong>Option</strong></code> скажет только \"что-то не так\". А <strong><code>Either</code></strong> позволит собрать список конкретных проблем:</p>\n\n<pre><code class=\"language-scala\">Either[ValidationError, User]\nEither[NetworkTimeout | ParseError, Data]\n</code></pre>\n\n<p>Это не просто \"что-то пошло не так\", это контракт в типах.</p>\n\n<h2 style=\"text-align:center;\">Когда Left — это не ошибка</h2>\n\n<p><strong>Маршрутизация запросов</strong>. Публичное API идёт налево, внутреннее направо. Оба требуют аутентификации, просто разной.</p>\n\n<p><strong>Источники данных</strong>. Кеш слева (быстро, может устареть), база справа (медленно, всегда свежее). Выбираете стратегию в зависимости от ситуации.</p>\n\n<p><strong>A/B тестирование</strong>. Группа А получает старый алгоритм, группа Б — новый. <strong><code>Either[OldResult, NewResult] </code></strong>позволяет сравнивать результаты.</p>\n\n<p><strong>Форматы данных</strong>. XML слева, JSON справа. Оба парсятся, просто разными парсерами.</p>\n\n<h2 style=\"text-align:center;\">Railway-oriented programming</h2>\n\n<p>Неважно, что у вас слева — ошибки или альтернативный путь. <code><strong>Either</strong></code> моделирует железную дорогу с развилкой. Каждая функция — стрелка. Попали на левый путь? Так и останетесь, пока явно не переключите.</p>\n\n<p>Это работает для ошибок: первый сбой останавливает цепочку. Но работает и для маршрутизации: выбрали путь А, остаётесь на нём до явного решения.</p>\n\n<h2 style=\"text-align:center;\">Композиция: сила в гибкости</h2>\n\n<p><strong><code>Either</code></strong> легко трансформируется. <strong><code>swap</code></strong> меняет стороны местами — вдруг вам нужен <strong>left-biased</strong> поток. <strong><code>merge</code></strong> объединяет, если типы совпадают. <code><strong>fold</strong></code> обрабатывает оба случая явно.</p>\n\n<p>Библиотеки расширяют возможности. Cats добавляет <code><strong>Validated</strong></code> — Either, который накапливает все \"левые\" значения вместо короткого замыкания. Для валидации форм, где нужны все ошибки сразу.</p>\n\n<h2 style=\"text-align:center;\">Тёмная сторона</h2>\n\n<p>Either требует дисциплины: нужно договориться о типе ошибок в команде, иначе получите <code><strong>Either[Any, Any]</strong></code> — возврат в каменный век. Также <code><strong>Either</strong></code> честен до жестокости. Он заставляет вас явно признать: да, тут надо в любом случае выбирать. </p>\n\n<h2 style=\"text-align:center;\">Современность: экосистема</h2>\n\n<p>Сегодня <code><strong>Either</strong></code> — фундамент библиотек вроде Cats и ZIO. <code><strong>Validated</strong></code> из Cats накапливает все ошибки вместо короткого замыкания. <code><strong>EitherT</strong></code> оборачивает <strong><code>Either</code></strong> в монаду для работы с <strong><code>Future</code></strong>. Появились специализированные типы ошибок вроде <strong><code>NonEmptyList</code></strong>, чтобы гарантировать: если <strong><code>Left</code></strong>, то там точно есть хотя бы одна ошибка.</p>\n\n<h2 style=\"text-align:center;\">Философия выбора</h2>\n\n<p>По сути, <strong><code>Either</code></strong> — это философское утверждение: мир <strong>бинарен </strong>в конкретный момент, но оба варианта имеют равное право на существование. Не \"что-то или пустота\", не \"успех или хаос\", а \"вариант А или вариант Б\", оба со своим типом, своей семантикой.</p>\n\n<p>Scala 3 сохранил Either почти без изменений — знак того, что тип созрел. Он закрывает нишу, которую не могут закрыть Option и Try: нишу осознанного, типизированного, композируемого ветвления логики. И делает это красиво.</p>\n\n<p>Но никто не помешает вам самим выбрать, что такое <strong>лево</strong>, и что такое <strong>право</strong>. </p>",
  "video" : null,
  "options" : {
    
  },
  "subtitle_files" : [
  ],
  "is_deprecated" : false
}
```

</details>
