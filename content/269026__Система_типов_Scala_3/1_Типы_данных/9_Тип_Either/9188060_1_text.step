{
  "step_id" : 9188060,
  "lesson_id" : 2144964,
  "position" : 1,
  "type" : "unknown",
  "block" : {
    "name" : "text",
    "text" : "<h1 style=\"text-align:center;\">Когда жизнь предлагает два пути</h1>\n\n<p>Представьте: вы пишете функцию поиска пользователя. Ищете сначала в кеше, потом в базе данных. Из какого источника результат? User из кеша или User из базы — как различить? И это важно для логирования, метрик, оптимизации.</p>\n\n<p>Или другой пример: функция возвращает либо готовый результат вычислений, либо токен для отложенного выполнения.</p>\n\n<p>Встречайте <strong><code>Either</code></strong> — тип, который говорит: \"У меня для тебя вариант А или вариант Б, оба полноценные, просто разные, один левый, другой правый\".</p>\n\n<h2 style=\"text-align:center;\">Но подождите...</h2>\n\n<p>Хотя исторически <strong><code>Either</code></strong> действительно задумывался как симметричный тип \"одно или другое\", в современной Scala он эволюционировал. После Scala 2.12 Either де-факто стал инструментом обработки ошибок с <strong>right-bias</strong> семантикой. <code><strong>Left</strong></code> = ошибка, <code><strong>Right</strong></code> = успех. Это практичное соглашение победило математическую чистоту.</p>\n\n<p>И знаете что? <strong><code>Either</code></strong> теперь закрывает нишу, которую не покрывают Option и Try: <strong>типизированные ошибки с композицией</strong>.</p>\n\n<h2 style=\"text-align:center;\">Наследие Haskell</h2>\n\n<p>Either пришёл в Scala из функционального программирования, где подобные типы существуют десятилетиями. В Haskell он появился ещё в 90-х. Идея проста: есть два возможных сценария, и оба одинаково валидны. Не \"что-то или ничего\" (Option), не \"успех или крах\" (Try), а \"вариант А или вариант Б\".</p>\n\n<p>В ранних версиях Scala <strong><code>Either</code></strong> был, скажем так, неудобным подростком. У него не было предпочтений: <strong><code>Left </code></strong>и <code><strong>Right</strong></code> были равноправны. Никакого <strong><code>map</code></strong>, никакого <strong><code>flatMap</code></strong>. Хотите обработать успешный случай? Извольте проверять вручную. Программисты морщились и писали костыли.</p>\n\n<h2 style=\"text-align:center;\">Революция в Scala 2.12</h2>\n\n<p>Всё изменилось, когда Either повзрослел. Сообщество договорилось: давайте считать <strong><code>Right</code></strong> \"правильным\" (каламбур в английском: right = правый и правильный), а <strong><code>Left</code></strong> — \"левым\", то есть ошибочным. Внезапно Either стал <strong><code>right-biased</code></strong>: <strong><code>map </code></strong>работает с <strong><code>Right</code></strong>, игнорируя <strong><code>Left</code></strong>. Это сделало его мощным инструментом для обработки ошибок.</p>\n\n<h2 style=\"text-align:center;\">Забавная история: спор о сторонах</h2>\n\n<p>В сообществе долго шла священная война: что класть в Left, что в Right? Математики настаивали на нейтральности: Either должен быть симметричным! Практики огрызались: нам нужна однозначность!</p>\n\n<p>Один программист на Stack Overflow предложил революционное решение: \"Давайте добавим третий вариант — Middle — для неопределённости\". Сообщество дружно проигнорировало идею, но мем \"Either с тремя состояниями\" ещё годами гулял по форумам.</p>\n\n<h2 style=\"text-align:center;\">Когда Either бьёт всех</h2>\n\n<p><strong>Композиция ошибок</strong>. Представьте: вы валидируете форму регистрации. Email, пароль, возраст — у каждого свой тип ошибки. <code><strong>Try</strong></code> свалит всё в одну кучу <code><strong>Throwable</strong></code>. <code><strong>Option</strong></code> скажет только \"что-то не так\". А <strong><code>Either</code></strong> позволит собрать список конкретных проблем:</p>\n\n<pre><code class=\"language-scala\">Either[ValidationError, User]\nEither[NetworkTimeout | ParseError, Data]\n</code></pre>\n\n<p>Это не просто \"что-то пошло не так\", это контракт в типах.</p>\n\n<h2 style=\"text-align:center;\">Когда Left — это не ошибка</h2>\n\n<p><strong>Маршрутизация запросов</strong>. Публичное API идёт налево, внутреннее направо. Оба требуют аутентификации, просто разной.</p>\n\n<p><strong>Источники данных</strong>. Кеш слева (быстро, может устареть), база справа (медленно, всегда свежее). Выбираете стратегию в зависимости от ситуации.</p>\n\n<p><strong>A/B тестирование</strong>. Группа А получает старый алгоритм, группа Б — новый. <strong><code>Either[OldResult, NewResult] </code></strong>позволяет сравнивать результаты.</p>\n\n<p><strong>Форматы данных</strong>. XML слева, JSON справа. Оба парсятся, просто разными парсерами.</p>\n\n<h2 style=\"text-align:center;\">Railway-oriented programming</h2>\n\n<p>Неважно, что у вас слева — ошибки или альтернативный путь. <code><strong>Either</strong></code> моделирует железную дорогу с развилкой. Каждая функция — стрелка. Попали на левый путь? Так и останетесь, пока явно не переключите.</p>\n\n<p>Это работает для ошибок: первый сбой останавливает цепочку. Но работает и для маршрутизации: выбрали путь А, остаётесь на нём до явного решения.</p>\n\n<h2 style=\"text-align:center;\">Композиция: сила в гибкости</h2>\n\n<p><strong><code>Either</code></strong> легко трансформируется. <strong><code>swap</code></strong> меняет стороны местами — вдруг вам нужен <strong>left-biased</strong> поток. <strong><code>merge</code></strong> объединяет, если типы совпадают. <code><strong>fold</strong></code> обрабатывает оба случая явно.</p>\n\n<p>Библиотеки расширяют возможности. Cats добавляет <code><strong>Validated</strong></code> — Either, который накапливает все \"левые\" значения вместо короткого замыкания. Для валидации форм, где нужны все ошибки сразу.</p>\n\n<h2 style=\"text-align:center;\">Тёмная сторона</h2>\n\n<p>Either требует дисциплины: нужно договориться о типе ошибок в команде, иначе получите <code><strong>Either[Any, Any]</strong></code> — возврат в каменный век. Также <code><strong>Either</strong></code> честен до жестокости. Он заставляет вас явно признать: да, тут надо в любом случае выбирать. </p>\n\n<h2 style=\"text-align:center;\">Современность: экосистема</h2>\n\n<p>Сегодня <code><strong>Either</strong></code> — фундамент библиотек вроде Cats и ZIO. <code><strong>Validated</strong></code> из Cats накапливает все ошибки вместо короткого замыкания. <code><strong>EitherT</strong></code> оборачивает <strong><code>Either</code></strong> в монаду для работы с <strong><code>Future</code></strong>. Появились специализированные типы ошибок вроде <strong><code>NonEmptyList</code></strong>, чтобы гарантировать: если <strong><code>Left</code></strong>, то там точно есть хотя бы одна ошибка.</p>\n\n<h2 style=\"text-align:center;\">Философия выбора</h2>\n\n<p>По сути, <strong><code>Either</code></strong> — это философское утверждение: мир <strong>бинарен </strong>в конкретный момент, но оба варианта имеют равное право на существование. Не \"что-то или пустота\", не \"успех или хаос\", а \"вариант А или вариант Б\", оба со своим типом, своей семантикой.</p>\n\n<p>Scala 3 сохранил Either почти без изменений — знак того, что тип созрел. Он закрывает нишу, которую не могут закрыть Option и Try: нишу осознанного, типизированного, композируемого ветвления логики. И делает это красиво.</p>\n\n<p>Но никто не помешает вам самим выбрать, что такое <strong>лево</strong>, и что такое <strong>право</strong>. </p>",
    "video" : null,
    "options" : {
      
    },
    "subtitle_files" : [
    ],
    "is_deprecated" : false
  },
  "name" : "text",
  "course_id" : 269026,
  "course_name" : " Система типов Scala 3",
  "exported_at" : "2026-01-10T10:36:33.3091327"
}