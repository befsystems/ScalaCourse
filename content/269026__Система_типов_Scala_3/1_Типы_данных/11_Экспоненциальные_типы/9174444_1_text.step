{
  "step_id" : 9174444,
  "lesson_id" : 2141282,
  "position" : 1,
  "type" : "unknown",
  "block" : {
    "name" : "text",
    "text" : "<h1 style=\"text-align:center;\">Экспоненциальные типы</h1>\n\n<p>Экспоненциальный тип — это <strong>функциональный тип</strong> <code>A =&gt; B</code>. В алгебре типов он записывается как B^A и читается как \"B в степени A\".</p>\n\n<h3>Интуиция</h3>\n\n<p>Почему функция — это экспонента? Функция <code>A =&gt; B</code> должна для каждого возможного значения типа <code>A</code> предоставить значение типа <code>B</code>. Количество различных функций равно:</p>\n\n<pre><code>|B|^|A| = |B| × |B| × ... × |B|  (|A| раз)\n</code></pre>\n\n<h3>Простой пример</h3>\n\n<pre><code class=\"language-scala\">// Boolean =&gt; Boolean\n// Сколько существует различных функций?\n// 2^2 = 4 функции:\n\nval f1: Boolean =&gt; Boolean = identity        // true → true,  false → false\nval f2: Boolean =&gt; Boolean = !_             // true → false, false → true\nval f3: Boolean =&gt; Boolean = _ =&gt; true      // всегда true\nval f4: Boolean =&gt; Boolean = _ =&gt; false     // всегда false\n</code></pre>\n\n<p>Действительно, 2^2 = 4 различные функции!</p>\n\n<h3>Проверка на Unit</h3>\n\n<p><code>Unit</code> имеет ровно одно значение <code>()</code>. Давайте посмотрим на функции с <code>Unit</code>:</p>\n\n<pre><code class=\"language-scala\">// Boolean =&gt; Unit\n// Количество функций: 1^2 = 1\nval onlyOne: Boolean =&gt; Unit = _ =&gt; ()\n// Неважно, что мы передаём, результат всегда ()\n\n// Unit =&gt; Boolean  \n// Количество функций: 2^1 = 2\nval toTrue: Unit =&gt; Boolean = _ =&gt; true\nval toFalse: Unit =&gt; Boolean = _ =&gt; false\n</code></pre>\n\n<h2>Алгебраические законы для экспоненциальных типов</h2>\n\n<h3>Закон 1: A^0 = 1</h3>\n\n<p>Функция из пустого типа (Nothing) в любой тип существует ровно одна:</p>\n\n<pre><code class=\"language-scala\">// Nothing =&gt; Int\n// Количество функций: |Int|^0 = 1\n\ndef absurd[A]: Nothing =&gt; A = (n: Nothing) =&gt; n\n// Эта функция никогда не вызовется, так как Nothing необитаем\n</code></pre>\n\n<h3>Закон 2: A^1 = A</h3>\n\n<p>Функция из <code>Unit</code> изоморфна самому типу:</p>\n\n<pre><code class=\"language-scala\">// Unit =&gt; Boolean ≅ Boolean\n// Количество функций: 2^1 = 2\n\n// Функция хранит значение Boolean\nval storeTrue: Unit =&gt; Boolean = _ =&gt; true\nval storeFalse: Unit =&gt; Boolean = _ =&gt; false\n\n// Изоморфизм\ndef to[A](value: A): Unit =&gt; A = _ =&gt; value\ndef from[A](f: Unit =&gt; A): A = f(())\n</code></pre>\n\n<h3>Закон 3: 1^A = 1</h3>\n\n<p>Функция в <code>Unit</code> всегда одна:</p>\n\n<pre><code class=\"language-scala\">// Int =&gt; Unit\n// Количество функций: 1^|Int| = 1\n\nval onlyFunction: Int =&gt; Unit = _ =&gt; ()\n// Любое другое определение приведёт к той же функции\n</code></pre>\n\n<h3>Закон 4: A^(B+C) = A^B × A^C</h3>\n\n<p>Функция из суммы типов равна произведению функций:</p>\n\n<pre><code class=\"language-scala\">// (Boolean | Int) =&gt; String ≅ (Boolean =&gt; String, Int =&gt; String)\n\ndef split[A, B, C](\n  f: Either[A, B] =&gt; C\n): (A =&gt; C, B =&gt; C) = (\n  a =&gt; f(Left(a)),\n  b =&gt; f(Right(b))\n)\n\ndef combine[A, B, C](\n  fa: A =&gt; C, \n  fb: B =&gt; C\n): Either[A, B] =&gt; C = {\n  case Left(a) =&gt; fa(a)\n  case Right(b) =&gt; fb(b)\n}\n</code></pre>\n\n<h3>Закон 5: A^(B×C) = (A^B)^C</h3>\n\n<p>Функция из произведения равна каррированной функции:</p>\n\n<pre><code class=\"language-scala\">// (Boolean, Int) =&gt; String ≅ Boolean =&gt; (Int =&gt; String)\n\ndef curry[A, B, C](f: (A, B) =&gt; C): A =&gt; B =&gt; C =\n  a =&gt; b =&gt; f(a, b)\n\ndef uncurry[A, B, C](f: A =&gt; B =&gt; C): (A, B) =&gt; C =\n  (a, b) =&gt; f(a)(b)\n\n// Пример использования\nval add: (Int, Int) =&gt; Int = _ + _\nval curriedAdd: Int =&gt; Int =&gt; Int = curry(add)\nval result: Int = curriedAdd(5)(3)  // 8\n</code></pre>\n\n<h3>Закон 6: (A×B)^C = A^C × B^C</h3>\n\n<p>Функция в произведение равна произведению функций:</p>\n\n<pre><code class=\"language-scala\">// Boolean =&gt; (Int, String) ≅ (Boolean =&gt; Int, Boolean =&gt; String)\n\ndef split2[A, B, C](\n  f: A =&gt; (B, C)\n): (A =&gt; B, A =&gt; C) = (\n  a =&gt; f(a)._1,\n  a =&gt; f(a)._2\n)\n\ndef combine2[A, B, C](\n  fb: A =&gt; B,\n  fc: A =&gt; C\n): A =&gt; (B, C) =\n  a =&gt; (fb(a), fc(a))\n</code></pre>\n\n<h2>Практическое применение</h2>\n\n<h3>Композиция функций</h3>\n\n<p>Экспоненциальные типы естественно поддерживают композицию:</p>\n\n<pre><code class=\"language-scala\">// (B =&gt; C) × (A =&gt; B) =&gt; (A =&gt; C)\ndef compose[A, B, C](g: B =&gt; C, f: A =&gt; B): A =&gt; C =\n  a =&gt; g(f(a))\n\n// Пример\nval double: Int =&gt; Int = _ * 2\nval increment: Int =&gt; Int = _ + 1\nval doubleThenIncrement: Int =&gt; Int = compose(increment, double)\n\ndoubleThenIncrement(5)  // (5 * 2) + 1 = 11\n</code></pre>\n\n<h3>Функции высших порядков</h3>\n\n<pre><code class=\"language-scala\">// Функция, принимающая функцию\ndef applyTwice[A](f: A =&gt; A): A =&gt; A =\n  a =&gt; f(f(a))\n\nval quadruple: Int =&gt; Int = applyTwice(_ * 2)\nquadruple(3)  // ((3 * 2) * 2) = 12\n\n// Тип applyTwice: (A =&gt; A) =&gt; (A =&gt; A)\n// Это (A^A)^(A^A)\n</code></pre>\n\n<h3>Continuation-Passing Style</h3>\n\n<pre><code class=\"language-scala\">// CPS трансформирует A =&gt; B в A =&gt; ((B =&gt; R) =&gt; R)\ndef toCPS[A, B, R](f: A =&gt; B): A =&gt; (B =&gt; R) =&gt; R =\n  a =&gt; k =&gt; k(f(a))\n\nval addFive: Int =&gt; Int = _ + 5\nval addFiveCPS: Int =&gt; (Int =&gt; String) =&gt; String = toCPS(addFive)\n\naddFiveCPS(10)(result =&gt; s\"Result: $result\")  // \"Result: 15\"\n</code></pre>\n\n<h2>Связь с другими концепциями</h2>\n\n<h3>Функтор как экспонента</h3>\n\n<p>Функтор можно представить как тип, параметризованный другим типом:</p>\n\n<pre><code class=\"language-scala\">// Option[A] можно рассматривать как 1 + A\n// List[A] можно рассматривать как 1 + A × List[A]\n\ntrait Functor[F[_]]:\n  def map[A, B](fa: F[A])(f: A =&gt; B): F[B]\n  // map принимает A =&gt; B (экспоненту)\n</code></pre>\n\n<h3>Монада и композиция Клейсли</h3>\n\n<pre><code class=\"language-scala\">// Стрелки Клейсли: A =&gt; F[B]\n// Где F - монада\n\ntrait Monad[F[_]]:\n  def flatMap[A, B](fa: F[A])(f: A =&gt; F[B]): F[B]\n  \n// Композиция Клейсли: (B =&gt; F[C]) × (A =&gt; F[B]) =&gt; (A =&gt; F[C])\ndef composeKleisli[F[_]: Monad, A, B, C](\n  g: B =&gt; F[C],\n  f: A =&gt; F[B]\n): A =&gt; F[C] =\n  a =&gt; f(a).flatMap(g)\n</code></pre>",
    "video" : null,
    "options" : {
      
    },
    "subtitle_files" : [
    ],
    "is_deprecated" : false
  },
  "name" : "text",
  "course_id" : 269026,
  "course_name" : " Система типов Scala 3",
  "exported_at" : "2026-01-10T10:36:29.7075006"
}