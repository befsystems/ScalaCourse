# Материал (Шаг 4)

## Информация о шаге

- **ID шага**: 9167855
- **Позиция**: 4
- **Тип**: text
- **Курс**:  Система типов Scala 3
- **Экспортирован**: 2026-01-10T10:36:18.7550097

## Содержание

# Тип Range - диапазон чисел

**Range** — представляет **последовательность целых чисел** с постоянным шагом в виде ленивой коллекции. Математически - это генератор** арифметической прогрессии. **Элементы вычисляются **по требованию****. **Является одним из самых эффективных способов работы с числовыми диапазонами благодаря своей уникальной внутренней структуре. 

Вместо того чтобы хранить все элементы последовательности в памяти, Range хранит только **три числа**:

- **start** — начальное значение

- **end** — конечное значение

- **step** — шаг между элементами

## Определение Range

// Диапазон от 1 до 5 (включительно)
val r1 = 1 to 5
println(r1) // Range 1 to 5

// Диапазон от 1 до 5 (исключая 5)
val r2 = 1 until 5
println(r2) // Range 1 until 5

// Распечатаем элементы
r1.foreach(println) // 1, 2, 3, 4, 5
r2.foreach(println) // 1, 2, 3, 4

### Range с шагом

// Чётные числа от 0 до 10
val evens = 0 to 10 by 2
println(evens) // Range(0, 2, 4, 6, 8, 10)

// Числа, кратные 5
val fives = 0 to 50 by 5
println(fives) // Range(0, 5, 10, 15, ..., 50)

// Обратный порядок
val countdown = 10 to 1 by -1
println(countdown) // Range(10, 9, 8, ..., 1)

## Ограничения Range

Поддерживает только ограниченный список типов чисел: 

| Тип | Range | NumericRange | Примечание |
| --- | --- | --- | --- |
| **Int** | ✓ | ✓ | Range оптимизирован |
| **Long** | ✗ | ✓ | Большие числа |
| **Short** | ✗ | ✓ | Малые целые |
| **Byte** | ✗ | ✓ | Очень малые целые |
| **Char** | ✗ | ✓ | Символы |
| **BigInt** | ✗ | ✓ | Произвольная точность |
| **BigDecimal** | ✗ | ✓ | Дробные с точностью |
| **Double** | ✗ | ✗ | Нужен workaround |
| **Float** | ✗ | ✗ | Нужен workaround |
| **Пользовательский** | ✗ | ✓* | *С Integral/Fractional |

### Только постоянный шаг

// ✓ Постоянный шаг
val r1 = 1 to 10 by 2 // 1, 3, 5, 7, 9

// ✗ Нельзя: переменный шаг
// val r2 = 1, 2, 4, 8, 16, 32 // геометрическая прогрессия

## Range с другими типами чисел

// Long
val longs: NumericRange[Long] = 1L to 100L by 5L
println(longs.take(5)) // NumericRange(1, 6, 11, 16, 21)

// Char
val alphabet: NumericRange[Char] = 'A' to 'Z'
println(alphabet.take(5)) // NumericRange(A, B, C, D, E)

// BigInt
val bigInts = BigInt(1) to BigInt(1000) by 100
println(bigInts.take(3)) // NumericRange(1, 101, 201)

// BigDecimal
val decimals = BigDecimal(0.0) to BigDecimal(1.0) by 0.1
println(decimals.take(5)) // NumericRange(0.0, 0.1, 0.2, 0.3, 0.4)

Также, при желании, можно создать поддержку диапазона для своего типа, соблюдая некоторые требования реализации.

## Преимущества Range

- **Эффективность памяти** — хранит только три значения (start, end, step)

- **Ленивость** — вычисляет элементы по требованию

- **Типобезопасность** — гарантирует работу с Int

- **Гомогенность** — все компоненты одного типа

- **Богатый API** — полный набор коллекционных операций

### ✗ НЕ используйте Range когда:

- Нужны дробные числа

- Шаг непостоянный

- Нужно часто модифицировать последовательность

- Работаете с произвольными числами (не прогрессия)

##  Практические примеры

### Пример 1: Генерация таблицы умножения

val numbers = 1 to 10

numbers.foreach { i =>
val row = numbers.map(j => i * j)
println(row.mkString("\t"))
}

### Пример 2: Фильтрация простых чисел

def isPrime(n: Int): Boolean =
n > 1 && (2 until n).forall(n % _ != 0)

val primes = (2 to 50).filter(isPrime)
println(primes) // Vector(2, 3, 5, 7, 11, 13, ...)

### Пример 3: Суммы подмножеств

val r = 1 to 10

val windowSums = r.sliding(3).map(_.sum).toList
println(windowSums) // List(6, 9, 12, 15, 18, 21, 24, 27)

---

### Полные данные JSON

<details>
<summary>Показать JSON данные</summary>

```json
{
  "name" : "text",
  "text" : "<h1 style=\"text-align:center;\">Тип Range - диапазон чисел</h1>\n\n<p><strong>Range</strong> — представляет <strong>последовательность целых чисел</strong> с постоянным шагом в виде ленивой коллекции. Математически - это генератор<strong> арифметической прогрессии. </strong>Элементы вычисляются <strong>по требованию</strong><strong>. </strong>Является одним из самых эффективных способов работы с числовыми диапазонами благодаря своей уникальной внутренней структуре. </p>\n\n<p>Вместо того чтобы хранить все элементы последовательности в памяти, Range хранит только <strong>три числа</strong>:</p>\n\n<ul>\n\t<li><strong>start</strong> — начальное значение</li>\n\t<li><strong>end</strong> — конечное значение</li>\n\t<li><strong>step</strong> — шаг между элементами</li>\n</ul>\n\n<h2 style=\"text-align:center;\">Определение Range</h2>\n\n<pre><code class=\"language-scala\">// Диапазон от 1 до 5 (включительно)\nval r1 = 1 to 5\nprintln(r1)  // Range 1 to 5\n\n// Диапазон от 1 до 5 (исключая 5)\nval r2 = 1 until 5\nprintln(r2)  // Range 1 until 5\n\n// Распечатаем элементы\nr1.foreach(println)  // 1, 2, 3, 4, 5\nr2.foreach(println)  // 1, 2, 3, 4\n</code></pre>\n\n<h3>Range с шагом</h3>\n\n<pre><code class=\"language-scala\">// Чётные числа от 0 до 10\nval evens = 0 to 10 by 2\nprintln(evens)  // Range(0, 2, 4, 6, 8, 10)\n\n// Числа, кратные 5\nval fives = 0 to 50 by 5\nprintln(fives)  // Range(0, 5, 10, 15, ..., 50)\n\n// Обратный порядок\nval countdown = 10 to 1 by -1\nprintln(countdown)  // Range(10, 9, 8, ..., 1)\n</code></pre>\n\n<h2 style=\"text-align:center;\">Ограничения Range</h2>\n\n<p>Поддерживает только ограниченный список типов чисел: </p>\n\n<table>\n\t<thead>\n\t\t<tr>\n\t\t\t<th>Тип</th>\n\t\t\t<th>Range</th>\n\t\t\t<th>NumericRange</th>\n\t\t\t<th>Примечание</th>\n\t\t</tr>\n\t</thead>\n\t<tbody>\n\t\t<tr>\n\t\t\t<td><strong>Int</strong></td>\n\t\t\t<td>✓</td>\n\t\t\t<td>✓</td>\n\t\t\t<td>Range оптимизирован</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td><strong>Long</strong></td>\n\t\t\t<td>✗</td>\n\t\t\t<td>✓</td>\n\t\t\t<td>Большие числа</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td><strong>Short</strong></td>\n\t\t\t<td>✗</td>\n\t\t\t<td>✓</td>\n\t\t\t<td>Малые целые</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td><strong>Byte</strong></td>\n\t\t\t<td>✗</td>\n\t\t\t<td>✓</td>\n\t\t\t<td>Очень малые целые</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td><strong>Char</strong></td>\n\t\t\t<td>✗</td>\n\t\t\t<td>✓</td>\n\t\t\t<td>Символы</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td><strong>BigInt</strong></td>\n\t\t\t<td>✗</td>\n\t\t\t<td>✓</td>\n\t\t\t<td>Произвольная точность</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td><strong>BigDecimal</strong></td>\n\t\t\t<td>✗</td>\n\t\t\t<td>✓</td>\n\t\t\t<td>Дробные с точностью</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td><strong>Double</strong></td>\n\t\t\t<td>✗</td>\n\t\t\t<td>✗</td>\n\t\t\t<td>Нужен workaround</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td><strong>Float</strong></td>\n\t\t\t<td>✗</td>\n\t\t\t<td>✗</td>\n\t\t\t<td>Нужен workaround</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td><strong>Пользовательский</strong></td>\n\t\t\t<td>✗</td>\n\t\t\t<td>✓*</td>\n\t\t\t<td>*С Integral/Fractional</td>\n\t\t</tr>\n\t</tbody>\n</table>\n\n<h3 style=\"text-align:center;\">Только постоянный шаг</h3>\n\n<pre><code class=\"language-scala\">// ✓ Постоянный шаг\nval r1 = 1 to 10 by 2  // 1, 3, 5, 7, 9\n\n// ✗ Нельзя: переменный шаг\n// val r2 = 1, 2, 4, 8, 16, 32  // геометрическая прогрессия\n</code></pre>\n\n<h2 style=\"text-align:center;\">Range с другими типами чисел</h2>\n\n<pre><code class=\"language-scala\">// Long\nval longs: NumericRange[Long] = 1L to 100L by 5L\nprintln(longs.take(5))  // NumericRange(1, 6, 11, 16, 21)\n\n// Char\nval alphabet: NumericRange[Char] = 'A' to 'Z'\nprintln(alphabet.take(5))  // NumericRange(A, B, C, D, E)\n\n// BigInt\nval bigInts = BigInt(1) to BigInt(1000) by 100\nprintln(bigInts.take(3))  // NumericRange(1, 101, 201)\n\n// BigDecimal\nval decimals = BigDecimal(0.0) to BigDecimal(1.0) by 0.1\nprintln(decimals.take(5))  // NumericRange(0.0, 0.1, 0.2, 0.3, 0.4)</code></pre>\n\n<p>Также, при желании, можно создать поддержку диапазона для своего типа, соблюдая некоторые требования реализации.</p>\n\n<h2 style=\"text-align:center;\">Преимущества Range</h2>\n\n<ol>\n\t<li><strong>Эффективность памяти</strong> — хранит только три значения (start, end, step)</li>\n\t<li><strong>Ленивость</strong> — вычисляет элементы по требованию</li>\n\t<li><strong>Типобезопасность</strong> — гарантирует работу с Int</li>\n\t<li><strong>Гомогенность</strong> — все компоненты одного типа</li>\n\t<li><strong>Богатый API</strong> — полный набор коллекционных операций</li>\n</ol>\n\n<h3>✗ НЕ используйте Range когда:</h3>\n\n<ul>\n\t<li>Нужны дробные числа</li>\n\t<li>Шаг непостоянный</li>\n\t<li>Нужно часто модифицировать последовательность</li>\n\t<li>Работаете с произвольными числами (не прогрессия)</li>\n</ul>\n\n<h2 style=\"text-align:center;\"> Практические примеры</h2>\n\n<h3>Пример 1: Генерация таблицы умножения</h3>\n\n<pre><code class=\"language-scala\">val numbers = 1 to 10\n\nnumbers.foreach { i =&gt;\n  val row = numbers.map(j =&gt; i * j)\n  println(row.mkString(\"\\t\"))\n}\n</code></pre>\n\n<h3>Пример 2: Фильтрация простых чисел</h3>\n\n<pre><code class=\"language-scala\">def isPrime(n: Int): Boolean =\n  n &gt; 1 &amp;&amp; (2 until n).forall(n % _ != 0)\n\nval primes = (2 to 50).filter(isPrime)\nprintln(primes)  // Vector(2, 3, 5, 7, 11, 13, ...)\n</code></pre>\n\n<h3>Пример 3: Суммы подмножеств</h3>\n\n<pre><code class=\"language-scala\">val r = 1 to 10\n\nval windowSums = r.sliding(3).map(_.sum).toList\nprintln(windowSums)  // List(6, 9, 12, 15, 18, 21, 24, 27)\n</code></pre>",
  "video" : null,
  "options" : {
    
  },
  "subtitle_files" : [
  ],
  "is_deprecated" : false
}
```

</details>
