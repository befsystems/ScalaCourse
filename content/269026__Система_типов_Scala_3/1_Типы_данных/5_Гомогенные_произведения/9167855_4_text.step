{
  "step_id" : 9167855,
  "lesson_id" : 2138956,
  "position" : 4,
  "type" : "unknown",
  "block" : {
    "name" : "text",
    "text" : "<h1 style=\"text-align:center;\">Тип Range - диапазон чисел</h1>\n\n<p><strong>Range</strong> — представляет <strong>последовательность целых чисел</strong> с постоянным шагом в виде ленивой коллекции. Математически - это генератор<strong> арифметической прогрессии. </strong>Элементы вычисляются <strong>по требованию</strong><strong>. </strong>Является одним из самых эффективных способов работы с числовыми диапазонами благодаря своей уникальной внутренней структуре. </p>\n\n<p>Вместо того чтобы хранить все элементы последовательности в памяти, Range хранит только <strong>три числа</strong>:</p>\n\n<ul>\n\t<li><strong>start</strong> — начальное значение</li>\n\t<li><strong>end</strong> — конечное значение</li>\n\t<li><strong>step</strong> — шаг между элементами</li>\n</ul>\n\n<h2 style=\"text-align:center;\">Определение Range</h2>\n\n<pre><code class=\"language-scala\">// Диапазон от 1 до 5 (включительно)\nval r1 = 1 to 5\nprintln(r1)  // Range 1 to 5\n\n// Диапазон от 1 до 5 (исключая 5)\nval r2 = 1 until 5\nprintln(r2)  // Range 1 until 5\n\n// Распечатаем элементы\nr1.foreach(println)  // 1, 2, 3, 4, 5\nr2.foreach(println)  // 1, 2, 3, 4\n</code></pre>\n\n<h3>Range с шагом</h3>\n\n<pre><code class=\"language-scala\">// Чётные числа от 0 до 10\nval evens = 0 to 10 by 2\nprintln(evens)  // Range(0, 2, 4, 6, 8, 10)\n\n// Числа, кратные 5\nval fives = 0 to 50 by 5\nprintln(fives)  // Range(0, 5, 10, 15, ..., 50)\n\n// Обратный порядок\nval countdown = 10 to 1 by -1\nprintln(countdown)  // Range(10, 9, 8, ..., 1)\n</code></pre>\n\n<h2 style=\"text-align:center;\">Ограничения Range</h2>\n\n<p>Поддерживает только ограниченный список типов чисел: </p>\n\n<table>\n\t<thead>\n\t\t<tr>\n\t\t\t<th>Тип</th>\n\t\t\t<th>Range</th>\n\t\t\t<th>NumericRange</th>\n\t\t\t<th>Примечание</th>\n\t\t</tr>\n\t</thead>\n\t<tbody>\n\t\t<tr>\n\t\t\t<td><strong>Int</strong></td>\n\t\t\t<td>✓</td>\n\t\t\t<td>✓</td>\n\t\t\t<td>Range оптимизирован</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td><strong>Long</strong></td>\n\t\t\t<td>✗</td>\n\t\t\t<td>✓</td>\n\t\t\t<td>Большие числа</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td><strong>Short</strong></td>\n\t\t\t<td>✗</td>\n\t\t\t<td>✓</td>\n\t\t\t<td>Малые целые</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td><strong>Byte</strong></td>\n\t\t\t<td>✗</td>\n\t\t\t<td>✓</td>\n\t\t\t<td>Очень малые целые</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td><strong>Char</strong></td>\n\t\t\t<td>✗</td>\n\t\t\t<td>✓</td>\n\t\t\t<td>Символы</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td><strong>BigInt</strong></td>\n\t\t\t<td>✗</td>\n\t\t\t<td>✓</td>\n\t\t\t<td>Произвольная точность</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td><strong>BigDecimal</strong></td>\n\t\t\t<td>✗</td>\n\t\t\t<td>✓</td>\n\t\t\t<td>Дробные с точностью</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td><strong>Double</strong></td>\n\t\t\t<td>✗</td>\n\t\t\t<td>✗</td>\n\t\t\t<td>Нужен workaround</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td><strong>Float</strong></td>\n\t\t\t<td>✗</td>\n\t\t\t<td>✗</td>\n\t\t\t<td>Нужен workaround</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td><strong>Пользовательский</strong></td>\n\t\t\t<td>✗</td>\n\t\t\t<td>✓*</td>\n\t\t\t<td>*С Integral/Fractional</td>\n\t\t</tr>\n\t</tbody>\n</table>\n\n<h3 style=\"text-align:center;\">Только постоянный шаг</h3>\n\n<pre><code class=\"language-scala\">// ✓ Постоянный шаг\nval r1 = 1 to 10 by 2  // 1, 3, 5, 7, 9\n\n// ✗ Нельзя: переменный шаг\n// val r2 = 1, 2, 4, 8, 16, 32  // геометрическая прогрессия\n</code></pre>\n\n<h2 style=\"text-align:center;\">Range с другими типами чисел</h2>\n\n<pre><code class=\"language-scala\">// Long\nval longs: NumericRange[Long] = 1L to 100L by 5L\nprintln(longs.take(5))  // NumericRange(1, 6, 11, 16, 21)\n\n// Char\nval alphabet: NumericRange[Char] = 'A' to 'Z'\nprintln(alphabet.take(5))  // NumericRange(A, B, C, D, E)\n\n// BigInt\nval bigInts = BigInt(1) to BigInt(1000) by 100\nprintln(bigInts.take(3))  // NumericRange(1, 101, 201)\n\n// BigDecimal\nval decimals = BigDecimal(0.0) to BigDecimal(1.0) by 0.1\nprintln(decimals.take(5))  // NumericRange(0.0, 0.1, 0.2, 0.3, 0.4)</code></pre>\n\n<p>Также, при желании, можно создать поддержку диапазона для своего типа, соблюдая некоторые требования реализации.</p>\n\n<h2 style=\"text-align:center;\">Преимущества Range</h2>\n\n<ol>\n\t<li><strong>Эффективность памяти</strong> — хранит только три значения (start, end, step)</li>\n\t<li><strong>Ленивость</strong> — вычисляет элементы по требованию</li>\n\t<li><strong>Типобезопасность</strong> — гарантирует работу с Int</li>\n\t<li><strong>Гомогенность</strong> — все компоненты одного типа</li>\n\t<li><strong>Богатый API</strong> — полный набор коллекционных операций</li>\n</ol>\n\n<h3>✗ НЕ используйте Range когда:</h3>\n\n<ul>\n\t<li>Нужны дробные числа</li>\n\t<li>Шаг непостоянный</li>\n\t<li>Нужно часто модифицировать последовательность</li>\n\t<li>Работаете с произвольными числами (не прогрессия)</li>\n</ul>\n\n<h2 style=\"text-align:center;\"> Практические примеры</h2>\n\n<h3>Пример 1: Генерация таблицы умножения</h3>\n\n<pre><code class=\"language-scala\">val numbers = 1 to 10\n\nnumbers.foreach { i =&gt;\n  val row = numbers.map(j =&gt; i * j)\n  println(row.mkString(\"\\t\"))\n}\n</code></pre>\n\n<h3>Пример 2: Фильтрация простых чисел</h3>\n\n<pre><code class=\"language-scala\">def isPrime(n: Int): Boolean =\n  n &gt; 1 &amp;&amp; (2 until n).forall(n % _ != 0)\n\nval primes = (2 to 50).filter(isPrime)\nprintln(primes)  // Vector(2, 3, 5, 7, 11, 13, ...)\n</code></pre>\n\n<h3>Пример 3: Суммы подмножеств</h3>\n\n<pre><code class=\"language-scala\">val r = 1 to 10\n\nval windowSums = r.sliding(3).map(_.sum).toList\nprintln(windowSums)  // List(6, 9, 12, 15, 18, 21, 24, 27)\n</code></pre>",
    "video" : null,
    "options" : {
      
    },
    "subtitle_files" : [
    ],
    "is_deprecated" : false
  },
  "name" : "text",
  "course_id" : 269026,
  "course_name" : " Система типов Scala 3",
  "exported_at" : "2026-01-10T10:36:18.7545378"
}