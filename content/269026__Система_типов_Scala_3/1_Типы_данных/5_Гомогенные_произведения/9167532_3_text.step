{
  "step_id" : 9167532,
  "lesson_id" : 2138956,
  "position" : 3,
  "type" : "unknown",
  "block" : {
    "name" : "text",
    "text" : "<h1 style=\"text-align:center;\"> Операции с Array</h1>\n\n<h3>Доступ к элементам</h3>\n\n<pre><code class=\"language-scala\">val numbers = Array(10, 20, 30, 40, 50)\n\n// Чтение\nval first = numbers(0)        // 10\nval last = numbers(4)         // 50\nval head = numbers.head       // 10\nval lastElem = numbers.last   // 50\n\n// Изменение (Array является изменяемым)\nnumbers(0) = 100\nnumbers(2) = 300\n// numbers теперь: Array(100, 20, 300, 40, 50)\n</code></pre>\n\n<h3>Получение информации о массиве</h3>\n\n<pre><code class=\"language-scala\">val data = Array(5, 10, 15, 20)\n\nval size = data.length        // 4\nval isEmpty = data.isEmpty    // false\nval nonEmpty = data.nonEmpty  // true\n</code></pre>\n\n<h2>Интересные операции с массивами</h2>\n\n<h3>Трансформация элементов</h3>\n\n<pre><code class=\"language-scala\">val numbers = Array(1, 2, 3, 4, 5)\n\n// map: применить функцию к каждому элементу\nval doubled = numbers.map(x =&gt; x * 2)\n// Array(2, 4, 6, 8, 10)\n\nval squares = numbers.map(x =&gt; x * x)\n// Array(1, 4, 9, 16, 25)\n</code></pre>\n\n<h3>Фильтрация</h3>\n\n<pre><code class=\"language-scala\">val numbers = Array(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)\n\n// Только чётные числа\nval evens = numbers.filter(x =&gt; x % 2 == 0)\n// Array(2, 4, 6, 8, 10)\n\n// Числа больше 5\nval greaterThanFive = numbers.filter(x =&gt; x &gt; 5)\n// Array(6, 7, 8, 9, 10)\n</code></pre>\n\n<h3>Свёртка (reduce и fold)</h3>\n\n<pre><code class=\"language-scala\">val numbers = Array(1, 2, 3, 4, 5)\n\n// Сумма всех элементов\nval sum = numbers.reduce((a, b) =&gt; a + b)\n// 15\n\n// То же самое, короче\nval sum2 = numbers.sum\n// 15\n\n// Произведение всех элементов\nval product = numbers.reduce((a, b) =&gt; a * b)\n// 120\n\n// fold с начальным значением\nval sumPlus10 = numbers.fold(10)((a, b) =&gt; a + b)\n// 25 (10 + 1 + 2 + 3 + 4 + 5)\n</code></pre>\n\n<h3>Поиск элементов</h3>\n\n<pre><code class=\"language-scala\">val numbers = Array(10, 20, 30, 40, 50)\n\n// Найти элемент\nval found = numbers.find(x =&gt; x &gt; 25)\n// Some(30)\n\n// Проверить существование\nval exists = numbers.exists(x =&gt; x == 30)\n// true\n\nval containsHundred = numbers.contains(100)\n// false\n\n// Проверить, что все элементы удовлетворяют условию\nval allPositive = numbers.forall(x =&gt; x &gt; 0)\n// true\n</code></pre>\n\n<h3>Сортировка</h3>\n\n<pre><code class=\"language-scala\">val unsorted = Array(5, 2, 8, 1, 9)\n\n// Сортировка (создаёт новый массив)\nval sorted = unsorted.sorted\n// Array(1, 2, 5, 8, 9)\n\n// Обратная сортировка\nval reversed = unsorted.sorted.reverse\n// Array(9, 8, 5, 2, 1)\n\n// Изменяемая сортировка (изменяет исходный массив)\nval mutable = Array(5, 2, 8, 1, 9)\nscala.util.Sorting.quickSort(mutable)\n// mutable теперь: Array(1, 2, 5, 8, 9)\n</code></pre>\n\n<h3>Извлечение подмассивов</h3>\n\n<pre><code class=\"language-scala\">val numbers = Array(10, 20, 30, 40, 50, 60)\n\n// Взять первые n элементов\nval firstThree = numbers.take(3)\n// Array(10, 20, 30)\n\n// Пропустить первые n элементов\nval afterTwo = numbers.drop(2)\n// Array(30, 40, 50, 60)\n\n// Срез (slice)\nval middle = numbers.slice(1, 4)\n// Array(20, 30, 40)\n</code></pre>\n\n<h3>Группировка и разделение</h3>\n\n<pre><code class=\"language-scala\">val numbers = Array(1, 2, 3, 4, 5, 6, 7, 8)\n\n// Разделить на части по условию\nval (evens, odds) = numbers.partition(x =&gt; x % 2 == 0)\n// evens: Array(2, 4, 6, 8)\n// odds: Array(1, 3, 5, 7)\n\n// Сгруппировать по ключу\nval grouped = numbers.groupBy(x =&gt; x % 3)\n// Map(0 -&gt; Array(3, 6), 1 -&gt; Array(1, 4, 7), 2 -&gt; Array(2, 5, 8))\n</code></pre>\n\n<h3>Агрегация</h3>\n\n<pre><code class=\"language-scala\">val numbers = Array(1, 2, 3, 4, 5)\n\nval total = numbers.sum           // 15\nval maximum = numbers.max         // 5\nval minimum = numbers.min         // 1\nval average = numbers.sum.toDouble / numbers.length  // 3.0\n</code></pre>\n\n<h3>Объединение массивов</h3>\n\n<pre><code class=\"language-scala\">val first = Array(1, 2, 3)\nval second = Array(4, 5, 6)\n\n// Конкатенация\nval combined = first ++ second\n// Array(1, 2, 3, 4, 5, 6)\n\n// Добавление элемента (создаёт новый массив)\nval withExtra = first :+ 4\n// Array(1, 2, 3, 4)\n\nval withPrefix = 0 +: first\n// Array(0, 1, 2, 3)\n</code></pre>\n\n<h2 style=\"text-align:center;\"> Полный список операций</h2>\n\n<h3>Создание и инициализация</h3>\n\n<pre><code class=\"language-scala\">Array(1, 2, 3)                    // Из элементов\nnew Array[Int](5)                 // Фиксированного размера\nArray.fill(3)(0)                  // Заполнение значением\nArray.tabulate(5)(i =&gt; i * 2)     // По функции индекса\nArray.range(1, 10)                // Диапазон [1, 10)\nArray.ofDim[Int](3, 3)            // Многомерный\nArray.empty[String]               // Пустой массив\nArray[Int]()                      // Пустой массив\nArray.concat(arr1, arr2)          // Объединение массивов\nArray.iterate(0, 5)(_ + 1)        // Итерация: 0, 1, 2, 3, 4\n\n</code></pre>\n\n<h3>Доступ к элементам</h3>\n\n<pre><code class=\"language-scala\">arr(index)                        // По индексу\narr.head                          // Первый элемент\narr.last                          // Последний элемент\narr.tail                          // Все, кроме первого\narr.init                          // Все, кроме последнего\narr.headOption                    // Some(первый) или None\narr.lastOption                    // Some(последний) или None\n</code></pre>\n\n<h3>Информация о массиве</h3>\n\n<pre><code class=\"language-scala\">arr.length                        // Длина\narr.size                          // То же, что length\narr.isEmpty                       // Пустой?\narr.nonEmpty                      // Не пустой?\narr.indices                       // Индексы (Range)\n</code></pre>\n\n<h3>Трансформация</h3>\n\n<pre><code class=\"language-scala\">arr.map(f)                        // Применить функцию\narr.flatMap(f)                    // Map + flatten\narr.flatten                       // Развернуть вложенную структуру\narr.filter(p)                     // Отфильтровать\narr.filterNot(p)                  // Инверсная фильтрация\narr.collect { case ... }          // Частичная функция\narr.sorted                        // Отсортировать\narr.sortBy(f)                     // Отсортировать по функции\narr.sortWith((a, b) =&gt; ...)       // Отсортировать с компаратором\narr.reverse                       // Обратить порядок\narr.reverseIterator               // Итератор в обратном порядке\narr.distinct                      // Уникальные элементы\narr.transpose                     // Транспонировать (Array[Array[T]])\narr.updated(i, value)             // Новый массив с обновлённым элементом\narr.patch(from, patch, replaced)  // Заменить участок</code></pre>\n\n<h3>Поиск и проверка</h3>\n\n<pre><code class=\"language-scala\">arr.find(p)                       // Найти первый\narr.findLast(p)                   // Найти последний\narr.exists(p)                     // Есть хотя бы один?\narr.forall(p)                     // Все удовлетворяют?\narr.contains(elem)                // Содержит элемент?\narr.containsSlice(seq)            // Содержит подпоследовательность?\narr.indexOf(elem)                 // Индекс элемента\narr.indexOf(elem, from)           // Индекс с позиции from\narr.lastIndexOf(elem)             // Последний индекс элемента\narr.indexWhere(p)                 // Индекс первого удовлетворяющего\narr.lastIndexWhere(p)             // Индекс последнего удовлетворяющего\narr.indexOfSlice(seq)             // Индекс подпоследовательности\narr.count(p)                      // Количество по условию\n</code></pre>\n\n<h3>Агрегация</h3>\n\n<pre><code class=\"language-scala\">arr.sum                           // Сумма\narr.product                       // Произведение\narr.max                           // Максимум\narr.maxOption                     // Some(максимум) или None\narr.min                           // Минимум\narr.minOption                     // Some(минимум) или None\narr.maxBy(f)                      // Максимум по функции\narr.minBy(f)                      // Минимум по функции\narr.reduce(f)                     // Свёртка\narr.reduceOption(f)               // Безопасная свёртка\narr.reduceLeft(f)                 // Левая свёртка\narr.reduceRight(f)                // Правая свёртка\narr.fold(z)(f)                    // Свёртка с начальным\narr.foldLeft(z)(f)                // Левая свёртка с начальным\narr.foldRight(z)(f)               // Правая свёртка с начальным\narr.scan(z)(f)                    // Свёртка с промежуточными результатами\narr.scanLeft(z)(f)                // Левая scan\narr.scanRight(z)(f)               // Правая scan\narr.aggregate(z)(seqop, combop)   // Агрегация с комбинированием\n</code></pre>\n\n<h3>Извлечение подмассивов</h3>\n\n<pre><code class=\"language-scala\">arr.take(n)                       // Первые n элементов\narr.takeRight(n)                  // Последние n элементов\narr.drop(n)                       // Без первых n\narr.dropRight(n)                  // Без последних n\narr.slice(from, until)            // Срез [from, until)\narr.takeWhile(p)                  // Пока условие истинно\narr.dropWhile(p)                  // Пропустить пока истинно\narr.splitAt(n)                    // Разделить на позиции n\n</code></pre>\n\n<h3>Группировка и разделение</h3>\n\n<pre><code class=\"language-scala\">arr.partition(p)                  // Разделить по условию\narr.span(p)                       // Разделить в первой точке нарушения\narr.groupBy(f)                    // Сгруппировать по ключу\narr.groupMap(key)(value)          // Группировать и трансформировать\narr.groupMapReduce(key)(value)(reduce) // Группировать, трансформировать, свернуть\narr.grouped(n)                    // Разбить на группы по n\narr.sliding(n)                    // Скользящее окно размера n\narr.sliding(n, step)              // Скользящее окно с шагом\narr.combinations(n)               // Все комбинации по n элементов\narr.permutations                  // Все перестановки</code></pre>\n\n<h3>Комбинирование</h3>\n\n<pre><code class=\"language-scala\">arr1 ++ arr2                      // Конкатенация\narr1 ++: arr2                     // Добавить arr1 перед arr2\narr :+ elem                       // Добавить в конец\nelem +: arr                       // Добавить в начало\narr1.zip(arr2)                    // Объединить попарно\narr.zipWithIndex                  // С индексами\narr.zipAll(other, thisElem, thatElem) // Zip с заполнением\narr.unzip                         // Разделить пары (для Array[(A,B)])\narr1.corresponds(arr2)(p)         // Проверить соответствие элементов\narr1.diff(arr2)                   // Разность множеств\narr1.intersect(arr2)              // Пересечение множеств\narr1.union(arr2)                  // Объединение (с дубликатами)\narr.padTo(len, elem)              // Дополнить до длины len\n</code></pre>\n\n<h3>Побочные эффекты</h3>\n\n<pre><code class=\"language-scala\">arr.foreach(f)                    // Применить к каждому\narr.update(i, value)              // arr(i) = value\nscala.util.Sorting.quickSort(arr) // Сортировка на месте\n</code></pre>\n\n<h3>Конвертация</h3>\n\n<pre><code class=\"language-scala\">arr.toList                        // В List\narr.toVector                      // В Vector\narr.toSet                         // В Set\narr.toSeq                         // В Seq\narr.toIndexedSeq                  // В IndexedSeq\narr.toMap                         // В Map (для Array[(K,V)])\narr.toBuffer                      // В ArrayBuffer\narr.iterator                      // В Iterator\narr.reverseIterator               // Обратный итератор\narr.mkString                      // В строку\narr.mkString(sep)                 // В строку с разделителем\narr.mkString(start, sep, end)     // В строку с обрамлением\narr.deep                          // Для глубокого сравнения/вывода\n</code></pre>\n\n<h3>Операции для многомерных массивов </h3>\n\n<pre><code class=\"language-scala\">matrix.transpose                  // Транспонировать\nmatrix.flatten                    // Развернуть в одномерный</code></pre>",
    "video" : null,
    "options" : {
      
    },
    "subtitle_files" : [
    ],
    "is_deprecated" : false
  },
  "name" : "text",
  "course_id" : 269026,
  "course_name" : " Система типов Scala 3",
  "exported_at" : "2026-01-10T10:36:18.7376488"
}