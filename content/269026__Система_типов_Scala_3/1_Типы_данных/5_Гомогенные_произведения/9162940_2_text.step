{
  "step_id" : 9162940,
  "lesson_id" : 2138956,
  "position" : 2,
  "type" : "unknown",
  "block" : {
    "name" : "text",
    "text" : "<h1 style=\"text-align:center;\">Тип Array (массив)</h1>\n\n<p>Array — представляет собой упорядоченную коллекцию элементов <strong>фиксированной длины</strong>. В отличие от списков и других изменяемых коллекций, размер массива определяется при создании и не может быть изменён впоследствии.</p>\n\n<p>Термин <strong>\"массив\"</strong> происходит от французского слова <strong>\"massif\"</strong>, которое означает:</p>\n\n<ul>\n\t<li>Массивный, громоздкий</li>\n\t<li>Сплошной, монолитный</li>\n\t<li>Горный массив (большая группа гор)</li>\n</ul>\n\n<p>В русский язык это слово пришло через научную и техническую литературу, где использовалось для обозначения <strong>большой совокупности однородных элементов</strong>, расположенных компактно и упорядоченно. Интересно, что в разных языках  используются похожие понятия, часто <strong>Array.</strong></p>\n\n<p>В математике термин \"массив\" использовался задолго до компьютеров для обозначения:</p>\n\n<ul>\n\t<li><strong>Матриц</strong> (двумерных массивов чисел)</li>\n\t<li><strong>Векторов</strong> (одномерных массивов)</li>\n\t<li><strong>Таблиц данных</strong></li>\n</ul>\n\n<p> </p>\n\n<h2 style=\"text-align:center;\">Array - тип с параметром</h2>\n\n<p>Прежде чем углубиться в Array, важно понять концепцию типов с параметрами. <em>(полностью тема будет раскрыта в следующих уроках)</em></p>\n\n<p>Array является <strong>параметризованным типом</strong> (или generic type). Это означает, что при создании массива мы указываем, какой тип данных будет храниться в нём. Например:</p>\n\n<pre><code class=\"language-scala\">val numbers: Array[Int] = Array(1, 2, 3, 4, 5)\nval words: Array[String] = Array(\"hello\", \"world\")\nval flags: Array[Boolean] = Array(true, false, true)</code></pre>\n\n<p>Запись <code>Array[Int]</code> читается как \"массив целых чисел\", где <code>Int</code> — это <strong>параметр типа</strong>. Можно провести аналогию с контейнером: Array — это коробка, а параметр типа указывает, что именно в ней хранится.</p>\n\n<p>Компилятор Scala использует эту информацию для проверки типов во время компиляции, предотвращая ошибки:</p>\n\n<pre><code class=\"language-scala\">val numbers: Array[Int] = Array(1, 2, 3)\n// numbers(0) = \"text\" // Ошибка компиляции!</code></pre>\n\n<h2 style=\"text-align:center;\">Создание массивов</h2>\n\n<h3>Основные способы создания</h3>\n\n<pre><code class=\"language-scala\">// Способ 1: явное указание элементов\nval fruits = Array(\"apple\", \"banana\", \"orange\")\n\n// Способ 2: создание массива фиксированного размера\nval zeros = new Array[Int](5) // Array(0, 0, 0, 0, 0)\n\n// Способ 3: с явным указанием типа\nval temperatures: Array[Double] = Array(23.5, 18.2, 25.0)\n</code></pre>\n\n<h3>Важная особенность: фиксированная длина</h3>\n\n<pre><code class=\"language-scala\">val numbers = new Array[Int](3) // Массив из 3 элементов\nnumbers(0) = 10\nnumbers(1) = 20\nnumbers(2) = 30\n\n// numbers(3) = 40 // Ошибка выполнения: IndexOutOfBoundsException\n</code></pre>\n\n<p>После создания массива его длина не может быть изменена. Нельзя добавить новый элемент или удалить существующий, изменив размер массива.</p>\n\n<p>Хорошо, объясню сопоставление с образцом (pattern matching) для массивов в Scala 3 по-русски.</p>\n\n<h2 style=\"text-align:center;\">Рattern matching (декомпозиция) массивов</h2>\n\n<p>Можно использовать pattern matching для массивов:</p>\n\n<pre><code class=\"language-scala\">def matchArray(arr: Array[Int]): String = arr match\n  case Array() =&gt; \"Пустой массив\"\n  case Array(x) =&gt; s\"Один элемент: $x\"\n  case Array(x, y) =&gt; s\"Два элемента: $x и $y\"\n  case Array(1, y, z) =&gt; s\"Три элемента: 1, $y, $z\"\n  case Array(x, y, z) =&gt; s\"Три элемента: $x, $y, $z\"\n  case _ =&gt; s\"Массив из ${arr.length} элементов\"\n</code></pre>\n\n<h3>Сопоставление головы и хвоста</h3>\n\n<p>Используйте оператор <code>*</code> для сопоставления оставшихся элементов:</p>\n\n<pre><code class=\"language-scala\">def processArray(arr: Array[Int]): String = arr match\n  case Array() =&gt; \"Пустой\"\n  case Array(first, rest*) =&gt; s\"Первый: $first, Остаток: ${rest.length} элементов\"\n</code></pre>\n\n<h2 style=\"text-align:center;\">Фиксированная длина: преимущества и ограничения</h2>\n\n<h3>Преимущества</h3>\n\n<p><strong>Производительность</strong>: благодаря фиксированному размеру, Array обеспечивает:</p>\n\n<ul>\n\t<li>Быстрый доступ к элементам по индексу O(1)</li>\n\t<li>Эффективное использование памяти</li>\n\t<li>Предсказуемое расположение данных в памяти</li>\n</ul>\n\n<p><strong>Безопасность</strong>: размер известен заранее, что помогает избежать ошибок переполнения.</p>\n\n<h3>Когда использовать Array</h3>\n\n<pre><code class=\"language-scala\">// Хорошо: известное количество данных\nval daysInWeek = Array(\"Пн\", \"Вт\", \"Ср\", \"Чт\", \"Пт\", \"Сб\", \"Вс\")\nval monthDays = new Array[Int](31)\n\n// Плохо: динамически растущий набор данных\n// Для этого лучше использовать List, ArrayBuffer или Vector\n</code></pre>\n\n<h3>Сравнение с изменяемыми коллекциями</h3>\n\n<pre><code class=\"language-scala\">import scala.collection.mutable.ArrayBuffer\n\n// Array: фиксированный размер\nval fixedArray = Array(1, 2, 3)\n// fixedArray += 4 // Ошибка!\n\n// ArrayBuffer: переменный размер\nval dynamicBuffer = ArrayBuffer(1, 2, 3)\ndynamicBuffer += 4 // OK: ArrayBuffer(1, 2, 3, 4)\n</code></pre>\n\n<h2 style=\"text-align:center;\">Array - изменяемый массив</h2>\n\n<p>Array обладает <strong>частичной изменяемостью, </strong>можно изменять <strong>содержание элементов</strong> массива, но нельзя изменить <strong>размерность массива</strong>.</p>\n\n<pre><code class=\"language-scala\">val temperatures = Array(20.5, 22.0, 19.8, 23.1)\n\n// Синтаксис arr(index) = value на самом деле вызывает метод update\ntemperatures(0) = 21.0\ntemperatures.update(1, 22.5)  // Альтернативный синтаксис\n\nprintln(temperatures.mkString(\", \"))  // 21.0, 22.5, 19.8, 23.1</code></pre>\n\n<p>В функциональном подходе принято пользоваться неизменяемыми структурами данных. Однако, это приводит к необходимости создавать новые структуры при малейшем изменении старой структуры, что очень затратно при использовании больших массивов данных с произвольным доступом к элементам.</p>\n\n<p>Существование типа Array - это сознательное уступка императивному подходу, с целью повышения производительности  математических операций в массивах . В частности, это матричные вычисления, которые очень популярны в программировании. </p>\n\n<h2 style=\"text-align:center;\">Многомерные массивы</h2>\n\n<p>Scala поддерживает создание многомерных массивов — массивов, элементами которых являются другие массивы.</p>\n\n<h3>Двумерные массивы (матрицы)</h3>\n\n<pre><code class=\"language-scala\">// Создание двумерного массива 3x3\nval matrix = Array.ofDim[Int](3, 3)\n\n// Заполнение значениями\nmatrix(0)(0) = 1\nmatrix(0)(1) = 2\nmatrix(0)(2) = 3\nmatrix(1)(0) = 4\nmatrix(1)(1) = 5\nmatrix(1)(2) = 6\nmatrix(2)(0) = 7\nmatrix(2)(1) = 8\nmatrix(2)(2) = 9\n\n// Чтение\nval element = matrix(1)(2)  // 6\n</code></pre>\n\n<h3>Инициализация двумерного массива</h3>\n\n<pre><code class=\"language-scala\">// Способ 1: явное создание\nval table = Array(\n  Array(1, 2, 3),\n  Array(4, 5, 6),\n  Array(7, 8, 9)\n)\n\n// Способ 2: с помощью ofDim\nval grid = Array.ofDim[Double](2, 4)\n// 2 строки, 4 столбца, заполнено 0.0\n</code></pre>\n\n<h3>Работа с многомерными массивами</h3>\n\n<pre><code class=\"language-scala\">val matrix = Array(\n  Array(1, 2, 3),\n  Array(4, 5, 6),\n  Array(7, 8, 9)\n)\n\n// Обход всех элементов\n// flatMap \"разворачивает\" вложенную структуру\nmatrix.flatMap(identity).foreach(println)\n\n// Удвоить все элементы\nval doubled = matrix.map(row =&gt; row.map(_ * 2))\n\n// Сумма всех элементов\nval total = matrix.flatMap(identity).sum  // 45\n\n// Произведение всех элементов\nval product = matrix.flatMap(identity).product  // 362880\n\n// Функциональное транспонирование\nval transposed = matrix.transpose\n// Array(\n//   Array(1, 4, 7),\n//   Array(2, 5, 8),\n//   Array(3, 6, 9)\n// )\n\n// Создание таблицы умножения, вариант 1\ndef multiplicationTable(size: Int): Array[Array[Int]] = {\n  Array.tabulate(size, size)((i, j) =&gt; (i + 1) * (j + 1))\n}\n\n// Создание таблицы умножения, вариант 2\ndef multiplicationTable(size: Int): Array[Array[Int]] = {\n  Array.fill(size, size)(0).zipWithIndex.map { case (row, i) =&gt;\n    row.zipWithIndex.map { case (_, j) =&gt;\n      (i + 1) * (j + 1)\n    }\n  }\n}\n\n</code></pre>\n\n<h3>Трёхмерные массивы</h3>\n\n<pre><code class=\"language-scala\">// Куб 2x3x4\nval cube = Array.ofDim[Int](2, 3, 4)\n\ncube(0)(1)(2) = 42\nval value = cube(0)(1)(2)  // 42\n\n// Размеры\nval depth = cube.length              // 2\nval height = cube(0).length          // 3\nval width = cube(0)(0).length        // 4\n</code></pre>\n\n<h2> </h2>",
    "video" : null,
    "options" : {
      
    },
    "subtitle_files" : [
    ],
    "is_deprecated" : false
  },
  "name" : "text",
  "course_id" : 269026,
  "course_name" : " Система типов Scala 3",
  "exported_at" : "2026-01-10T10:36:18.718305"
}