# Материал (Шаг 5)

## Информация о шаге

- **ID шага**: 9167902
- **Позиция**: 5
- **Тип**: text
- **Курс**:  Система типов Scala 3
- **Экспортирован**: 2026-01-10T10:36:18.7594746

## Содержание

# Операции Range

## Коллекционные операции

val r = 1 to 10

// Базовые свойства
println(r.length) // 10
println(r.size) // 10
println(r.isEmpty) // false
println(r.nonEmpty) // true
println(r.head) // 1
println(r.last) // 10
println(r.tail) // Range(2, 3, 4, ..., 10)
println(r.init) // Range(1, 2, 3, ..., 9)

## Операции доступа к элементам

### Индексация и извлечение

val r = 10 to 100 by 10

// Доступ по индексу
println(r(0)) // 10
println(r(5)) // 60
println(r.apply(3)) // 40

// Безопасный доступ
println(r.lift(0)) // Some(10)
println(r.lift(100)) // None

// Извлечение подмножеств
println(r.take(3)) // Range(10, 20, 30)
println(r.drop(3)) // Range(40, 50, ..., 100)
println(r.slice(2, 5)) // Range(30, 40, 50)
println(r.takeRight(2)) // Range(90, 100)
println(r.dropRight(2)) // Range(10, 20, ..., 80)

### Проверка содержимого

val r = 1 to 20

println(r.contains(10)) // true
println(r.contains(25)) // false
println(r.indexOf(15)) // 14
println(r.lastIndexOf(5)) // 4
println(r.indexWhere(_ > 15)) // 15

## Операции преобразования

### Map и фильтрация

val r = 1 to 10

// Map (возвращает не Range, а IndexedSeq)
val doubled = r.map(_ * 2)
println(doubled) // Vector(2, 4, 6, ..., 20)

// Filter
val evens = r.filter(_ % 2 == 0)
println(evens) // Vector(2, 4, 6, 8, 10)

// Collect
val squares = r.collect { case x if x % 2 == 0 => x * x }
println(squares) // Vector(4, 16, 36, 64, 100)

### FlatMap и группировка

val r = 1 to 5

// FlatMap
val expanded = r.flatMap(x => List(x, x * 10))
println(expanded) // Vector(1, 10, 2, 20, 3, 30, 4, 40, 5, 50)

// Grouping
val grouped = r.grouped(2).toList
println(grouped) // List(Range(1, 2), Range(3, 4), Range(5))

// Sliding window
val windows = r.sliding(3).toList
println(windows) // List(Range(1, 2, 3), Range(2, 3, 4), Range(3, 4, 5))

## Операции свёртки (Fold/Reduce)

val r = 1 to 10

// Sum и product
println(r.sum) // 55
println(r.product) // 3628800

// Fold операции
val sumFold = r.fold(0)(_ + _)
println(sumFold) // 55

val sumLeft = r.foldLeft(0)(_ + _)
println(sumLeft) // 55

val sumRight = r.foldRight(0)(_ + _)
println(sumRight) // 55

// Reduce
val max = r.reduce((a, b) => if (a > b) a else b)
println(max) // 10

val min = r.reduceLeft((a, b) => if (a < b) a else b)
println(min) // 1

## Операции агрегации

val r = 1 to 20

// Min/Max
println(r.min) // 1
println(r.max) // 20
println(r.minOption) // Some(1)
println(r.maxOption) // Some(20)

// Поиск с условием
println(r.minBy(_ % 7)) // 7
println(r.maxBy(x => -x)) // 1

// Count
println(r.count(_ % 2 == 0)) // 10
println(r.count(_ > 15)) // 5

## Операции проверки

val r = 1 to 10

// Проверка предикатов
println(r.forall(_ > 0)) // true
println(r.forall(_ < 5)) // false
println(r.exists(_ > 8)) // true
println(r.exists(_ > 20)) // false

// Поиск элементов
println(r.find(_ > 5)) // Some(6)
println(r.find(_ > 100)) // None
println(r.findLast(_ < 5)) // Some(4)

## Комбинаторные операции

val r1 = 1 to 5
val r2 = 10 to 15

// Объединение
val concatenated = r1 ++ r2
println(concatenated) // Vector(1, 2, 3, 4, 5, 10, 11, 12, 13, 14, 15)

// Zip
val zipped = r1 zip r2
println(zipped) // Vector((1,10), (2,11), (3,12), (4,13), (5,14))

// ZipWithIndex
val indexed = r1.zipWithIndex
println(indexed) // Vector((1,0), (2,1), (3,2), (4,3), (5,4))

// Partition
val (small, large) = r1.partition(_ < 3)
println(small) // Vector(1, 2)
println(large) // Vector(3, 4, 5)

## Специфичные операции Range

### Reverse

val r = 1 to 10

println(r.reverse) // Range(10, 9, 8, ..., 1)
println(r.reverse.step) // -1 (шаг изменился)

### Проверка границ

val r = 5 to 50 by 5

println(r.isInclusive) // true (для 'to')

val r2 = 5 until 50 by 5
println(r2.isInclusive) // false (для 'until')

### Длина и размер

val r = 1 to 1000000

// Range эффективен по памяти - хранит только start, end, step
println(r.length) // 1000000
println(r.size) // 1000000

// Но можно создать материализованную версию
val vector = r.toVector
println(vector.size) // 1000000 (но в памяти!)

## Операции сортировки

val r = 10 to 1 by -1

println(r.sorted) // Vector(1, 2, 3, ..., 10)
println(r.sortWith(_ > _)) // Vector(10, 9, 8, ..., 1)
println(r.sortBy(-_)) // Vector(10, 9, 8, ..., 1)

## Операции с предикатами

val r = 1 to 20

// TakeWhile / DropWhile
println(r.takeWhile(_ < 10)) // Range(1, 2, 3, ..., 9)
println(r.dropWhile(_ < 10)) // Range(10, 11, 12, ..., 20)

// Span (комбинация takeWhile и dropWhile)
val (before, after) = r.span(_ < 10)
println(before) // Range(1, 2, ..., 9)
println(after) // Range(10, 11, ..., 20)

## Преобразования в другие коллекции

val r = 1 to 10

println(r.toList) // List(1, 2, 3, ..., 10)
println(r.toVector) // Vector(1, 2, 3, ..., 10)
println(r.toSet) // Set(1, 2, 3, ..., 10)
println(r.toArray) // Array(1, 2, 3, ..., 10)
println(r.toSeq) // Seq(1, 2, 3, ..., 10)
println(r.toIndexedSeq) // IndexedSeq(1, 2, 3, ..., 10)

## Строковые операции

val r = 1 to 5

println(r.mkString) // "12345"
println(r.mkString(", ")) // "1, 2, 3, 4, 5"
println(r.mkString("[", ", ", "]")) // "[1, 2, 3, 4, 5]"

## Полный список основных операций

### Создание Range

- `Range(start, end, step)`

- `start to end`

- `start until end`

- `start to end by step`

### Product операции

- `productArity` — количество компонентов

- `productElement(n)` — доступ к компоненту

- `start`, `end`, `step` — прямой доступ к полям

### Доступ к элементам

- `apply(index)`, `(index)`

- `head`, `last`, `tail`, `init`

- `take(n)`, `drop(n)`, `slice(from, to)`

- `takeRight(n)`, `dropRight(n)`

- `lift(index)`

### Проверки

- `contains(elem)`, `indexOf(elem)`, `lastIndexOf(elem)`

- `isEmpty`, `nonEmpty`, `length`, `size`

- `forall(pred)`, `exists(pred)`

- `find(pred)`, `findLast(pred)`

- `indexWhere(pred)`, `lastIndexWhere(pred)`

### Трансформации

- `map(f)`, `flatMap(f)`, `collect(pf)`

- `filter(pred)`, `filterNot(pred)`

- `withFilter(pred)`

### Агрегация

- `sum`, `product`, `min`, `max`

- `minOption`, `maxOption`

- `minBy(f)`, `maxBy(f)`

- `count(pred)`

### Свёртки

- `fold(z)(op)`, `foldLeft(z)(op)`, `foldRight(z)(op)`

- `reduce(op)`, `reduceLeft(op)`, `reduceRight(op)`

- `scan(z)(op)`, `scanLeft(z)(op)`, `scanRight(z)(op)`

### Группировка и разбиение

- `grouped(size)`

- `sliding(size)`, `sliding(size, step)`

- `partition(pred)`, `span(pred)`

- `splitAt(n)`

### Комбинирование

- `++(other)`, `concat(other)`

- `zip(other)`, `zipWithIndex`

- `zipAll(other, thisElem, thatElem)`

### Сортировка

- `sorted`, `sortWith(lt)`, `sortBy(f)`

- `reverse`

### Условная выборка

- `takeWhile(pred)`, `dropWhile(pred)`

- `span(pred)`

### Конверсии

- `toList`, `toVector`, `toArray`, `toSet`

- `toSeq`, `toIndexedSeq`

- `mkString`, `mkString(sep)`, `mkString(start, sep, end)`

### Специфичные для Range

- `isInclusive`

- `numRangeElements`

##  

---

### Полные данные JSON

<details>
<summary>Показать JSON данные</summary>

```json
{
  "name" : "text",
  "text" : "<h1 style=\"text-align:center;\">Операции Range</h1>\n\n<h2 style=\"text-align:center;\">Коллекционные операции</h2>\n\n<pre><code class=\"language-scala\">val r = 1 to 10\n\n// Базовые свойства\nprintln(r.length)       // 10\nprintln(r.size)         // 10\nprintln(r.isEmpty)      // false\nprintln(r.nonEmpty)     // true\nprintln(r.head)         // 1\nprintln(r.last)         // 10\nprintln(r.tail)         // Range(2, 3, 4, ..., 10)\nprintln(r.init)         // Range(1, 2, 3, ..., 9)\n</code></pre>\n\n<h2 style=\"text-align:center;\">Операции доступа к элементам</h2>\n\n<h3>Индексация и извлечение</h3>\n\n<pre><code class=\"language-scala\">val r = 10 to 100 by 10\n\n// Доступ по индексу\nprintln(r(0))           // 10\nprintln(r(5))           // 60\nprintln(r.apply(3))     // 40\n\n// Безопасный доступ\nprintln(r.lift(0))      // Some(10)\nprintln(r.lift(100))    // None\n\n// Извлечение подмножеств\nprintln(r.take(3))      // Range(10, 20, 30)\nprintln(r.drop(3))      // Range(40, 50, ..., 100)\nprintln(r.slice(2, 5))  // Range(30, 40, 50)\nprintln(r.takeRight(2)) // Range(90, 100)\nprintln(r.dropRight(2)) // Range(10, 20, ..., 80)\n</code></pre>\n\n<h3>Проверка содержимого</h3>\n\n<pre><code class=\"language-scala\">val r = 1 to 20\n\nprintln(r.contains(10))         // true\nprintln(r.contains(25))         // false\nprintln(r.indexOf(15))          // 14\nprintln(r.lastIndexOf(5))       // 4\nprintln(r.indexWhere(_ &gt; 15))   // 15\n</code></pre>\n\n<h2 style=\"text-align:center;\">Операции преобразования</h2>\n\n<h3>Map и фильтрация</h3>\n\n<pre><code class=\"language-scala\">val r = 1 to 10\n\n// Map (возвращает не Range, а IndexedSeq)\nval doubled = r.map(_ * 2)\nprintln(doubled)  // Vector(2, 4, 6, ..., 20)\n\n// Filter\nval evens = r.filter(_ % 2 == 0)\nprintln(evens)    // Vector(2, 4, 6, 8, 10)\n\n// Collect\nval squares = r.collect { case x if x % 2 == 0 =&gt; x * x }\nprintln(squares)  // Vector(4, 16, 36, 64, 100)\n</code></pre>\n\n<h3>FlatMap и группировка</h3>\n\n<pre><code class=\"language-scala\">val r = 1 to 5\n\n// FlatMap\nval expanded = r.flatMap(x =&gt; List(x, x * 10))\nprintln(expanded)  // Vector(1, 10, 2, 20, 3, 30, 4, 40, 5, 50)\n\n// Grouping\nval grouped = r.grouped(2).toList\nprintln(grouped)   // List(Range(1, 2), Range(3, 4), Range(5))\n\n// Sliding window\nval windows = r.sliding(3).toList\nprintln(windows)   // List(Range(1, 2, 3), Range(2, 3, 4), Range(3, 4, 5))\n</code></pre>\n\n<h2 style=\"text-align:center;\">Операции свёртки (Fold/Reduce)</h2>\n\n<pre><code class=\"language-scala\">val r = 1 to 10\n\n// Sum и product\nprintln(r.sum)          // 55\nprintln(r.product)      // 3628800\n\n// Fold операции\nval sumFold = r.fold(0)(_ + _)\nprintln(sumFold)        // 55\n\nval sumLeft = r.foldLeft(0)(_ + _)\nprintln(sumLeft)        // 55\n\nval sumRight = r.foldRight(0)(_ + _)\nprintln(sumRight)       // 55\n\n// Reduce\nval max = r.reduce((a, b) =&gt; if (a &gt; b) a else b)\nprintln(max)            // 10\n\nval min = r.reduceLeft((a, b) =&gt; if (a &lt; b) a else b)\nprintln(min)            // 1\n</code></pre>\n\n<h2 style=\"text-align:center;\">Операции агрегации</h2>\n\n<pre><code class=\"language-scala\">val r = 1 to 20\n\n// Min/Max\nprintln(r.min)          // 1\nprintln(r.max)          // 20\nprintln(r.minOption)    // Some(1)\nprintln(r.maxOption)    // Some(20)\n\n// Поиск с условием\nprintln(r.minBy(_ % 7))           // 7\nprintln(r.maxBy(x =&gt; -x))         // 1\n\n// Count\nprintln(r.count(_ % 2 == 0))      // 10\nprintln(r.count(_ &gt; 15))          // 5\n</code></pre>\n\n<h2 style=\"text-align:center;\">Операции проверки</h2>\n\n<pre><code class=\"language-scala\">val r = 1 to 10\n\n// Проверка предикатов\nprintln(r.forall(_ &gt; 0))          // true\nprintln(r.forall(_ &lt; 5))          // false\nprintln(r.exists(_ &gt; 8))          // true\nprintln(r.exists(_ &gt; 20))         // false\n\n// Поиск элементов\nprintln(r.find(_ &gt; 5))            // Some(6)\nprintln(r.find(_ &gt; 100))          // None\nprintln(r.findLast(_ &lt; 5))        // Some(4)\n</code></pre>\n\n<h2 style=\"text-align:center;\">Комбинаторные операции</h2>\n\n<pre><code class=\"language-scala\">val r1 = 1 to 5\nval r2 = 10 to 15\n\n// Объединение\nval concatenated = r1 ++ r2\nprintln(concatenated)  // Vector(1, 2, 3, 4, 5, 10, 11, 12, 13, 14, 15)\n\n// Zip\nval zipped = r1 zip r2\nprintln(zipped)        // Vector((1,10), (2,11), (3,12), (4,13), (5,14))\n\n// ZipWithIndex\nval indexed = r1.zipWithIndex\nprintln(indexed)       // Vector((1,0), (2,1), (3,2), (4,3), (5,4))\n\n// Partition\nval (small, large) = r1.partition(_ &lt; 3)\nprintln(small)         // Vector(1, 2)\nprintln(large)         // Vector(3, 4, 5)\n</code></pre>\n\n<h2 style=\"text-align:center;\">Специфичные операции Range</h2>\n\n<h3>Reverse</h3>\n\n<pre><code class=\"language-scala\">val r = 1 to 10\n\nprintln(r.reverse)     // Range(10, 9, 8, ..., 1)\nprintln(r.reverse.step) // -1 (шаг изменился)\n</code></pre>\n\n<h3>Проверка границ</h3>\n\n<pre><code class=\"language-scala\">val r = 5 to 50 by 5\n\nprintln(r.isInclusive)  // true (для 'to')\n\nval r2 = 5 until 50 by 5\nprintln(r2.isInclusive) // false (для 'until')\n</code></pre>\n\n<h3>Длина и размер</h3>\n\n<pre><code class=\"language-scala\">val r = 1 to 1000000\n\n// Range эффективен по памяти - хранит только start, end, step\nprintln(r.length)       // 1000000\nprintln(r.size)         // 1000000\n\n// Но можно создать материализованную версию\nval vector = r.toVector\nprintln(vector.size)    // 1000000 (но в памяти!)\n</code></pre>\n\n<h2 style=\"text-align:center;\">Операции сортировки</h2>\n\n<pre><code class=\"language-scala\">val r = 10 to 1 by -1\n\nprintln(r.sorted)           // Vector(1, 2, 3, ..., 10)\nprintln(r.sortWith(_ &gt; _))  // Vector(10, 9, 8, ..., 1)\nprintln(r.sortBy(-_))       // Vector(10, 9, 8, ..., 1)\n</code></pre>\n\n<h2 style=\"text-align:center;\">Операции с предикатами</h2>\n\n<pre><code class=\"language-scala\">val r = 1 to 20\n\n// TakeWhile / DropWhile\nprintln(r.takeWhile(_ &lt; 10))  // Range(1, 2, 3, ..., 9)\nprintln(r.dropWhile(_ &lt; 10))  // Range(10, 11, 12, ..., 20)\n\n// Span (комбинация takeWhile и dropWhile)\nval (before, after) = r.span(_ &lt; 10)\nprintln(before)  // Range(1, 2, ..., 9)\nprintln(after)   // Range(10, 11, ..., 20)\n</code></pre>\n\n<h2 style=\"text-align:center;\">Преобразования в другие коллекции</h2>\n\n<pre><code class=\"language-scala\">val r = 1 to 10\n\nprintln(r.toList)       // List(1, 2, 3, ..., 10)\nprintln(r.toVector)     // Vector(1, 2, 3, ..., 10)\nprintln(r.toSet)        // Set(1, 2, 3, ..., 10)\nprintln(r.toArray)      // Array(1, 2, 3, ..., 10)\nprintln(r.toSeq)        // Seq(1, 2, 3, ..., 10)\nprintln(r.toIndexedSeq) // IndexedSeq(1, 2, 3, ..., 10)\n</code></pre>\n\n<h2 style=\"text-align:center;\">Строковые операции</h2>\n\n<pre><code class=\"language-scala\">val r = 1 to 5\n\nprintln(r.mkString)           // \"12345\"\nprintln(r.mkString(\", \"))     // \"1, 2, 3, 4, 5\"\nprintln(r.mkString(\"[\", \", \", \"]\"))  // \"[1, 2, 3, 4, 5]\"\n</code></pre>\n\n<h2 style=\"text-align:center;\">Полный список основных операций</h2>\n\n<h3>Создание Range</h3>\n\n<ul>\n\t<li><code>Range(start, end, step)</code></li>\n\t<li><code>start to end</code></li>\n\t<li><code>start until end</code></li>\n\t<li><code>start to end by step</code></li>\n</ul>\n\n<h3>Product операции</h3>\n\n<ul>\n\t<li><code>productArity</code> — количество компонентов</li>\n\t<li><code>productElement(n)</code> — доступ к компоненту</li>\n\t<li><code>start</code>, <code>end</code>, <code>step</code> — прямой доступ к полям</li>\n</ul>\n\n<h3>Доступ к элементам</h3>\n\n<ul>\n\t<li><code>apply(index)</code>, <code>(index)</code></li>\n\t<li><code>head</code>, <code>last</code>, <code>tail</code>, <code>init</code></li>\n\t<li><code>take(n)</code>, <code>drop(n)</code>, <code>slice(from, to)</code></li>\n\t<li><code>takeRight(n)</code>, <code>dropRight(n)</code></li>\n\t<li><code>lift(index)</code></li>\n</ul>\n\n<h3>Проверки</h3>\n\n<ul>\n\t<li><code>contains(elem)</code>, <code>indexOf(elem)</code>, <code>lastIndexOf(elem)</code></li>\n\t<li><code>isEmpty</code>, <code>nonEmpty</code>, <code>length</code>, <code>size</code></li>\n\t<li><code>forall(pred)</code>, <code>exists(pred)</code></li>\n\t<li><code>find(pred)</code>, <code>findLast(pred)</code></li>\n\t<li><code>indexWhere(pred)</code>, <code>lastIndexWhere(pred)</code></li>\n</ul>\n\n<h3>Трансформации</h3>\n\n<ul>\n\t<li><code>map(f)</code>, <code>flatMap(f)</code>, <code>collect(pf)</code></li>\n\t<li><code>filter(pred)</code>, <code>filterNot(pred)</code></li>\n\t<li><code>withFilter(pred)</code></li>\n</ul>\n\n<h3>Агрегация</h3>\n\n<ul>\n\t<li><code>sum</code>, <code>product</code>, <code>min</code>, <code>max</code></li>\n\t<li><code>minOption</code>, <code>maxOption</code></li>\n\t<li><code>minBy(f)</code>, <code>maxBy(f)</code></li>\n\t<li><code>count(pred)</code></li>\n</ul>\n\n<h3>Свёртки</h3>\n\n<ul>\n\t<li><code>fold(z)(op)</code>, <code>foldLeft(z)(op)</code>, <code>foldRight(z)(op)</code></li>\n\t<li><code>reduce(op)</code>, <code>reduceLeft(op)</code>, <code>reduceRight(op)</code></li>\n\t<li><code>scan(z)(op)</code>, <code>scanLeft(z)(op)</code>, <code>scanRight(z)(op)</code></li>\n</ul>\n\n<h3>Группировка и разбиение</h3>\n\n<ul>\n\t<li><code>grouped(size)</code></li>\n\t<li><code>sliding(size)</code>, <code>sliding(size, step)</code></li>\n\t<li><code>partition(pred)</code>, <code>span(pred)</code></li>\n\t<li><code>splitAt(n)</code></li>\n</ul>\n\n<h3>Комбинирование</h3>\n\n<ul>\n\t<li><code>++(other)</code>, <code>concat(other)</code></li>\n\t<li><code>zip(other)</code>, <code>zipWithIndex</code></li>\n\t<li><code>zipAll(other, thisElem, thatElem)</code></li>\n</ul>\n\n<h3>Сортировка</h3>\n\n<ul>\n\t<li><code>sorted</code>, <code>sortWith(lt)</code>, <code>sortBy(f)</code></li>\n\t<li><code>reverse</code></li>\n</ul>\n\n<h3>Условная выборка</h3>\n\n<ul>\n\t<li><code>takeWhile(pred)</code>, <code>dropWhile(pred)</code></li>\n\t<li><code>span(pred)</code></li>\n</ul>\n\n<h3>Конверсии</h3>\n\n<ul>\n\t<li><code>toList</code>, <code>toVector</code>, <code>toArray</code>, <code>toSet</code></li>\n\t<li><code>toSeq</code>, <code>toIndexedSeq</code></li>\n\t<li><code>mkString</code>, <code>mkString(sep)</code>, <code>mkString(start, sep, end)</code></li>\n</ul>\n\n<h3>Специфичные для Range</h3>\n\n<ul>\n\t<li><code>isInclusive</code></li>\n\t<li><code>numRangeElements</code></li>\n</ul>\n\n<h2> </h2>\n\n<ol>\n</ol>",
  "video" : null,
  "options" : {
    
  },
  "subtitle_files" : [
  ],
  "is_deprecated" : false
}
```

</details>
