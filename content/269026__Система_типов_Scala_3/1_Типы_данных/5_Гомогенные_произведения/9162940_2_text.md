# Материал (Шаг 2)

## Информация о шаге

- **ID шага**: 9162940
- **Позиция**: 2
- **Тип**: text
- **Курс**:  Система типов Scala 3
- **Экспортирован**: 2026-01-10T10:36:18.7212806

## Содержание

# Тип Array (массив)

Array — представляет собой упорядоченную коллекцию элементов **фиксированной длины**. В отличие от списков и других изменяемых коллекций, размер массива определяется при создании и не может быть изменён впоследствии.

Термин **"массив"** происходит от французского слова **"massif"**, которое означает:

- Массивный, громоздкий

- Сплошной, монолитный

- Горный массив (большая группа гор)

В русский язык это слово пришло через научную и техническую литературу, где использовалось для обозначения **большой совокупности однородных элементов**, расположенных компактно и упорядоченно. Интересно, что в разных языках  используются похожие понятия, часто **Array.**

В математике термин "массив" использовался задолго до компьютеров для обозначения:

- **Матриц** (двумерных массивов чисел)

- **Векторов** (одномерных массивов)

- **Таблиц данных**

 

## Array - тип с параметром

Прежде чем углубиться в Array, важно понять концепцию типов с параметрами. *(полностью тема будет раскрыта в следующих уроках)*

Array является **параметризованным типом** (или generic type). Это означает, что при создании массива мы указываем, какой тип данных будет храниться в нём. Например:

val numbers: Array[Int] = Array(1, 2, 3, 4, 5)
val words: Array[String] = Array("hello", "world")
val flags: Array[Boolean] = Array(true, false, true)

Запись `Array[Int]` читается как "массив целых чисел", где `Int` — это **параметр типа**. Можно провести аналогию с контейнером: Array — это коробка, а параметр типа указывает, что именно в ней хранится.

Компилятор Scala использует эту информацию для проверки типов во время компиляции, предотвращая ошибки:

val numbers: Array[Int] = Array(1, 2, 3)
// numbers(0) = "text" // Ошибка компиляции!

## Создание массивов

### Основные способы создания

// Способ 1: явное указание элементов
val fruits = Array("apple", "banana", "orange")

// Способ 2: создание массива фиксированного размера
val zeros = new Array[Int](5) // Array(0, 0, 0, 0, 0)

// Способ 3: с явным указанием типа
val temperatures: Array[Double] = Array(23.5, 18.2, 25.0)

### Важная особенность: фиксированная длина

val numbers = new Array[Int](3) // Массив из 3 элементов
numbers(0) = 10
numbers(1) = 20
numbers(2) = 30

// numbers(3) = 40 // Ошибка выполнения: IndexOutOfBoundsException

После создания массива его длина не может быть изменена. Нельзя добавить новый элемент или удалить существующий, изменив размер массива.

Хорошо, объясню сопоставление с образцом (pattern matching) для массивов в Scala 3 по-русски.

## Рattern matching (декомпозиция) массивов

Можно использовать pattern matching для массивов:

def matchArray(arr: Array[Int]): String = arr match
case Array() => "Пустой массив"
case Array(x) => s"Один элемент: $x"
case Array(x, y) => s"Два элемента: $x и $y"
case Array(1, y, z) => s"Три элемента: 1, $y, $z"
case Array(x, y, z) => s"Три элемента: $x, $y, $z"
case _ => s"Массив из ${arr.length} элементов"

### Сопоставление головы и хвоста

Используйте оператор `*` для сопоставления оставшихся элементов:

def processArray(arr: Array[Int]): String = arr match
case Array() => "Пустой"
case Array(first, rest*) => s"Первый: $first, Остаток: ${rest.length} элементов"

## Фиксированная длина: преимущества и ограничения

### Преимущества

**Производительность**: благодаря фиксированному размеру, Array обеспечивает:

- Быстрый доступ к элементам по индексу O(1)

- Эффективное использование памяти

- Предсказуемое расположение данных в памяти

**Безопасность**: размер известен заранее, что помогает избежать ошибок переполнения.

### Когда использовать Array

// Хорошо: известное количество данных
val daysInWeek = Array("Пн", "Вт", "Ср", "Чт", "Пт", "Сб", "Вс")
val monthDays = new Array[Int](31)

// Плохо: динамически растущий набор данных
// Для этого лучше использовать List, ArrayBuffer или Vector

### Сравнение с изменяемыми коллекциями

import scala.collection.mutable.ArrayBuffer

// Array: фиксированный размер
val fixedArray = Array(1, 2, 3)
// fixedArray += 4 // Ошибка!

// ArrayBuffer: переменный размер
val dynamicBuffer = ArrayBuffer(1, 2, 3)
dynamicBuffer += 4 // OK: ArrayBuffer(1, 2, 3, 4)

## Array - изменяемый массив

Array обладает **частичной изменяемостью, **можно изменять **содержание элементов** массива, но нельзя изменить **размерность массива**.

val temperatures = Array(20.5, 22.0, 19.8, 23.1)

// Синтаксис arr(index) = value на самом деле вызывает метод update
temperatures(0) = 21.0
temperatures.update(1, 22.5) // Альтернативный синтаксис

println(temperatures.mkString(", ")) // 21.0, 22.5, 19.8, 23.1

В функциональном подходе принято пользоваться неизменяемыми структурами данных. Однако, это приводит к необходимости создавать новые структуры при малейшем изменении старой структуры, что очень затратно при использовании больших массивов данных с произвольным доступом к элементам.

Существование типа Array - это сознательное уступка императивному подходу, с целью повышения производительности  математических операций в массивах . В частности, это матричные вычисления, которые очень популярны в программировании. 

## Многомерные массивы

Scala поддерживает создание многомерных массивов — массивов, элементами которых являются другие массивы.

### Двумерные массивы (матрицы)

// Создание двумерного массива 3x3
val matrix = Array.ofDim[Int](3, 3)

// Заполнение значениями
matrix(0)(0) = 1
matrix(0)(1) = 2
matrix(0)(2) = 3
matrix(1)(0) = 4
matrix(1)(1) = 5
matrix(1)(2) = 6
matrix(2)(0) = 7
matrix(2)(1) = 8
matrix(2)(2) = 9

// Чтение
val element = matrix(1)(2) // 6

### Инициализация двумерного массива

// Способ 1: явное создание
val table = Array(
Array(1, 2, 3),
Array(4, 5, 6),
Array(7, 8, 9)
)

// Способ 2: с помощью ofDim
val grid = Array.ofDim[Double](2, 4)
// 2 строки, 4 столбца, заполнено 0.0

### Работа с многомерными массивами

val matrix = Array(
Array(1, 2, 3),
Array(4, 5, 6),
Array(7, 8, 9)
)

// Обход всех элементов
// flatMap "разворачивает" вложенную структуру
matrix.flatMap(identity).foreach(println)

// Удвоить все элементы
val doubled = matrix.map(row => row.map(_ * 2))

// Сумма всех элементов
val total = matrix.flatMap(identity).sum // 45

// Произведение всех элементов
val product = matrix.flatMap(identity).product // 362880

// Функциональное транспонирование
val transposed = matrix.transpose
// Array(
// Array(1, 4, 7),
// Array(2, 5, 8),
// Array(3, 6, 9)
// )

// Создание таблицы умножения, вариант 1
def multiplicationTable(size: Int): Array[Array[Int]] = {
Array.tabulate(size, size)((i, j) => (i + 1) * (j + 1))
}

// Создание таблицы умножения, вариант 2
def multiplicationTable(size: Int): Array[Array[Int]] = {
Array.fill(size, size)(0).zipWithIndex.map { case (row, i) =>
row.zipWithIndex.map { case (_, j) =>
(i + 1) * (j + 1)
}
}
}

### Трёхмерные массивы

// Куб 2x3x4
val cube = Array.ofDim[Int](2, 3, 4)

cube(0)(1)(2) = 42
val value = cube(0)(1)(2) // 42

// Размеры
val depth = cube.length // 2
val height = cube(0).length // 3
val width = cube(0)(0).length // 4

##  

---

### Полные данные JSON

<details>
<summary>Показать JSON данные</summary>

```json
{
  "name" : "text",
  "text" : "<h1 style=\"text-align:center;\">Тип Array (массив)</h1>\n\n<p>Array — представляет собой упорядоченную коллекцию элементов <strong>фиксированной длины</strong>. В отличие от списков и других изменяемых коллекций, размер массива определяется при создании и не может быть изменён впоследствии.</p>\n\n<p>Термин <strong>\"массив\"</strong> происходит от французского слова <strong>\"massif\"</strong>, которое означает:</p>\n\n<ul>\n\t<li>Массивный, громоздкий</li>\n\t<li>Сплошной, монолитный</li>\n\t<li>Горный массив (большая группа гор)</li>\n</ul>\n\n<p>В русский язык это слово пришло через научную и техническую литературу, где использовалось для обозначения <strong>большой совокупности однородных элементов</strong>, расположенных компактно и упорядоченно. Интересно, что в разных языках  используются похожие понятия, часто <strong>Array.</strong></p>\n\n<p>В математике термин \"массив\" использовался задолго до компьютеров для обозначения:</p>\n\n<ul>\n\t<li><strong>Матриц</strong> (двумерных массивов чисел)</li>\n\t<li><strong>Векторов</strong> (одномерных массивов)</li>\n\t<li><strong>Таблиц данных</strong></li>\n</ul>\n\n<p> </p>\n\n<h2 style=\"text-align:center;\">Array - тип с параметром</h2>\n\n<p>Прежде чем углубиться в Array, важно понять концепцию типов с параметрами. <em>(полностью тема будет раскрыта в следующих уроках)</em></p>\n\n<p>Array является <strong>параметризованным типом</strong> (или generic type). Это означает, что при создании массива мы указываем, какой тип данных будет храниться в нём. Например:</p>\n\n<pre><code class=\"language-scala\">val numbers: Array[Int] = Array(1, 2, 3, 4, 5)\nval words: Array[String] = Array(\"hello\", \"world\")\nval flags: Array[Boolean] = Array(true, false, true)</code></pre>\n\n<p>Запись <code>Array[Int]</code> читается как \"массив целых чисел\", где <code>Int</code> — это <strong>параметр типа</strong>. Можно провести аналогию с контейнером: Array — это коробка, а параметр типа указывает, что именно в ней хранится.</p>\n\n<p>Компилятор Scala использует эту информацию для проверки типов во время компиляции, предотвращая ошибки:</p>\n\n<pre><code class=\"language-scala\">val numbers: Array[Int] = Array(1, 2, 3)\n// numbers(0) = \"text\" // Ошибка компиляции!</code></pre>\n\n<h2 style=\"text-align:center;\">Создание массивов</h2>\n\n<h3>Основные способы создания</h3>\n\n<pre><code class=\"language-scala\">// Способ 1: явное указание элементов\nval fruits = Array(\"apple\", \"banana\", \"orange\")\n\n// Способ 2: создание массива фиксированного размера\nval zeros = new Array[Int](5) // Array(0, 0, 0, 0, 0)\n\n// Способ 3: с явным указанием типа\nval temperatures: Array[Double] = Array(23.5, 18.2, 25.0)\n</code></pre>\n\n<h3>Важная особенность: фиксированная длина</h3>\n\n<pre><code class=\"language-scala\">val numbers = new Array[Int](3) // Массив из 3 элементов\nnumbers(0) = 10\nnumbers(1) = 20\nnumbers(2) = 30\n\n// numbers(3) = 40 // Ошибка выполнения: IndexOutOfBoundsException\n</code></pre>\n\n<p>После создания массива его длина не может быть изменена. Нельзя добавить новый элемент или удалить существующий, изменив размер массива.</p>\n\n<p>Хорошо, объясню сопоставление с образцом (pattern matching) для массивов в Scala 3 по-русски.</p>\n\n<h2 style=\"text-align:center;\">Рattern matching (декомпозиция) массивов</h2>\n\n<p>Можно использовать pattern matching для массивов:</p>\n\n<pre><code class=\"language-scala\">def matchArray(arr: Array[Int]): String = arr match\n  case Array() =&gt; \"Пустой массив\"\n  case Array(x) =&gt; s\"Один элемент: $x\"\n  case Array(x, y) =&gt; s\"Два элемента: $x и $y\"\n  case Array(1, y, z) =&gt; s\"Три элемента: 1, $y, $z\"\n  case Array(x, y, z) =&gt; s\"Три элемента: $x, $y, $z\"\n  case _ =&gt; s\"Массив из ${arr.length} элементов\"\n</code></pre>\n\n<h3>Сопоставление головы и хвоста</h3>\n\n<p>Используйте оператор <code>*</code> для сопоставления оставшихся элементов:</p>\n\n<pre><code class=\"language-scala\">def processArray(arr: Array[Int]): String = arr match\n  case Array() =&gt; \"Пустой\"\n  case Array(first, rest*) =&gt; s\"Первый: $first, Остаток: ${rest.length} элементов\"\n</code></pre>\n\n<h2 style=\"text-align:center;\">Фиксированная длина: преимущества и ограничения</h2>\n\n<h3>Преимущества</h3>\n\n<p><strong>Производительность</strong>: благодаря фиксированному размеру, Array обеспечивает:</p>\n\n<ul>\n\t<li>Быстрый доступ к элементам по индексу O(1)</li>\n\t<li>Эффективное использование памяти</li>\n\t<li>Предсказуемое расположение данных в памяти</li>\n</ul>\n\n<p><strong>Безопасность</strong>: размер известен заранее, что помогает избежать ошибок переполнения.</p>\n\n<h3>Когда использовать Array</h3>\n\n<pre><code class=\"language-scala\">// Хорошо: известное количество данных\nval daysInWeek = Array(\"Пн\", \"Вт\", \"Ср\", \"Чт\", \"Пт\", \"Сб\", \"Вс\")\nval monthDays = new Array[Int](31)\n\n// Плохо: динамически растущий набор данных\n// Для этого лучше использовать List, ArrayBuffer или Vector\n</code></pre>\n\n<h3>Сравнение с изменяемыми коллекциями</h3>\n\n<pre><code class=\"language-scala\">import scala.collection.mutable.ArrayBuffer\n\n// Array: фиксированный размер\nval fixedArray = Array(1, 2, 3)\n// fixedArray += 4 // Ошибка!\n\n// ArrayBuffer: переменный размер\nval dynamicBuffer = ArrayBuffer(1, 2, 3)\ndynamicBuffer += 4 // OK: ArrayBuffer(1, 2, 3, 4)\n</code></pre>\n\n<h2 style=\"text-align:center;\">Array - изменяемый массив</h2>\n\n<p>Array обладает <strong>частичной изменяемостью, </strong>можно изменять <strong>содержание элементов</strong> массива, но нельзя изменить <strong>размерность массива</strong>.</p>\n\n<pre><code class=\"language-scala\">val temperatures = Array(20.5, 22.0, 19.8, 23.1)\n\n// Синтаксис arr(index) = value на самом деле вызывает метод update\ntemperatures(0) = 21.0\ntemperatures.update(1, 22.5)  // Альтернативный синтаксис\n\nprintln(temperatures.mkString(\", \"))  // 21.0, 22.5, 19.8, 23.1</code></pre>\n\n<p>В функциональном подходе принято пользоваться неизменяемыми структурами данных. Однако, это приводит к необходимости создавать новые структуры при малейшем изменении старой структуры, что очень затратно при использовании больших массивов данных с произвольным доступом к элементам.</p>\n\n<p>Существование типа Array - это сознательное уступка императивному подходу, с целью повышения производительности  математических операций в массивах . В частности, это матричные вычисления, которые очень популярны в программировании. </p>\n\n<h2 style=\"text-align:center;\">Многомерные массивы</h2>\n\n<p>Scala поддерживает создание многомерных массивов — массивов, элементами которых являются другие массивы.</p>\n\n<h3>Двумерные массивы (матрицы)</h3>\n\n<pre><code class=\"language-scala\">// Создание двумерного массива 3x3\nval matrix = Array.ofDim[Int](3, 3)\n\n// Заполнение значениями\nmatrix(0)(0) = 1\nmatrix(0)(1) = 2\nmatrix(0)(2) = 3\nmatrix(1)(0) = 4\nmatrix(1)(1) = 5\nmatrix(1)(2) = 6\nmatrix(2)(0) = 7\nmatrix(2)(1) = 8\nmatrix(2)(2) = 9\n\n// Чтение\nval element = matrix(1)(2)  // 6\n</code></pre>\n\n<h3>Инициализация двумерного массива</h3>\n\n<pre><code class=\"language-scala\">// Способ 1: явное создание\nval table = Array(\n  Array(1, 2, 3),\n  Array(4, 5, 6),\n  Array(7, 8, 9)\n)\n\n// Способ 2: с помощью ofDim\nval grid = Array.ofDim[Double](2, 4)\n// 2 строки, 4 столбца, заполнено 0.0\n</code></pre>\n\n<h3>Работа с многомерными массивами</h3>\n\n<pre><code class=\"language-scala\">val matrix = Array(\n  Array(1, 2, 3),\n  Array(4, 5, 6),\n  Array(7, 8, 9)\n)\n\n// Обход всех элементов\n// flatMap \"разворачивает\" вложенную структуру\nmatrix.flatMap(identity).foreach(println)\n\n// Удвоить все элементы\nval doubled = matrix.map(row =&gt; row.map(_ * 2))\n\n// Сумма всех элементов\nval total = matrix.flatMap(identity).sum  // 45\n\n// Произведение всех элементов\nval product = matrix.flatMap(identity).product  // 362880\n\n// Функциональное транспонирование\nval transposed = matrix.transpose\n// Array(\n//   Array(1, 4, 7),\n//   Array(2, 5, 8),\n//   Array(3, 6, 9)\n// )\n\n// Создание таблицы умножения, вариант 1\ndef multiplicationTable(size: Int): Array[Array[Int]] = {\n  Array.tabulate(size, size)((i, j) =&gt; (i + 1) * (j + 1))\n}\n\n// Создание таблицы умножения, вариант 2\ndef multiplicationTable(size: Int): Array[Array[Int]] = {\n  Array.fill(size, size)(0).zipWithIndex.map { case (row, i) =&gt;\n    row.zipWithIndex.map { case (_, j) =&gt;\n      (i + 1) * (j + 1)\n    }\n  }\n}\n\n</code></pre>\n\n<h3>Трёхмерные массивы</h3>\n\n<pre><code class=\"language-scala\">// Куб 2x3x4\nval cube = Array.ofDim[Int](2, 3, 4)\n\ncube(0)(1)(2) = 42\nval value = cube(0)(1)(2)  // 42\n\n// Размеры\nval depth = cube.length              // 2\nval height = cube(0).length          // 3\nval width = cube(0)(0).length        // 4\n</code></pre>\n\n<h2> </h2>",
  "video" : null,
  "options" : {
    
  },
  "subtitle_files" : [
  ],
  "is_deprecated" : false
}
```

</details>
