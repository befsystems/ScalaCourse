# Материал (Шаг 3)

## Информация о шаге

- **ID шага**: 8971034
- **Позиция**: 3
- **Тип**: text
- **Курс**:  Система типов Scala 3
- **Экспортирован**: 2026-01-10T10:36:28.6639517

## Содержание

# Общие принципы реализации Product Types

### 1. Закрытость (Finiteness)

- Число компонентов фиксировано на этапе компиляции

- Невозможно добавить или удалить поля в runtime

### 2. Гетерогенность (Heterogeneity)

- Компоненты могут быть разных типов

- Тип каждого компонента сохраняется и проверяется компилятором

val data: (Int, String, Boolean) = (42, "hello", true)
// Каждый компонент имеет свой тип

### 3. Упорядоченность (Ordering)

- Позиция компонента имеет значение

- `(Int, String) ≠ (String, Int)` как типы

val p1: (Int, String) = (1, "a")
val p2: (String, Int) = ("a", 1)
// p1 = p2 // Ошибка компиляции: несовместимые типы

### 4. Структурность vs Номинальность

**Кортежи — структурные:** два кортежа эквивалентны, если совпадают типы их компонентов

val t1: (Int, String) = (1, "hello")
val t2: (Int, String) = (1, "hello")
// t1 и t2 — один и тот же тип

**Case classes — номинальные:** тип определяется именем класса

case class PersonA(age: Int, name: String)
case class PersonB(age: Int, name: String)

val a = PersonA(30, "Alice")
val b = PersonB(30, "Alice")
// a и b — РАЗНЫЕ типы, несмотря на одинаковую структуру
// val x: PersonA = b // Ошибка компиляции

### 5. Декомпозиция

- Компоненты можно извлекать

- Поддержка pattern matching

val person: (String, Int) = ("Alice", 30)

// Извлечение по индексу (кортежи)
val name = person._1
val age = person._2

// Pattern matching
person match {
case (n, a) => println(s"$n is $a years old")
}

### 6. Неизменяемость (Immutability)

Все стандартные product types в Scala неизменяемы. Это требование функционального похода. Дает безопасность в многопоточной среде, предсказуемое поведение данных в сложных системах.

---

### Полные данные JSON

<details>
<summary>Показать JSON данные</summary>

```json
{
  "name" : "text",
  "text" : "<h1 style=\"text-align:center;\">Общие принципы реализации Product Types</h1>\n\n<h3>1. Закрытость (Finiteness)</h3>\n\n<ul>\n\t<li>Число компонентов фиксировано на этапе компиляции</li>\n\t<li>Невозможно добавить или удалить поля в runtime</li>\n</ul>\n\n<h3>2. Гетерогенность (Heterogeneity)</h3>\n\n<ul>\n\t<li>Компоненты могут быть разных типов</li>\n\t<li>Тип каждого компонента сохраняется и проверяется компилятором</li>\n</ul>\n\n<pre><code class=\"language-scala\">val data: (Int, String, Boolean) = (42, \"hello\", true)\n// Каждый компонент имеет свой тип\n</code></pre>\n\n<h3>3. Упорядоченность (Ordering)</h3>\n\n<ul>\n\t<li>Позиция компонента имеет значение</li>\n\t<li><code>(Int, String) ≠ (String, Int)</code> как типы</li>\n</ul>\n\n<pre><code class=\"language-scala\">val p1: (Int, String) = (1, \"a\")\nval p2: (String, Int) = (\"a\", 1)\n// p1 = p2 // Ошибка компиляции: несовместимые типы\n</code></pre>\n\n<h3>4. Структурность vs Номинальность</h3>\n\n<p><strong>Кортежи — структурные:</strong> два кортежа эквивалентны, если совпадают типы их компонентов</p>\n\n<pre><code class=\"language-scala\">val t1: (Int, String) = (1, \"hello\")\nval t2: (Int, String) = (1, \"hello\")\n// t1 и t2 — один и тот же тип\n</code></pre>\n\n<p><strong>Case classes — номинальные:</strong> тип определяется именем класса</p>\n\n<pre><code class=\"language-scala\">case class PersonA(age: Int, name: String)\ncase class PersonB(age: Int, name: String)\n\nval a = PersonA(30, \"Alice\")\nval b = PersonB(30, \"Alice\")\n// a и b — РАЗНЫЕ типы, несмотря на одинаковую структуру\n// val x: PersonA = b // Ошибка компиляции\n</code></pre>\n\n<h3>5. Декомпозиция</h3>\n\n<ul>\n\t<li>Компоненты можно извлекать</li>\n\t<li>Поддержка pattern matching</li>\n</ul>\n\n<pre><code class=\"language-scala\">val person: (String, Int) = (\"Alice\", 30)\n\n// Извлечение по индексу (кортежи)\nval name = person._1\nval age = person._2\n\n// Pattern matching\nperson match {\n  case (n, a) =&gt; println(s\"$n is $a years old\")\n}\n</code></pre>\n\n<h3>6. Неизменяемость (Immutability)</h3>\n\n<p>Все стандартные product types в Scala неизменяемы. Это требование функционального похода. Дает безопасность в многопоточной среде, предсказуемое поведение данных в сложных системах.</p>",
  "video" : null,
  "options" : {
    
  },
  "subtitle_files" : [
  ],
  "is_deprecated" : false
}
```

</details>
