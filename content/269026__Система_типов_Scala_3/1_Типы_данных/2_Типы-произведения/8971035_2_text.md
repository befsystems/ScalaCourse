# Материал (Шаг 2)

## Информация о шаге

- **ID шага**: 8971035
- **Позиция**: 2
- **Тип**: text
- **Курс**:  Система типов Scala 3
- **Экспортирован**: 2026-01-10T10:36:28.6570053

## Содержание

# Алгебра типов-произведений

## Кардинальность типов-произведений

**Кардинальность** типа — это количество всех возможных значений этого типа.

Примеры базовых типов:

- `Boolean` имеет кардинальность **2** (true, false)

- `Int` имеет кардинальность **2³²** (32-битное знаковое целое в Scala)

- `Unit` имеет кардинальность **1** (только одно значение: `()`)

- `Nothing` имеет кардинальность **0** (нет значений)

Для product типа кардинальность вычисляется как произведение кардинальностей его компонентов:

**|T₁ × T₂ × ... × Tₙ| = |T₁| × |T₂| × ... × |Tₙ|**

Примеры:

- `(Boolean, Boolean)` имеет кардинальность **2 × 2 = 4**

- `(Int, Boolean)` имеет кардинальность **2³² × 2**

- `(Unit, Int)` имеет кардинальность **1 × 2³² = 2³²** (эквивалентно `Int`)

- `(Boolean, Unit, String)` = **2 × 1 × |String| = 2 × |String|**

## Математические свойства произведения типов

Product types обладают алгебраическими свойствами:

- **Коммутативность:** `A × B ≅ B × A` (изоморфны)

- **Ассоциативность:** `(A × B) × C ≅ A × (B × C)`

- **Нетральный элемент:** `A × Unit ≅ A`

- **Поглощающий элемент:** `A × Nothing ≅ Nothing`

где,

- A и B - произвольные типы,

- символ `≅` означает *изоморфизм* — типы можно однозначно преобразовать друг в друга.

// Коммутативность: типы разные, но изоморфны
val person1: (String, Int) = ("Alice", 30)
val person2: (Int, String) = (30, "Alice")
// Это РАЗНЫЕ типы в системе типов Scala!

// Но мы можем создать изоморфное преобразование:
def swap(pair: (String, Int)): (Int, String) = (pair._2, pair._1)
val swapped = swap(person1) // (30, "Alice"): (Int, String)

// Ассоциативность
type ABC1 = ((String, Int), Boolean) // ((a, b), c)
type ABC2 = (String, (Int, Boolean)) // (a, (b, c))
// Изоморфны: можно преобразовать туда и обратно

// Нетральный элемент: Unit не добавляет информации
val withUnit: (String, Unit) = ("hello", ())
val justString: String = withUnit._1
// (String, Unit) ≅ String

// Поглощающий элемент: невозможно создать значение
// val impossible: (String, Nothing) = ??? // Не скомпилируется!

**Тип Unit как нейтральный элемент в алгебре:**

- `Unit` соответствует единице в алгебре типов (как 1 в умножении: 1 × x = x)

- В логике `Unit` соответствует истине (⊤)

- `Unit` не несёт данных, поэтому не влияет на информационную ёмкость произведения

**Тип Nothing как поглощающий элемент в алгебре:**

- `Nothing` соответствует нулю в алгебре типов (как 0 в умножении: 0 × x = 0)

- В логике `Nothing` соответствует лжи (⊥), также называется *bottom type*

- `Nothing` — это тип без значений, поэтому product с `Nothing` невозможно создать

// Невозможно создать значение типа (String, Nothing)
val impossible: (String, Nothing) = ("hello", ???)
// Не существует значения типа Nothing, которое можно подставить!

##  

---

### Полные данные JSON

<details>
<summary>Показать JSON данные</summary>

```json
{
  "name" : "text",
  "text" : "<h1 style=\"text-align:center;\">Алгебра типов-произведений</h1>\n\n<h2 style=\"text-align:center;\">Кардинальность типов-произведений</h2>\n\n<p><strong>Кардинальность</strong> типа — это количество всех возможных значений этого типа.</p>\n\n<p>Примеры базовых типов:</p>\n\n<ul>\n\t<li><code>Boolean</code> имеет кардинальность <strong>2</strong> (true, false)</li>\n\t<li><code>Int</code> имеет кардинальность <strong>2³²</strong> (32-битное знаковое целое в Scala)</li>\n\t<li><code>Unit</code> имеет кардинальность <strong>1</strong> (только одно значение: <code>()</code>)</li>\n\t<li><code>Nothing</code> имеет кардинальность <strong>0</strong> (нет значений)</li>\n</ul>\n\n<p>Для product типа кардинальность вычисляется как произведение кардинальностей его компонентов:</p>\n\n<p><strong>|T₁ × T₂ × ... × Tₙ| = |T₁| × |T₂| × ... × |Tₙ|</strong></p>\n\n<p>Примеры:</p>\n\n<ul>\n\t<li><code>(Boolean, Boolean)</code> имеет кардинальность <strong>2 × 2 = 4</strong></li>\n\t<li><code>(Int, Boolean)</code> имеет кардинальность <strong>2³² × 2</strong></li>\n\t<li><code>(Unit, Int)</code> имеет кардинальность <strong>1 × 2³² = 2³²</strong> (эквивалентно <code>Int</code>)</li>\n\t<li><code>(Boolean, Unit, String)</code> = <strong>2 × 1 × |String| = 2 × |String|</strong></li>\n</ul>\n\n<h2 style=\"text-align:center;\">Математические свойства произведения типов</h2>\n\n<p>Product types обладают алгебраическими свойствами:</p>\n\n<ol>\n\t<li><strong>Коммутативность:</strong> <code>A × B ≅ B × A</code> (изоморфны)</li>\n\t<li><strong>Ассоциативность:</strong> <code>(A × B) × C ≅ A × (B × C)</code></li>\n\t<li><strong>Нетральный элемент:</strong> <code>A × Unit ≅ A</code></li>\n\t<li><strong>Поглощающий элемент:</strong> <code>A × Nothing ≅ Nothing</code></li>\n</ol>\n\n<p>где,</p>\n\n<ul>\n\t<li>A и B - произвольные типы,</li>\n\t<li>символ <code>≅</code> означает <em>изоморфизм</em> — типы можно однозначно преобразовать друг в друга.</li>\n</ul>\n\n<pre><code class=\"language-scala\">// Коммутативность: типы разные, но изоморфны\nval person1: (String, Int) = (\"Alice\", 30)\nval person2: (Int, String) = (30, \"Alice\")\n// Это РАЗНЫЕ типы в системе типов Scala!\n\n// Но мы можем создать изоморфное преобразование:\ndef swap(pair: (String, Int)): (Int, String) = (pair._2, pair._1)\nval swapped = swap(person1) // (30, \"Alice\"): (Int, String)\n\n// Ассоциативность\ntype ABC1 = ((String, Int), Boolean)  // ((a, b), c)\ntype ABC2 = (String, (Int, Boolean))  // (a, (b, c))\n// Изоморфны: можно преобразовать туда и обратно\n\n// Нетральный элемент: Unit не добавляет информации\nval withUnit: (String, Unit) = (\"hello\", ())\nval justString: String = withUnit._1\n// (String, Unit) ≅ String\n\n// Поглощающий элемент: невозможно создать значение\n// val impossible: (String, Nothing) = ??? // Не скомпилируется!\n</code></pre>\n\n<p><strong>Тип Unit как нейтральный элемент в алгебре:</strong></p>\n\n<ul>\n\t<li><code>Unit</code> соответствует единице в алгебре типов (как 1 в умножении: 1 × x = x)</li>\n\t<li>В логике <code>Unit</code> соответствует истине (⊤)</li>\n\t<li><code>Unit</code> не несёт данных, поэтому не влияет на информационную ёмкость произведения</li>\n</ul>\n\n<p><strong>Тип Nothing как поглощающий элемент в алгебре:</strong></p>\n\n<ul>\n\t<li><code>Nothing</code> соответствует нулю в алгебре типов (как 0 в умножении: 0 × x = 0)</li>\n\t<li>В логике <code>Nothing</code> соответствует лжи (⊥), также называется <em>bottom type</em></li>\n\t<li><code>Nothing</code> — это тип без значений, поэтому product с <code>Nothing</code> невозможно создать</li>\n</ul>\n\n<pre><code class=\"language-scala\">// Невозможно создать значение типа (String, Nothing)\nval impossible: (String, Nothing) = (\"hello\", ???)\n// Не существует значения типа Nothing, которое можно подставить!\n\n</code></pre>\n\n<h2 style=\"text-align:center;\"> </h2>",
  "video" : null,
  "options" : {
    
  },
  "subtitle_files" : [
  ],
  "is_deprecated" : false
}
```

</details>
