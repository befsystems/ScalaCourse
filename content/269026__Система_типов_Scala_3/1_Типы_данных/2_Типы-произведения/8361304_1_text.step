{
  "step_id" : 8361304,
  "lesson_id" : 1880635,
  "position" : 1,
  "type" : "unknown",
  "block" : {
    "name" : "text",
    "text" : "<h1 style=\"text-align:center;\">Типы-произведения</h1>\n\n<p><strong>Тип-произведение</strong> (Product type) — это <strong>составной </strong>тип данных, представляющий собой упорядоченный и фиксированный набор значений разных типов в единой структуре, где каждый компонент сохраняет свой тип и значение, и может быть извлечен независимо.</p>\n\n<p>Название \"product\" происходит из <strong>теории категорий</strong>: если тип A содержит m значений, а тип B содержит n значений, то их произведение A × B содержит m × n возможных комбинаций. Это <strong>декартово произведение</strong> типов - И.</p>\n\n<h2 style=\"text-align:center;\">Представители Product Types в Scala</h2>\n\n<h3 style=\"text-align:center;\">Кортежи (Tuples)</h3>\n\n<p><strong>Назначение:</strong> быстрое создание временных структур данных без объявления типа.</p>\n\n<pre><code class=\"language-scala\">// Создание кортежа\nval point: (Int, Int) = (10, 20)\nval person = (\"Alice\", 30, \"Engineer\")</code></pre>\n\n<p><strong>Когда использовать:</strong></p>\n\n<ul>\n\t<li>Для возврата нескольких значений из функции</li>\n\t<li>Временные структуры данных</li>\n\t<li>Группировка данных в map/groupBy</li>\n</ul>\n\n<h3 style=\"text-align:center;\">Конструкция Case Class</h3>\n\n<p><strong>Назначение:</strong> моделирование данных предметной области с именованными полями.</p>\n\n<pre><code class=\"language-scala\">case class User(id: Long, name: String, email: String, active: Boolean)\n\nval user = User(1, \"Alice\", \"alice@example.com\", true)\n</code></pre>\n\n<p><strong>Когда использовать:</strong></p>\n\n<ul>\n\t<li>Моделирование бизнес-данных (domain model)</li>\n\t<li>Когда важна читаемость и самодокументирование кода</li>\n\t<li>Когда нужна семантика имён полей</li>\n\t<li>Публичные API</li>\n\t<li>Когда структура устойчива</li>\n</ul>\n\n<h2 style=\"text-align:center;\">Назначение типов-произведений</h2>\n\n<p><strong>1. Моделирование составных данных</strong></p>\n\n<p>Product types позволяют точно моделировать реальные сущности, которые имеют несколько независимых характеристик:</p>\n\n<pre><code class=\"language-scala\">// Точка имеет координаты x И y\ncase class Point(x: Double, y: Double)\n\n// Пользователь имеет имя И email И возраст\ncase class User(name: String, email: String, age: Int)\n</code></pre>\n\n<p><strong>2. Гарантия полноты данных</strong></p>\n\n<p>Например тип <code>(String, Int, Boolean)</code> гарантирует, что значение содержит <strong>ВСЕ три</strong> компонента. Невозможно создать \"частичное\" значение.</p>\n\n<pre><code class=\"language-scala\">// Определение типа-произведения (tuple)\ntype Person = (String, Int, Boolean)\n\n// ✅ Корректное создание — все три компонента присутствуют\nval validPerson: Person = (\"Alice\", 30, true)\n\n// ❌ Это не скомпилируется — недостаточно компонентов\n// val invalidPerson: Person = (\"Bob\", 25)\n// Found:    (String, Int)\n// Required: (String, Int, Boolean)</code></pre>\n\n<p> Безопасный рефакторинг:</p>\n\n<pre><code class=\"language-scala\">// Изменили структуру:\ncase class User(name: String, email: String) // убрали age\n\n// Компилятор сразу покажет ВСЕ места, где использовался age:\ndef greet(user: User) = s\"${user.name}, ${user.age}\" // ❌ Ошибка компиляции!\n</code></pre>\n\n<p><strong>3. Типобезопасность</strong></p>\n\n<p>Product types сохраняют тип каждого компонента, предотвращая ошибки:</p>\n\n<pre><code class=\"language-scala\">// ❌ Это не скомпилируется — неправильный тип компонента\n// val invalidPerson: Person = (\"Charlie\", \"35\", false)\n// Found:    (String, String, Boolean)\n// Required: (String, Int, Boolean)\n\n// ❌ Это не скомпилируется — неправильный порядок\n// val invalidPerson: Person = (30, \"David\", true)\n// Found:    (Int, String, Boolean)\n// Required: (String, Int, Boolean)\n</code></pre>\n\n<h2 style=\"text-align:center;\">Когда НЕ использовать Product Types</h2>\n\n<p>Product types не подходят когда:</p>\n\n<ol>\n\t<li><strong>Нужны взаимоисключающие альтернативы</strong>: используйте Sum Types для моделирования \"ИЛИ\"</li>\n\t<li><strong>Много опциональных полей</strong>: часто признак того, что нужен Sum Type с разными вариантами</li>\n\t<li><strong>Булевы флаги описывают состояние</strong>: замените на Sum Type с явными состояниями</li>\n\t<li><strong>Данные имеют разную структуру по типу</strong>: используйте Sum Type с разными case классами</li>\n\t<li><strong>Структура должна расширяться пользователями</strong>: используйте trait вместо case class</li>\n</ol>\n\n<h2 style=\"text-align:center;\"> </h2>\n\n<p> </p>\n\n<ul>\n</ul>\n\n<h2 style=\"text-align:center;\"> </h2>\n\n<ul>\n</ul>\n\n<h2 style=\"text-align:center;\"> </h2>\n\n<table>\n\t<thead>\n\t\t<tr>\n\t\t\t<th> </th>\n\t\t\t<th> </th>\n\t\t\t<th> </th>\n\t\t\t<th> </th>\n\t\t</tr>\n\t</thead>\n\t<tbody>\n\t\t<tr>\n\t\t\t<td> </td>\n\t\t\t<td> </td>\n\t\t\t<td> </td>\n\t\t\t<td> </td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td> </td>\n\t\t\t<td> </td>\n\t\t\t<td> </td>\n\t\t\t<td> </td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td> </td>\n\t\t\t<td> </td>\n\t\t\t<td> </td>\n\t\t\t<td> </td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td> </td>\n\t\t\t<td> </td>\n\t\t\t<td> </td>\n\t\t\t<td> </td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td> </td>\n\t\t\t<td> </td>\n\t\t\t<td> </td>\n\t\t\t<td> </td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td> </td>\n\t\t\t<td> </td>\n\t\t\t<td> </td>\n\t\t\t<td> </td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td> </td>\n\t\t\t<td> </td>\n\t\t\t<td> </td>\n\t\t\t<td> </td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td> </td>\n\t\t\t<td> </td>\n\t\t\t<td> </td>\n\t\t\t<td> </td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td> </td>\n\t\t\t<td> </td>\n\t\t\t<td> </td>\n\t\t\t<td> </td>\n\t\t</tr>\n\t</tbody>\n</table>",
    "video" : null,
    "options" : {
      
    },
    "subtitle_files" : [
    ],
    "is_deprecated" : false
  },
  "name" : "text",
  "course_id" : 269026,
  "course_name" : " Система типов Scala 3",
  "exported_at" : "2026-01-10T10:36:28.6456186"
}