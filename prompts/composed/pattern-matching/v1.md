# Составной промпт: Урок "Pattern Matching в Scala 3"

**Сгенерирован**: 2025-12-22
**Шаблон**: `templates/lesson-basic.md`
**Версия**: 1.0

---

# ПРОМПТ ДЛЯ СОЗДАНИЯ УРОКА

Создай урок "Pattern Matching в Scala 3" для начинающих программистов.

## Контекст проекта

- **Технический стек**: Scala 3.3.1, SBT 1.9.7, платформа Stepik
- **Целевая аудитория**: Начинающие программисты (базовые знания программирования)
- **Язык**: Русский
- **Формат**: Markdown для Stepik с интерактивными упражнениями

## Предварительные требования

Студент уже знает:
- Базовый синтаксис Scala
- Переменные и типы
- Case классы
- Базовые коллекции (List)

## Цели обучения

После прохождения урока студент должен уметь:
1. Использовать pattern matching с различными типами данных
2. Применять guards в pattern matching
3. Понимать exhaustiveness checking
4. Использовать pattern matching в реальных задачах

## Структура урока

Следуй стандартной структуре:

### 1. Введение (2-3 минуты)
- **Зацепка**: Покажи как pattern matching делает код проще и безопаснее
- **Мотивация**: Сравни с if-else цепочками в других языках
- **Связь**: Напомни про case классы из предыдущего урока
- **План**: Что узнает студент

### 2. Теоретическая часть (10-15 минут)
- Что такое pattern matching
- Синтаксис match expressions
- Как компилятор проверяет полноту (exhaustiveness)
- Преимущества перед if-else

**Принципы изложения**:
- Простым языком, короткие предложения
- Определяй все термины
- От простого к сложному

### 3. Примеры кода (8-12 минут)

Создай 4 примера нарастающей сложности:

#### Пример 1: Базовое использование (3-5 строк)
- Matching с константами (числа, строки)
- Показать синтаксис match/case
- Простой, понятный результат

#### Пример 2: Matching с типами (5-7 строк)
- Pattern matching с case классами
- Деструктуризация данных
- Использование переменных в patterns

#### Пример 3: Guards (8-10 строк)
- Добавление условий в case
- Комбинирование patterns и условий
- Практический пример (фильтрация данных)

#### Пример 4: Реальный use case (10-15 строк)
- Обработка разных типов пользователей или данных
- Комбинирование возможностей
- Читаемое решение бизнес-задачи

**Требования к примерам**:
- Все примеры должны компилироваться в Scala 3.3.1
- Использовать indent-based синтаксис Scala 3
- Говорящие имена переменных и функций
- Комментарии для ключевых моментов
- Показывать вывод/результат

### 4. Распространенные ошибки (3-5 минут)

Покажи 2-3 типичные ошибки:
- Забыли default case (не exhaustive match)
- Неправильный порядок cases (более общий перед специфичным)
- Как компилятор помогает избежать ошибок

Формат:
```scala
// ❌ Ошибка: [описание]
[неправильный код]

// ✅ Правильно: [объяснение]
[правильный код]
```

### 5. Лучшие практики (2-3 минуты)
- Всегда покрывать все случаи (exhaustiveness)
- Использовать pattern matching вместо if-else цепочек
- Порядок cases: от специфичного к общему
- Когда НЕ использовать pattern matching

### 6. Практическое задание (5-10 минут)

**Описание задачи**:
Создай функцию, которая принимает данные о фигурах (круг, прямоугольник, треугольник) и вычисляет площадь.

**Входные данные**:
```scala
enum Shape:
  case Circle(radius: Double)
  case Rectangle(width: Double, height: Double)
  case Triangle(base: Double, height: Double)
```

**Задание**:
Напиши функцию `calculateArea(shape: Shape): Double` используя pattern matching.

**Ожидаемый результат**:
```scala
calculateArea(Circle(5.0))              // 78.54
calculateArea(Rectangle(4.0, 5.0))      // 20.0
calculateArea(Triangle(4.0, 3.0))       // 6.0
```

**Подсказки**:
1. Используй match expression
2. Для каждого case деструктурируй параметры
3. Формулы площадей: круг = π*r², прямоугольник = w*h, треугольник = (b*h)/2

**Тесты** (автопроверка):
```scala
assert(calculateArea(Circle(5.0)) == 78.54 +- 0.01)
assert(calculateArea(Rectangle(4.0, 5.0)) == 20.0)
assert(calculateArea(Triangle(4.0, 3.0)) == 6.0)
```

### 7. Резюме (1-2 минуты)

Ключевые выводы (3-5 пунктов):
- Pattern matching делает код безопаснее и читаемее
- Компилятор проверяет полноту покрытия случаев
- Можно деструктурировать данные прямо в pattern
- Guards добавляют дополнительные условия

**Следующий урок**: Option и работа с отсутствующими значениями

## Требования к стилю кода

- **Синтаксис**: Scala 3 indent-based (без фигурных скобок где возможно)
- **Именование**: camelCase для переменных, PascalCase для классов
- **Комментарии**: Только для объяснения концепций, не для очевидного
- **Читаемость**: Код должен быть понятен начинающим

Примеры стиля:
```scala
// ✅ Хорошо: indent-based Scala 3
def describe(value: Int): String = value match
  case 0 => "zero"
  case n if n > 0 => "positive"
  case _ => "negative"

// ❌ Плохо: старый синтаксис с скобками
def describe(value: Int): String = value match {
  case 0 => "zero"
  case n if n > 0 => "positive"
  case _ => "negative"
}
```

## Прогрессивное усложнение

Каждый пример должен добавлять ОДНУ новую концепцию:
1. Пример 1: Базовый синтаксис match/case
2. Пример 2: + деструктуризация
3. Пример 3: + guards
4. Пример 4: + комбинирование в реальной задаче

Не вводи несколько новых концепций одновременно!

## Критерии качества

Проверь что урок:
- [ ] Содержит все 7 секций
- [ ] Объем 30-45 минут (800-1500 слов)
- [ ] Примеры компилируются в Scala 3.3.1
- [ ] Код использует indent-based синтаксис
- [ ] Язык доступен для начинающих
- [ ] Есть практическое задание с тестами
- [ ] Каждый пример добавляет одну концепцию

---

## Формат вывода

Создай урок в формате Markdown, готовый для загрузки на Stepik.

Начни с:
```markdown
# Pattern Matching в Scala 3

## Введение
[...]
```

И следуй структуре выше.
