# Модуль: Прогрессивное усложнение

## Назначение
Определяет принципы постепенного усложнения материала для эффективного обучения.

## Применимость
- Тип промпта: уроки, серии уроков
- Обязательный: рекомендуется
- Комбинируется с: lesson/*, common/*

## Содержание

### Принцип прогрессивного усложнения

Каждый новый элемент должен строиться на уже изученном материале, добавляя только ОДНУ новую концепцию за раз.

```
Известное + Одна новая концепция = Новое знание
```

### Уровни сложности

#### Уровень 1: Базовое знакомство
- Синтаксис и базовое использование
- Минимум деталей
- Акцент на "как использовать"

```scala
// Уровень 1: Знакомство с Option
val maybeNumber: Option[Int] = Some(42)
val value = maybeNumber.getOrElse(0)
```

#### Уровень 2: Расширение возможностей
- Дополнительные способы использования
- Простые комбинации
- Акцент на "что еще можно"

```scala
// Уровень 2: Работа с Option через map
val maybeNumber: Option[Int] = Some(42)
val doubled = maybeNumber.map(n => n * 2)
// doubled = Some(84)
```

#### Уровень 3: Комбинирование
- Использование нескольких возможностей вместе
- Реальные сценарии
- Акцент на "как это работает вместе"

```scala
// Уровень 3: Комбинирование операций
val maybeNumber: Option[Int] = Some(42)
val result = maybeNumber
  .filter(n => n > 0)
  .map(n => n * 2)
  .getOrElse(0)
```

#### Уровень 4: Нюансы и edge cases
- Детали работы
- Граничные случаи
- Акцент на "что важно знать"

```scala
// Уровень 4: Понимание None и цепочек
val maybeNumber: Option[Int] = None
val result = maybeNumber
  .filter(n => n > 0)  // не выполнится
  .map(n => n * 2)     // не выполнится
  .getOrElse(0)        // вернет 0
```

### Применение в уроках

#### В рамках одного урока

```
Введение
  ↓
Базовый синтаксис (Уровень 1)
  ↓
Одна дополнительная возможность (Уровень 2)
  ↓
Комбинирование (Уровень 3)
  ↓
Практическая задача (Уровень 3-4)
```

#### В рамках серии уроков

```
Урок 1: List - создание и базовые операции
  ↓
Урок 2: List - map, filter (на базе Урока 1)
  ↓
Урок 3: List - fold, reduce (на базе Уроков 1-2)
  ↓
Урок 4: Коллекции - Set, Map (используя знания о List)
```

### Связывание концепций

#### Техника "моста"

В начале нового урока напоминаем предыдущий материал:

```markdown
В предыдущем уроке вы узнали про List и операцию map.
Сегодня мы применим те же идеи к другим коллекциям.
```

#### Техника "фундамента"

Объясняем, как новое строится на старом:

```markdown
Option работает как List с 0 или 1 элементом:
- Some(x) похож на List(x)
- None похож на List()

Поэтому map работает одинаково!
```

### Признаки правильной прогрессии

✅ **Хорошо:**
- Студент понимает каждый шаг
- Новое не вызывает шока
- Видна логическая связь
- Можно самостоятельно догадаться о следующем шаге

❌ **Плохо:**
- Внезапное появление сложной концепции
- Использование неизученного материала
- Скачки в сложности
- Слишком много нового сразу

### Примеры правильной прогрессии

#### ✅ Хороший путь: изучение функций

```
1. Функция с одним параметром
   def double(n: Int): Int = n * 2

2. Функция с несколькими параметрами
   def add(a: Int, b: Int): Int = a + b

3. Функция, возвращающая функцию
   def multiplier(factor: Int): Int => Int =
     n => n * factor

4. Функции высшего порядка
   def applyTwice(f: Int => Int, x: Int): Int =
     f(f(x))
```

Каждый шаг добавляет ОДНУ новую идею:
1. Базовый синтаксис
2. Множественные параметры
3. Функции как значения
4. Функции как аргументы

#### ❌ Плохой путь: слишком быстро

```
1. Функция с параметром
   def double(n: Int): Int = n * 2

2. Функция высшего порядка с дженериками и каррированием
   def foldLeft[A, B](list: List[A])(initial: B)(f: (B, A) => B): B
```

Проблема: сразу 4 новые концепции (дженерики, каррирование, fold, функции высшего порядка).

### Адаптация под аудиторию

**Начинающие:**
- Медленная прогрессия
- Больше повторений
- Маленькие шаги

**Средний уровень:**
- Умеренная прогрессия
- Опора на знания из других языков
- Средние шаги

**Продвинутые:**
- Быстрая прогрессия
- Акцент на нюансы
- Большие шаги

## Примеры использования

В промпте для создания урока:
```
Следуй принципу прогрессивного усложнения:
- Каждый пример добавляет только одну новую концепцию
- Примеры идут от простого к сложному
- Новое строится на уже изученном
- В начале урока напомни предыдущий материал
- Покажи связь между концепциями
```

В промпте для серии уроков:
```
Серия из 3 уроков должна следовать прогрессии:
Урок 1 (базовый) → Урок 2 (расширение) → Урок 3 (комбинирование)

Каждый урок начинается с резюме предыдущего.
Новые концепции вводятся по одной.
```

## Версия
- Создан: 2025-12-22
- Обновлен: 2025-12-22
- Версия: 1.0
